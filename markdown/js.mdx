import ImageViewer from '@/components/image/ImageViewer';
import jsbook from '@/public/jsbook.jpeg';

# 자바스크립트

<ImageViewer src={jsbook} alt="책 표지" priority />

## 소개

지극히 주관적인 자바스크립트 공부 기록입니다. 공부하며 기억할만한 ~~얼척없던~~
것들을 이곳에 기록해요.

공부한 코드 바로 실행해보려고 컴포넌트도 따로 만들었어요:

```js
console.log('탭해서 펼치기');
console.log('🌸 🌼 🌸 🌼');
```

궁금한 부분이 있다면 맨 아래 댓글로 자유롭게 물어봐주세요.

## 1. Introduction to Javascript

코어 js에는 입출력 기능이 포함되어있지 않습니다. 입출력, 네트워크, 그래픽 등의
기능은 js가 임베딩된 호스트 환경의 책임입니다.

### 3. A Tour of JavaScript

```js
console.log([1, 2] + [3, 4, 5]);
```

**표현식**은 어떤 값으로 계산되지만 프로그램의 상태를 바꾸지는 않고, **문**은
값은 없지만 상태를 바꿉니다.

## 2. Lexical Structure

프로그래밍 언어의 lexical structure는 해당 언어로 프로그램을 어떻게 작성할지
알려주는 기본적인 규칙들입니다.

### 4. Identifiers and Reserved Words

쓸 일은 없지만, let도 변수명으로 경우에 따라 쓸 수는 있습니다. 주석을
해제해보세요:

```js
// 'use strict'
var let = 'hello, world!';
console.log(let);
```

### 5. Unicode

유니코드 값을 바꿔보세요:

```js
const π = 3.14;
console.log(π, '\u{1F600}');
```

<br />

```js
const str = [...Array(9).keys()]
  .map((x) => 0x1f311 + x)
  .map((x) => String.fromCodePoint(x))
  .join(' ');

console.log(str);
```

문자의 모양이 같더라도 다른 유니코드 값일 수 있습니다. 유니코드 표준에
normalization 알고리즘이 있지만 JS가 이를 처리해주지는 않으므로 에디터에서 잘
해주는지 확인합시다.

### 6. Optional Semicolons

세미콜론이 없으면 동작이 직관과 다른 경우가 있습니다.

```js
// prettier-ignore
let y = 1 + 2
(3 + 4).toString()
```

## 3. Types, Values, and Variables

JS는 함수와 클래스가 단순 언어 구문(syntax)의 일부가 아니라 코드에 의해 조작될
수 있는 값 점에서 다른 정적 언어들과 다릅니다.

### 1. Overview and Definitions

JS에서 문자열은 불변입니다. 이미 선언된 문자열의 일부를 수정할 수 없습니다.

```js
// 'use strict'
const str = 'javascript';
str[0] = 'd';
console.log(str);
```

### 2. Numbers

64비트 부동소수점을 사용합니다. 오버플로우가 발생해도 에러를 던지지는 않습니다.

```js
let val = Number.MAX_VALUE;
// (val + 1은 왜 Infinity가 아니지?)
console.log(val, val + 1, val ** 2);
console.log(val === val + 1);
```

하지만 배열 인덱싱이나 비트 연산등은 32비트 정수 연산을 합니다.

```js
console.log(1 << 30, 1 << 31, 1 << 32);
```

16진수도 아래처럼 바로 입력할 수 있습니다. CSS 색상값 넣을 때 종종 썼던 것
같아요.

```js
console.log(0x333);
```

이외에도 특이한 경우가 많습니다.

```js
console.log(1 / 0, 0 / 0, Infinity / 0, Infinity / Infinity);

let zero = 0;
let negZero = -0;
console.log(zero === negZero);
console.log(1 / zero === 1 / negZero);
```

NaN은 모든 값과 비교 결과가 false입니다. Number.isNaN 이나 isNaN을 씁시다.

https://stackoverflow.com/questions/33164725

```js
const val = NaN;
console.log(val === NaN, Number.isNaN(val));
```

아래와 같은 경우를 이해하려면 부동소수점 표준인 IEEE-754를 공부해봅시다:

```js
let x = 0.3 - 0.2;
let y = 0.2 - 0.1;
console.log(x === 0.1, y === 0.1);
```

부동소수점이 근사값을 사용하는게 문제라면 scaled integer를 사용해볼 수 있습니다.
이더리움에서는 wei라는 최소 단위(=10^(-18)ether)를 쓰는데 책에서 말하는 scaled
integer과 비슷한 것 같습니다.

BigInt와 Number간의 연산은 두 자료형이 포함관계가 아니므로 불가능합니다. 비교
연산은 가능합니다.

BigInt는 암호학에 쓰기는 부적합한데 timing attack에 대응하지 않기 때문입니다.

https://timing.attacks.cr.yp.to/programming.html

### 3. Text

UTF-16 인코딩을 사용합니다. Codepoint가 16비트에 들어가지 않는 유니코드 문자는
**surrogate pair**로 알려진 UTF-16의 시퀀스를 사용합니다.

대부분의 문자열 관련 메서드는 16비트 단위로 동작하고 surrogate pair를 특별
취급하지 않습니다. 다만 이터러블 관련(for/of...)은 실제 문자열처럼 되게
처리해줍니다.

```js
const euro = '€';
const love = '💙';
console.log(euro.length);
console.log(love.length);
console.log(love === '\ud83d\udc99');
console.log(love[0]);
for (const c of love) console.log(c);
```

문자열 표기법 별로 미묘하게 다른 newline 차이입니다.

```js
console.log(
  'one\
long\
line',
);

console.log(`two 
line`);
```

이런저런 문자열 관련 메서드들입니다:

```js
// d83d + dc99
const love = '💙';

console.log(love.charAt(0));

// returns an integer between 0 and 65535
// representing the UTF-16 code unit at the given index.
// may return lone surrogates
console.log(0xd83d === love.charCodeAt(0));
// 왜 0x1f499인지는..모르겠음..
console.log(love.codePointAt(0).toString(16));
```

String.prototype.normalize도 있는데 자세히는 보지 않았습니다.

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/normalize

Tagged tempalte literals는 styled-component에서 활용하는걸로 알고 있습니다:

```js
const str = String.raw`\n`;
console.log(str);
```

### 4. Boolean Values

```js
console.log(!!undefined);
console.log(!!null);
console.log(!!0);
console.log(!!-0);
console.log(!!NaN);
console.log(!!'');
```

### 5. null and undefined

**undefined**는 언어 키워드인 null과는 다르게 미리 정의된 전역 상수값으로
undefined로 초기화되어있습니다.

> undefined is a property of the global object. That is, it is a variable in
> global scope.
>
> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined

```js
console.log('undefined' in globalThis);
console.log('null' in globalThis);
```

### 6. Symbols

프로퍼티명을 심볼로 정하고 이를 공유하지 않으면 다른 모듈의 코드가 실수로 해당
프로퍼티를 건들지 않음을 보장받을 수 있습니다.

```js
const sym = Symbol();
let obj = {
  a: 1,
  [sym]: 2,
};

console.log(obj, Object.values(obj));
console.log(obj[sym]);
```

ES6에서 이터러블을 정의할 때 이터레이터 메서드를 문자열 이름으로 정해 표준화하면
기존 코드가 망가질 염려가 있었기에 symbolic name을 도입했습니다. Symbol.for
메서드는 비슷한 맥락에서 global Symbol registry로 기능합니다:

```js
let s = Symbol.for('shared');
let t = Symbol.for('shared');
console.log(s === t, s.toString(), Symbol.keyFor(t));
```

### 7. The Global Object

전역 객체의 프로퍼티들은 JS 프로그램에서 사용할 수 있는 전역적으로 정의된
식별자들입니다. undefined, isNaN(), String(), Math 등등...

브라우저에서 window 객체는 스스로를 참조하는 window 프로퍼티가 있어서 이
프로퍼티를 사용해 전역 객체에 접근할 수 있습니다. (뭔가 메타적이고 신기한듯,,,)
Web worker 스레드에서는 좀 다르다는데 이후 챕터해서 공부해봅시다.

원래는 노드에서는 global, 브라우저에서는 window로 전역 객체에 접근했지만
ES2020부터는 globalThis로 표준화되었습니다.

```js
console.log(window === globalThis);
console.log(window === window.window.window);
```

### 8. Immutable Primitive Values and Mutable Object References

객체는 참조하는 대상이 같아야 같습니다:

```js
let a = [1, 2, 3];
let b = [1, 2, 3];
console.log(a === b);
```

### 9. Type Conversions

~이딴게.. 언어...?~

원시값->원시값 변환 표입니다:

| Value     | to String   | to Number | to Boolean |
| --------- | ----------- | --------- | ---------- |
| undefined | 'undefined' | NaN       | false      |
| null      | 'null'      | 0         | false      |
| true      | 'true'      | 1         |            |
| false     | 'false'     | 0         |            |
| ""        |             | 0         | false      |
| " 1.2"    |             | 1.2       | true       |
| "one"     |             | NaN       | true       |
| 0         | '0'         |           | false      |
| -0        | '0'         |           | false      |
| 1         | '1'         |           | true       |
| Infinity  | 'Infinity'  |           | true       |
| -Infinity | '-Infinity' |           | true       |
| NaN       | 'NaN'       |           | false      |

객체->원시값 변환은 뒤에서 살펴볼게요.

#### Conversions and Equality

어떤 값이 다른 값으로 바뀐다고 두 값이 같음을 의미하지는 않습니다. 타입 변환
알고리즘과 연산자에서 사용하는 알고리즘이 상이하기 때문입니다. 아래 예제를
볼게요.

```js
console.log(Boolean(undefined)); // false로 변환됐습니다.
console.log(undefined == false); // 그렇다고 false와 == 하지는 않습니다.
```

#### Explicit Conversions

wrapper '객체'를 사용한 형변환 방식은 하위호환을 위해 있으니 사용하지 맙시다:

```js
const val = new Boolean('true');
console.log(typeof val);
```

숫자 관련 메서드들입니다:

```js
let n = 17;
console.log(`0b${n.toString(2)}`);
console.log(`0o${n.toString(8)}`);
console.log(`0x${n.toString(16)}`);
console.log();

n = 123456.789;
console.log(n.toString(2));
console.log(n.toFixed(2));
console.log(n.toFixed(5));
console.log(n.toExponential(1));
console.log(n.toExponential(3));
// precesion값이 정수 부분을 표현하지 못할 정도면 지수 표기법을 사용합니다.
console.log(n.toPrecision(4));
console.log(n.toPrecision(10));
console.log();

console.log(Number('3 eggs'));
console.log(parseInt('  3 eggs'));
console.log(parseInt('3.14'));
console.log(parseInt('0xF'));
console.log(parseFloat('.1'));
console.log(parseInt('.1'));
console.log(parseInt('ff'));
console.log(parseInt('ff', 16));
```

#### The toString() and valueOf() methods

객체 -> 원시값 변환 알고리즘을 이해하려면 두 메서드를 알아야해요. 모든 객체가 이
메서드들을 상속받습니다.

- 각 클래스는 각자의 toString을 구현합니다. 객체의 문자열 표현을 반환합니다.
- valueOf는 (만약 있다면) 객체를 표현하는 원시값을 반환합니다. 대부분은 이런
  원시값이 없기에 객체 자신을 반환합니다.

```js
console.log(new Boolean(true).valueOf());
console.log({ a: 1 }.valueOf());
console.log(new Date().valueOf());
```

#### object-to-primitive conversion algorithms

세 종류로 나뉘어 상황에 맞게 사용됩니다.

- prefer-string: toString이 **원시값을 반환한다면**(문자열이 아니더라도) 이를
  사용, 아니면 valueOf가 원시값 반환하면 이를 사용, 아니면 TypeError.
- prefer-number: prefer-string에서 valueOf와 toString 순서만 교체.
- no-preference: Date면 prefer-string, 다른 모든 빌트인 객체는 prefer-number

```js
console.log(Number([])); // valueOf 실패, toString에서 "", 0으로 변환
console.log(Number([9])); // valueOf 실패, toString에서 "9", 9로 변환
```

#### Object to Primitive Conversions

모든 객체는 불 값으로 변환시 true가 됩니다:

```js
console.log(Boolean(new Boolean(false)));
```

객체를 문자열로 변환해야하면 prefer-string 알고리즘으로 우선 변환하고 필요시
결과값을 위 표에 따라 문자열로 변환합니다.

숫자도 마찬가지로 prefer-number를 돌리고 숫자로 변환합니다. 다만 몇몇 연산자는
예외가 있습니다:

- '+' 연산자는 객체에 no-preference 알고리즘을 돌리고, 이후 피연산자중 하나라도
  문자열이면 문자열 concat을, 그렇지 않다면 숫자로 둘 다 수정합니다.
- '==' 와 '!='는 피연산자 하나만 객체면 해당 객체를 no-preference 알고리즘을
  사용해 원시값으로 수정 후 비교합니다.
- 부등호 연산자는 둘 다 객체면 prefer-number 알고리즘으로 변환 후 비교합니다.
  다만 prefer-number에서 반환된 원시값을 숫자로 형변환하지 않습니다.

```js
const a = {
  valueOf: () => 'not a number',
  //  valueOf: () => 123,
};

console.log(a + '', a + 1);
```

### 10. Variable Declaration and Assignment

확실히 안바뀌는 값에만 const를 쓰는 사람들이 있고, 일단 const로 선언하고 나중에
바뀌어야한다면 let으로 수정하는 사람들이 있습니다. 아래는 참고할만한
아티클입니다.

https://overreacted.io/on-let-vs-const/

for문에서도 const를 쓸 수 있습니다:

```js
for (const datum of [1, 2, 3]) console.log(datum);
for (const i = 0; i < 5; i++) console.log(i);
```

let과 const는 block scope입니다.

Top level에서 선언되면 **전역 변수/상수**라고 합니다. 노드와 client-side js
module에서 전역 값의 스코프는 파일입니다. Traditional client-side js에서는 html
document입니다. 한 스크립트에서 선언한 전역 값을 다른 스크립트에서 사용할 수
있습니다.

var는 포함하는 함수 body 내부에 스코핑?됩니다:

```js
for (var i = 0; i < 10; i++);
console.log(i);
```

함수 바깥에서 선언하면 전역 변수가 되는데, globalThis에 포함된다는 점이 var와
let/const의 차이입니다:

```js
var a = 1;
let b = 1;
console.log(globalThis.a, globalThis.b);
```

var는 중복 선언을 제한하지 않습니다. 또한 hoisting이 이루어집니다. 즉 변수의
선언이 변수를 포함하는 스코프 최상단으로 이동합니다:

```js
var a = 10;
var a = 20;
console.log(a);

console.log(b);
var b = 10;

console.log(c);
let c;
```

<br />

```js
console.log('이 줄은 실행되지 않습니다');
let a;
let a;
```

strict mode의 유무에 따라 선언되지 않는 변수에 대한 처리가 달라집니다. strict
mode가 아니면 새로운 전역 변수가 생성됩니다. 이러한 변수는 var로 선언된 변수와
특성이 '유사'합니다.

```js
(() => {
  a = 10;
})();

console.log(a);

(() => {
  'use strict';
  b = 10;
})();
```

Destructuring assignment에서 이런 것도 가능합니다:

```js
let [, x, , y] = [1, 2, 3, 4];
console.log(x, y);

let [first, ...rest] = 'Hello';
console.log(first, rest);
```

## 4. Expressions and Operators

### 1. Primary Expressions

최소 단위의 표현식을 **primary expression**이라 합니다. 아래와 같은 것들이
있어요:

```js
// literal
console.log(1.23, 'hello', /pattern/);

// language keywords
console.log(true, false);

// variable reference
let val = 10;
console.log(val, undefined);
```

undefined는 전역 객체의 프로퍼티 값이라서 리터럴이나 키워드가 아닌 varaible
reference입니다:

```js
console.log('undefined' in window);
console.log(window.undefined === undefined);
```

### 2. Object and Array Initializers

Array initializer 내부의 표현식은 매번 평가됩니다:

```js
let f = () => [Math.random()];
console.log(f());
console.log(f());
```

쉼표 사이를 비워 undefined를 배열 사이에 넣을 수 있어요.

```js
// 실행 컴포넌트의 한계(...)로 지금은 undefined가 안뜹니다
// 브라우저 콘솔에 넣어보세요!
console.log([1, , , 4, 5]);
```

### 3. Function Definition Expressions

객체를 만드는 객체 리터럴처럼 function definition expression은 함수 리터럴로 볼
수 있습니다. ES6에서 추가된 화살표 함수와 함께 챕터 8에서 자세하게 살펴볼게요.

```js
let square = function (x) {
  return x * x;
};
```

### 4. Property Access Expressions

null과 undefined는 프로퍼티를 가지지 않습니다.

```js
let val = 2; // null이나 undefined로 수정해보세요
console.log(val.toString());
```

대괄호를 사용한 프로퍼티 참조에서는 대괄호 내부의 표현식이 문자열로 변환됩니다.

```js
let name = {};
name.toString = () => 'str';
console.log(String(name));

let obj = { [name]: 'name' };
console.log(obj);
```

대괄호를 사용한 방법은 프로퍼티 이름에 공백이나 문장부호가 있을 때, 프로퍼티
이름이 숫자일 때(배열), 프로퍼티 이름이 동적으로 정해질 때 사용돼요.

ES2020에서는 optional chaining을 사용한 프로퍼티 접근이 추가되었습니다. **? 왼쪽
값이 null/undefined면** 최종 평가 결과가 undefined가 됩니다.

```js
let a = null;
let b = { val: 10 };
console.log(a?.val, b?.val);
console.log(a?.b.c.d.e.f.g);

let c = { d: {} };

try {
  c.d?.e.f;
} catch {
  console.log('c.d가 객체여서 short-circuit되지 않습니다');
}
```

<br />

```js
let arr;
let index = 0;
arr?.[index++];
console.log(index); // 대괄호 내부 표현식이 평가되지 않았습니다.
```

### 5. Invocation Expressions

Conditional invocation의 예시입니다:

```js
function square(x, log) {
  log?.(x); // 함수인지 아닌지는 체크하지 않습니다.
  return x * x;
}

square(1, 1);
```

Conditional invocation의 short circuit 관련 특징입니다:

```js
let f = null,
  x = 0;

try {
  f(x++);
} catch {}
console.log(x); // 인자로 전달된 표현식이 평가되었습니다.

f?.(x++); // 평가되지 않습니다.
console.log(x);
```

### 6. Object Creation Expressions

(굳이 싶지만 ㅎ,,) 생성자에 전달되는 인자가 없으면 아래와 같은 문법도
가능합니다:

```js
// prettier-ignore
console.log(new Date);
```

### 7. Operator Overview

모든 자바스크립트 값들은 truthy 혹은 falsy합니다. 따라서 피연산자로 불 값을 받는
연산자는 자동 형변환 덕분에 무슨 값에 대해서든 잘 동작합니다.

변수, 객체 프로퍼티, 배열의 요소는 모두 lvalue입니다.

Side effect가 있는 연산자들:

- Assigment operator
- increment, decrement operator
- delete operator
- some function/object creation

할당 연산자는 우선순위가 아주 낮아 거의 마지막에 적용됩니다. 프로퍼티 접근(a.b)
및 함수 실행 연산자(f())는 우선순위가 아주 높습니다.

최근에 추가된 몇몇 연산자들은 우선순위가 명확히 정의되어 있지 않고 애매한 경우
아래와 같이 에러가 발생합니다:

```js
-2 ** 10
```

연산자의 결합 방향(associativity)의 예제 코드입니다:

```js
let a = 2,
  b = 1,
  c = 4;

// left-to-right associativity
console.log(a - b - c);

// right-to-left
// prettier-ignore
console.log(a ** b ** c);
console.log((a = b = c), a);

console.log(a ? b : c ? a : b);
// (a ? b : (c ? a : b))
```

표현식은 연산자의 우선순위나 결합 방향에 상관없이 왼쪽에서 오른쪽 방향으로
평가됩니다:

```js
let helper = (n) => () => (console.log(n), n);

let f = helper(1);
let g = helper(2);
let h = helper(3);

console.log(f() + g() * h());
console.log(f() * g() + h());
```

### 8. Arithmetic Expressions

0/0은 NaN입니다.

> Because that's how floating-point is defined (more generally than just
> Javascript)
>
> https://stackoverflow.com/questions/18838301

나머지(%) 연산자 결과의 부호는 첫번째 피연산자의 부호와 같습니다.

```js
console.log(5 % 2, -5 % 2);
```

덧셈 연산자 알고리즘:

1. 두 피연산자 중 하나라도 객체면 no-preference 알고리즘을 통해 원시값으로
   변환합니다. 즉 Date 객체는 prefer-string, 나머지 객체는 prefer-number를
   사용합니다.
1. 피연산자의 변환 결과 중 하나라도 문자열이면 나머지도 문자열로 바꾸고 문자열
   덧셈을 수행합니다.
1. 아니면 숫자로 바꾸고 숫자 덧셈을 수행합니다.

```js
let a = { valueOf: () => 1 };
let b = { valueOf: () => 2 };
let c = { valueOf: () => '3' };
let d = { toString: () => 1 };

console.log(a + b);
console.log(b + c);
console.log(d + 1);
```

참고할만한 링크에요:

> Actually, no. Because in step 5 and 6, both operands are resolved into their
> primitives first, and this resolution is done without "hint". When there is no
> hint passed to ToPrimitive, Objects return their default values, which is the
> return of the valueOf() method.
>
> https://stackoverflow.com/questions/38937118/

갑자기 생각난 재미있는 상황:

```js
let obj = { valueOf: () => obj };
console.log(Number(obj));

obj = { toString: () => obj };
console.log(String(obj));
```

시프트 연산자의 두 번째 피연산자는 0 이상 32 미만의 값만 가능하고 이를 위해
피연산자에서 하위 5개의 비트만 남깁니다:

```js
console.log(32 >> (1024 + 1));
console.log(32 >> NaN);
console.log(32 >> Infinity);
console.log(32 >> -Infinity);
```

Unsigned right shift는 bigint를 쓸 수 없는 유일한 비트 연산자입니다.

> This is because it fills the leftmost bits with zeroes, but conceptually,
> BigInts have an infinite number of leading sign bits, so there's no "leftmost
> bit" to fill with zeroes.
>
> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift

```js
console.log(-1 >> 1);
console.log(-1 >>> 1);

console.log(-1n >> 1n);
console.log(-1n >>> 1n);
```

### 9. Relational Expressions

==는 레거시 취급합시다.

NaN은 그 어떤 값과도 같지 않습니다:

```js
console.log(NaN === NaN, NaN == NaN);

let 난인가요 = (x) => x !== x;
console.log(난인가요(NaN));
```

두 문자열이 같아 보여도 다른 유니코드 시퀀스로 인코딩되어있으면 다릅니다.

== 연산자는 다음 규칙을 사용합니다:

```js
// null과 undefiend는 같습니다
console.log(null == undefined);

// 숫자와 문자열 비교는 문자열을 숫자로 바꿉니다.
console.log(123 == ' 123');

// 하나가 불 값이면 이를 숫자로 바꿉니다.
console.log('1' == true);
// -> '1' == 1
// -> 1 == 1
// -> true

// 하나가 객체고 나머지가 숫자/문자열이면 객체를 원시값으로 변환하고 비교합니다.
let a = { valueOf: () => 1 };
console.log(a == 1);

let b = { toString: () => '!@#' };
console.log(b == '!@#');

// 나머지 조합은 모두 false입니다.
```

비교 연산자에서는 다음 규칙을 사용합니다:

```js
// 둘 다 문자열이면 문자열 비교를 합니다.

// 하나라도 객체면 숫자로 변환합니다(valueOf 실패시 toString)
let a = { valueOf: () => 1 };
console.log(a < 2);

// 하나라도 문자열이 아니면 숫자로 변환 후 비교합니다.
let b = { toString: () => '  5' };
console.log(4 < b, b < 6);

// 하나라도 NaN이면 false입니다.
```

문자열 비교는 결과적으로 16비트 정수 배열의 비교라서 결과값이 예상과 다를 수
있습니다:

```js
console.log('Z' < 'a');
console.log('Z'.localeCompare('a'));
```

비교 연산자와 다르게 + 연산자는 둘 중 하나라도 문자열이면 나머지를 문자열로
바꿉니다:

```js
console.log('1' + 2);
console.log('11' < 3);

// 그래서 이런 식으로 문자열 형변환을 하는 경우도 있어요.
console.log(123 + '');
```

`<=`나 `>=`는 같은지는 체크하지 않고 >와 < 의 부정으로 정의됩니다.

in 연산자는 첫번째 피연산자를 필요시 문자열로 변환합니다:

```js
let a = { toString: () => '0' };
console.log(a in [123]);
console.log(a in []);
```

### 10. Logical Expressions

방금 살펴본 relational operator들은 &&, || 보다 우선순위가 높습니다.

Side effect가 있는 표현식을 &&나 || 오른쪽에 쓸 때는 실행이 될 수도 안될 수도
있으니 주의합시다.

### 11. Assigment Expressions

```js
let a;
let b = 1;
console.log((a = b) === 1, a);
```

`a op= b`와 `a = a op b`가 다른 경우가 있습니다:

```js
let data = [0, 1, 2];
let i = 0;
let log = () => console.log(data[0], data[1], data[2]);

// a op= b
data[i++] *= 2;
log();

data = [0, 1, 2];
i = 0;

// a = a op b
data[i++] = data[i++] * 2;
log();
```

### 12. Evaluation Expressions

```js
let a = 1;
console.log(eval('a'));
```

지역 변수 접근으로 인한 최적화의 어려움때문에 인터프리터는 eval을 호출한 함수를
덜 최적화합니다. 그렇다고 alias된 이름으로 eval을 호출하는 경우까지 컴파일러가
알 수는 없으므로 이렇게 실행된 경우 eval은 전역 스코프에서 동작합니다. 이를
eval의 **indirect call**이라 하며 코드를 독립된 top-level 스크립트로 실행시킬 때
유용하게 활용됩니다.

```js
let a = 1;
console.log((0, eval)('a'));
```

strict mode에서는 eval이 reserved word가 되는 등 함수보다 키워드에 가까워집니다.

### 13. Miscellaneous Operators

First-defined (??) 연산자는 첫 피연산자가 null이나 undefined면 두번째
피연산자를, 아니면 첫번째 피연산자를 반환합니다. Truthy함이 기준인 ||와 다르게
정의만 되어있으면 됩니다:

```js
console.log(0 || 1);
console.log(0 ?? 1);
```

이상하지만 `typeof null === 'object'`입니다:

https://stackoverflow.com/a/18808270

void 연산자는 피연산자를 평가하고 undefined를 반환합니다:

```js
let a = 0;
let inc = () => void a++;
console.log(inc(), a);
```

Comma operator는 왼쪽 표현식들의 결과를 버리기 때문에 side effect가 있는
표현식들을 쓸 때만 의미있습니다. 써본 적 없는 것 같아도 for문에서 종종 사용돼요:

```js
for (let i = 1, j = 4; j; i++, j--) {
  console.log('*'.repeat(i) + ' '.repeat(j));
}
```

## 5. Statements

표현식은 평가되어 값이 되지만 문(statements) 실행되어 어떤 일을 일으킵니다.
자바스크립트 프로그램은 세미콜론으로 구분된 문들의 나열이에요.

### 2 Compound and Empty Statements

Statement block은 여러 문들을 하나의 compound statements로 묶습니다.
세미콜론으로 끝나지 않음이 특징입니다.

```js
{
  let a = 10;
  let b = 20;
}
```

여러 종류의 JS 문들이 하나의 자식 문을 가질 수 있는데, compound statement를
사용해 자식 문에 원하는 만큼의 문을 집어넣을 수 있습니다.

반대되는 역할의 문으로 empty statement가 있습니다:

```js
let sum = 0;
// prettier-ignore
for (let x = 1; x <= 10; sum += x++) /* empty */;
console.log(sum);
```

### 3. Conditionals

JS에 else if 라는 별도의 문법?이 있는건 아니고 그냥 else문이랑 if문이랑
붙은거라고 해요:

https://stackoverflow.com/a/4005623

switch문에서는 같음을 === 연산자를 사용해 판단합니다.

### 4. Loops

흔하진 않지만 for문에서 initialize문이 없는 경우도 있습니다:

```js
let list = { val: 1, next: { val: 2, next: { val: 3 } } };

let print = (l) => {
  for (; l; l = l.next) console.log(l.val);
};

print(list);
```

for of에서 배열 순회중에 배열이 수정되면 순회 과정에 영향을 줍니다.

```js
let arr = [1];
for (let element of arr) {
  arr.push(element * 2);
  if (100 < element) break;
}
console.log(arr);
```

Map을 for of로 순회하면 키와 값이 모두 나옵니다:

```js
let m = new Map([[1, 'one']]);
for (let [k, v] of m) console.log(k, v);
```

뒤에서 배울 for/await 예제 미리보기:

```js
async function printStream(stream) {
  for await (let chunk of stream) {
    console.log(chunk);
  }
}
```

for/in은 객체면 다 됩니다. Enumerable한 스스로의 문자열 키들을 순회합니다. 다만
상속받은 프로퍼티도 순회하기에 for/in대신 for/of와 Object.keys()를 쓰는 경우가
많습니다.

### 5. Jumps

break, continue의 기능을 포함한다면 while문으로 for문을 완벽하게 재현하는 것은
불가능합니다.

JS가 에러를 던질 때 Error 클래스와 그 서브클래스를 사용합니다. name 프로퍼티는
에러의 종류를 나타내고 message는 생성자 함수에 전달된 문자열입니다.

finally 블록은 try절 실행 이후 cleanup을 위해 주로 사용됩니다. try+finally
조합도 가능합니다. finally 블록이 return/continue/break/throw등으로 점프를
한다면 기존에 예약?된 점프는 무시됩니다:

```js
let f = () => {
  try {
    throw new Error('Error!!');
  } finally {
    // 아래 주석을 해제해보세요.
    // return;
  }
};

f();
console.log('실행 완료');
```

아래처럼 while로 for문을 재현할 수 있어요. 다만 break문에 대해서는 실행 결과가
조금 다릅니다. finally문을 이렇게 쓰는게 신기해서 가져왔습니다:

```js
let i = 0;
while (i < 10) {
  try {
    if (i % 2 == 0) continue;
    console.log(i);
  } finally {
    i++;
  }
}
```

### 6. Miscallaneous Statements

with문은 객체의 프로퍼티를 변수가 선언된 것처럼 쓸 수 있게 합니다. 쓰지 마세요.

debugger문은 브라우저등에서 breakpoint로 기능합니다.

'use strict'는 코드를 strict mode로 동작하게합니다. ES6 module, class 내부에
있는 코드에는 자동적용됩니다. strict mode에서는 대표적으로 다음과 같은 차이점이
있어요:

- with 사용 불가
- 선언되지 않은 변수 사용 불가
- (메서드가 아닌) 함수로 호출된 함수의 this값이 undefined

책에서는 strict mode에서 duplicated property name이 안된다고 했는데 ES2015부터
다시 허용하나봅니다:

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Duplicate_property_names

### 7. Declarations

선언문(declarations)은 값에 이름을 부여해서 다른 구문들의 의미를 정의합니다.

모던 JS에서 var를 쓸 이유는 없습니다.

함수 선언은 호이스팅되어 다른 코드보다 먼저 처리됩니다. 클래스 선언은
호이스팅되지 않아요:

```js
f(5);

// (함수 내부 변수가 존재하는지는 함수 실행 전까지는 확인 안하는건가?)
function f(n) {
  console.log('f');
  n && g(n - 1);
}

function g(n) {
  console.log('g');
  n && f(n - 1);
}

let a = new A();
class A {}
```

## 6. Objects

### 1. Introduction to Objects

다른 기능들도 있지만 기본적으로 객체는 문자열을 값으로 매핑합니다. JS 객체는
다른 객체(프로토타입)로부터 프로퍼티를 상속받고 이를 **prototypal
inheritance**라 합니다.

신기하게도 프로퍼티 이름으로 빈 문자열도 가능합니다:

```js
let a = { '': 1 };
console.log(a['']);
```

상속받지 않은 객체의 프로퍼티를 **own property**라 합니다.

각 프로퍼티는 아래 세 attribute들을 가집니다:

- writable: 프로퍼티 값을 설정할 수 있는지
- enumerable: for/in 루프로 순회할 수 있는지
- configurable: 프로퍼티를 삭제하거나 attribute를 수정할 수 있는지

### 2. Creating Objects

중요한 문장이라고 생각해서 그대로 긁어왔어요:

> Remember: almost all objects have a **prototype**, but only a relatively small
> number of objects have `prototype` property. It is these objects with
> `prototype` properties that define the **prototypes** for all the other
> objects.

Object.create의 인자는 생성된 객체의 프로토타입이 됩니다:

```js
let obj1 = {};
console.log(String(obj1));

let obj2 = Object.create(null);
console.log(String(obj2));
```

### 3. Querying and Setting Properties

일반 객체가 연관 배열(딕셔너리)로 자주 활용되기는 하지만 Map 클래스가 더 나은
경우가 있습니다.

같은 이름의 프로퍼티가 프로토타입 체인의 다른 곳에 위치할 수 있습니다:

```js
let a = { x: 1 };
let b = Object.create(a);
console.log(a, b);

b.x = 2;
console.log(a, b);
```

위 코드와 같은 특징 덕분에 상속받은 프로퍼티를 선택적으로 override할 수
있도록합니다. 다만 setter 메서드 관련해서 예외가 있습니다:

```js
let parent = {
  set val(x) {
    this.y = 1;
  },
};

let child = Object.create(parent);

child.val = 2; // child에 프로퍼티가 추가되지 않고 parent의 setter가 호출됩니다.
console.log(parent, child); // setter에서 추가한 프로퍼티는 child에 추가됩니다.
```

### 4. Deleting Properties

delete 연산자는 객체 자신의 프로퍼티만 삭제합니다.

암묵적으로/명시적으로 선언된 변수들의 차이가 delete 연산자에 관련하여 있습니다:

```js
// 원래는 var로 선언한 경우 삭제가 안되어야하는데
// 콘솔 컴포넌트를 eval로 구현해서 차이가 생기는 것 같아요 (확인 필요)
// 브라우저 콘솔에서 실행해보세요 :(
var a = 10;
console.log(globalThis.a);
delete globalThis.a;
console.log(globalThis.a);

b = 20;
console.log(globalThis.b);
delete globalThis.b;
console.log(globalThis.b);
```

### 5. Testing Properties

```js
let a = Object.create({ x: 1 });
a.y = 2;

console.log('x' in a);
console.log(a.hasOwnProperty('x'));

// 스스로의 enumerable한 프로퍼티인지
console.log(a.propertyIsEnumerable('x'));
console.log(a.propertyIsEnumerable('y'));
```

프로퍼티 유무 확인에서 in 연산자와 !== undefined의 차이:

```js
let a = { x: undefined };
console.log('x' in a, a.x !== undefined);
console.log('y' in a, a.y !== undefined);
```

### 6. Enumerating Properties

```js
let a = { x: 1 };
let b = Object.create(a);
b.y = 2;
b[Symbol()] = 3;

// own&inherited enumerable string
for (i in b) console.log(i);
// own enumerable string
console.log(Object.keys(b));
// own (non)enumerable string
console.log(Object.getOwnPropertyNames(b));
// own (non)enumerable symbols
console.log(Object.getOwnPropertySymbols(b));
// own (non)enumeratble string&symbols
console.log(Reflect.ownKeys(b));
```

각종 메서드들의 프로퍼티 순회 순서입니다:

1. 0이상의 자연수를 순서대로
1. 문자열은 추가한 순서대로(리터럴에 있는 순서대로)
1. 심볼도 추가한 순서대로

for-in의 순서는 표준에 자세히 명시되어있진 않다는데,,, 최근에 수정된 것
같습니다:

https://stackoverflow.com/questions/30076219/does-es6-introduce-a-well-defined-order-of-enumeration-for-object-properties

### 7. Extending Objects

객체의 복사가 자주 있어서 ES6에서 `Object.assign()`을 추가했습니다. 두번째 이후
인자들의 enumerable/own/string+symbol 프로퍼티들을 첫번째 인자 객체로
복사합니다.

### 8. Serializing Objects

```js
console.log(JSON.stringify([NaN, Infinity, -Infinity]));
console.log(JSON.parse(JSON.stringify(new Date()))); // parse 후에도 문자열입니다.
```

stringify는 own enumerable property만 처리합니다.

### 9. Object Methods

Object.prototype에서 상속되는 메서드들:

```js
let point = {
  x: 3,
  y: 4,

  toString() {
    return `(${this.x}, ${this.y})`;
  },

  toLocaleString() {
    return `(${this.x.toLocaleString()}, ${this.y.toLocaleString()})`;
  },

  valueOf() {
    return Math.hypot(this.x, this.y);
  },

  // Object.prototype에는 없지만 JSON.stringify가 봅니다
  toJSON() {
    return this.toString();
  },
};

console.log(String(point), Number(point), JSON.stringify(point));
```

### 10. Extended Object Literal Syntax

심볼은 opaque value입니다:

> In computer science, an opaque data type is a data type whose concrete data
> structure is not defined in an interface.
>
> https://en.wikipedia.org/wiki/Opaque_data_type

Symbol은 객체가 아닌 원시값이고 `Symbol()`은 생성자 함수가 아닌 팩토리
함수입니다.

Symbol이 값을 완전히 숨길 수는 없는데 `Object.getOwnPropertySymbols()`로 심볼을
얻어내고 프로퍼티를 수정 혹은 삭제할 수 있기 때문입니다. 프로퍼티가 덮어씌워지는
사고 방지(?)의 목적으로 생각하면 될 것 같아요.

스프레드 연산자는 enumerable own 프로퍼티를 복사합니다. Mdn 문서에 스프레드
연산자와 `Object.assign`과의 차이에 대한 재밌는 예제 코드가 있어서 가져왔어요.
전자는 setter를 호출하지만 후자는 그렇지 않습니다.

> ```js
> const objectAssign = Object.assign(
>   {
>     set foo(val) {
>       console.log(val);
>     },
>   },
>   { foo: 1 },
> );
> // Logs "1"; objectAssign.foo is still the original setter
>
> const spread = {
>   set foo(val) {
>     console.log(val);
>   },
>   ...{ foo: 1 },
> };
> // Nothing is logged; spread.foo is 1
> ```
>
> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax

아래 두 코드는 동일합니다. 후자가 더 간략해요:

```js
let square = {
  area: function () {
    return this.side ** 2;
  },
  side: 10,
};

square = {
  area() {
    return this.side ** 2;
  },
  size: 10,
};
```

getter가 정의되는 위치와 enumerable함에 대한 참고 링크:

https://stackoverflow.com/questions/34517538

## 7. Arrays

### 1. Creating Arrays

Spread operator를 통한 배열 생성은 모든 이터러블 객체에서 가능해요:

```js
console.log([...'0123456789ABCDEF']);

// 중복 원소 없애기
console.log([...new Set([...'hello world'])]);
```

Array 생성자에 하나의 숫자를 전달하면 length 속성이 해당 숫자로 설정된
preallocated array(?)가 반환됩니다:

```js
let a = new Array(10);
console.log(a.length, a[0], 0 in a);

// 이럴 때 말고 언제 쓰는지는 저는 잘 모르겠네요 ㅎ,,,
console.log([...Array(10).keys()].join(' '));
```

`Array.of`는 전달된 인자들을 가지는 배열을 반환하는 팩토리 매서드에요:

```js
console.log(Array.of(1));
console.log(Array.of(1, 2, 3));
```

`Array.form`은 이터러블이나 유사 배열을 배열로 변환하는 팩토리 메서드로 스프레드
연산자와 유사하게 동작해요. **Web API에서 종종 유사배열을 반환하기에 이 때
유용하게 사용돼요**. 두번째 인자로 함수를 건네줄 수 있는데 상황에 따라 배열의
생성과 매핑을 한번에 할 수 있어 배열 생성 후 별도로 map을 하는 것보다
효율적입니다:

```js
let arraylike = { 0: 1, 1: 2, 2: 3, length: 3 };
console.log(Array.from(arraylike, (x) => 2 * x));
```

### 2. Reading and Writing Array Elements

배열 인덱스(array index)와 객체의 프로퍼티명(object property name)을 구분하는
것이 도움이 됩니다. 모든 배열 인덱스는 프로퍼티명이지만, 프로퍼티명 중에 0이상
2^32-1미만의 정수만 인덱스로 기능할 수 있어요.

https://stackoverflow.com/questions/6154989/maximum-size-of-an-array-in-javascript

### 3. Sparse Arrays

배열 표현식에서 쉼표 사이가 비어있으면 희소 배열이 됩니다. undefined인 요소가
있는 것과 희소 배열인 것은 달라요:

```js
let a = [undefined, , undefined];
console.log(0 in a, 1 in a);
console.log(a[0], a[1]);
```

희소 배열의 length 프로퍼티 값은 배열 요소의 개수보다 큽니다:

```js
let a = new Array(5); // 희소 배열입니다.
console.log(a.length);

a = [];
console.log(a.length);

a[1000] = 0;
console.log(a.length);
```

희소 배열이 희소(sparse)할수록 느리지만 메모리 효율적인 방식으로 처리됩니다.

### 4. Array Length

Invariant: 배열 요소의 인덱스는 항상 length값 미만입니다.

```js
a = [1, 2, 3, 4, 5];
a.length = 3;
console.log(a);
```

### 5. Adding and Deleting Array Elements

재미로만 보는 push와 a[a.length]의 성능 테스트:

```js
let ITER = 10000000;

let arr = new Array();
let t = performance.now();
for (let i = 0; i < ITER; i++) {
  arr[arr.length] = i;
}

console.log(performance.now() - t);

arr = new Array();
t = performance.now();
for (let i = 0; i < ITER; i++) {
  arr.push(i);
}

console.log(performance.now() - t);
```

https://stackoverflow.com/questions/6772757/using-the-push-method-or-length-when-adding-to-array

요소를 delete한다고 길이가 달라지지는 않습니다:

```js
let a = [1, 2, 3];
delete a[2];
console.log(2 in a, a[2], a.length);
```

### 6. Iterating Arrays

맨날 `Object.entries(arr)`로 썼는데 배열이면 아래처럼 바로 쓸 수도 있네요:

```js
for (const [k, v] of [...'abcdef'].entries()) console.log(k, v);
```

### 7. Multidimensional Arrays

> 희소 배열의 빈 슬롯은 배열 메서드 간에 일관성 없이 동작합니다. 일반적으로
> 오래된 메서드(forEach 등)는 빈 슬롯을 건너뛰는 반면, 최신 메서드(for/of 등)는
> 빈 슬롯을 undefined로 처리합니다.
>
> https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array
>
> ```js
> let a = [1, , 3];
> a.forEach((i) => console.log(i));
> for (const i of a) console.log(i);
> ```

#### Array Iterator Methods

```js
let a = [1, , 3];
a.forEach(
  // forEach 외에 다른 대부분의 메서드들도 val, idx, arr을 함수에 건네줍니다.
  function (val, idx, arr) {
    console.log(val, idx, arr, this);
  },
  // 다른 대부분의 메서드들도 두번째 인자의 값이 (있다면) 함수 내부의 this가 됩니다.
  { val: 'hello' },
);
```

forEach와 for문은 유사하지만 for문의 break에 대응되는 문법은 없습니다.

filter 함수는 predicate 함수를 받아요:

https://stackoverflow.com/questions/3230944/what-does-predicate-mean-in-the-context-of-computer-science

희소 배열의 간격 없애기 예제:

```js
console.log([1, , 2, , , 3, 4, , 5, , , 6, , ,].filter(() => true));
```

수학적 관습?으로 인해 빈 배열에 대해서 every와 some의 결과는 다음과 같습니다:

```js
console.log([].every((x) => true));
console.log([].some((x) => true));
```

reduce 함수는 첫번째 인자로 지금까지의 누적된 결과를 전달합니다. 함수에 initial
value를 전달해주지 않으면 첫번째 요소을 사용합니다:

```js
let ret = [1, , , 2, , , 3].reduce((acc, val, idx, arr) => {
  console.log(acc, val, idx, arr);
  return acc + val;
}, 0); // 인자 0을 지워보세요

console.log(ret);
```

<br />

```js
[].reduce((acc, val) => acc + val);
```

reduceRight는 인덱스 내림차순으로 처리합니다. (왜 써본 적이 없지,,,)

reduce/reduceRight는 this를 설정하는 인자가 없습니다. 설정해야된다면 나중에 배울
bind를 쓰면 돼요.

#### Flattening arrays with flat() and flatMap()

```js
let arr = [1, [2, [3, [4]]]];
console.log(arr.flat());
console.log(arr.flat(1));
console.log(arr.flat(2));
console.log(arr.flat(3));
```

`a.flatMap(f)`는 `a.map(f).flat()`과 같지만 더 효율적입니다. 입력 배열의 각
요소마다 N(>=0)개의 요소를 대응시킬 수 있도록 일반화된 `map`으로 생각할 수
있어요:

```js
let phrases = ['hello world!', 'hello visitors!'];
console.log(phrases.flatMap((x) => x.split(' ')));

let numbers = [-2, -1, 0, 1, 2];
console.log(numbers.flatMap((x) => (x < 0 ? [] : Math.sqrt(x))));
```

#### Adding arrays with concat()

기존 배열을 바꾸지 않아요.

```js
console.log([1, 2].concat([3, [4]], 5));
```

#### Stacks and Queues with push(), pop(), shift(), and unshift()

저는 shift랑 unshift를 자꾸 까먹어요:

```js
let a = [1, 2, 3];
console.log(a.shift());
a.unshift(4, 5);
console.log(a);
```

#### Subarrays with slice(), splice(), fill(), and copyWithin()

```js
let a = [1, 2, 3, 4, 5];
console.log(a.slice(1, 3));
console.log(a.slice(1));
console.log(a.slice(-3, -1));
```

splice는 start index, length, 삽입할 요소들을 인자로 받습니다:

```js
let a = [1, 2, 3, 4, 5];
console.log(a.splice(1, 2), a);
console.log(a.splice(0, 2, [1, 2], 3), a);
```

<br />

```js
let a = new Array(5);
console.log(a.fill(0));
console.log(a.fill(9, 1));
console.log(a.fill(8, 2, -1));
```

copyWithin은 배열 일부분을 배열의 다른 곳으로 옯겨요. 고성능 메서드로 설계되었고
나중에 배울 typed array에 유용합니다. C의 memmove()를 본땄다고 하네요. 목적지
인덱스, 시작 인덱스(없으면 0), 개수 인덱스(없으면 배열 길이) 순으로 인자를
받아요:

```js
let a = [1, 2, 3, 4, 5];
console.log(a.copyWithin(1));
console.log(a.copyWithin(2, 3));
console.log(a.copyWithin(0, -2));
```

#### Array Searching and Sorting Methods

```js
let a = [1, 2, 3, 2, 1];
console.log(a.indexOf(2));
console.log(a.lastIndexOf(2));
console.log(a.indexOf(4));
```

indexOf의 두번째 인자는 탐색을 시작할 인덱스를 의미합니다:

```js
let findAll = (a, x) => {
  let results = [];
  let pos = 0;
  while (pos < a.length) {
    pos = a.indexOf(x, pos);
    if (pos === -1) break;
    results.push(pos++);
  }
  return results;
};

console.log(findAll([1, 2, 3, 2, 1], 2));
```

includes 메서드는 NaN 처리를 합니다:

```js
let a = [1, NaN, 3];
console.log(a.indexOf(NaN));
console.log(a.includes(NaN));
```

https://stackoverflow.com/questions/66743472/why-does-nan-includesnan-return-true-in-javascript

`sort`는 요소를 문자열로 바꿔서 사전순으로 정렬합니다. 대신 undefined는
마지막으로 간대요:

```js
console.log([undefined, 9, 10, '200'].sort());
console.log([33, 4, 1111, 222].sort());
console.log([33, 4, 1111, 222].sort((a, b) => a - b));
```

#### Array to String Conversions

Array 객체의 toString은 인자 없는 join처럼 동작합니다:

```js
console.log([1, 2, 3].toString());
console.log([, , ,].toString());

let a = { toLocaleString: () => 'aaa' };
let b = { toLocaleString: () => 'bbb' };
console.log([a, b].toString());
console.log([a, b].toLocaleString());
```

#### Static Array Functions

> Array.isArray()는 프로토타입 체인에 Array.prototype이 있지만 실제 배열이 아닌
> 객체를 거부합니다. instanceof Array는 이를 허용합니다.
>
> https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray

> Determining with absolute accuracy whether or not a JavaScript object is an
> array
>
> https://web.mit.edu/jwalden/www/isArray.html

### 9. Array-Like Objects

배열 관련된 많은 알고리즘들이 객체가 length 프로퍼티와 0 이상 정수 프로퍼티들을
가지기만해도 잘 동작합니다:

```js
let a = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
console.log(Array.prototype.join.call(a, '+'));
```

Client-side JS에서 많은 HTML document 메서드들이 유사 배열 객체를 반환합니다.

### 10. Strings as Arrays

```js
let a = 'Javascript';
console.log(Array.prototype.join.call(a, ' '));

// string은 immutable합니다
console.log(Array.prototype.push.call(a, '!'));
```

## 8. Functions

### 1. Defining Functions

<br />

## 메모

https://stackoverflow.com/questions/43709005/let-const-and-var-on-global-functions-in-javascript

> 배열에 실제로 존재하는 키만 포함하는 Object.keys()와 달리, keys() 반복자는
> 누락된 속성을 나타내는 빈 공간을 무시하지 않습니다.
>
> https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/keys
