import ImageViewer from '@/components/ImageViewer';
import pythonArg from '@/public/python_default_arg.png';

## 6. Objects

### 1. Introduction to Objects

다른 기능들도 있지만 기본적으로 객체는 문자열을 값으로 매핑합니다. JS 객체는
다른 객체(프로토타입)로부터 프로퍼티를 상속받고 이를 **prototypal
inheritance**라 합니다.

신기하게도 프로퍼티 이름으로 빈 문자열도 가능합니다:

```js
let a = { '': 1 };
console.log(a['']);
```

상속받지 않은 객체의 프로퍼티를 **own property**라 합니다.

각 프로퍼티는 아래 세 attribute들을 가집니다:

- writable: 프로퍼티 값을 설정할 수 있는지
- enumerable: for/in 루프로 순회할 수 있는지
- configurable: 프로퍼티를 삭제하거나 attribute를 수정할 수 있는지

### 2. Creating Objects

중요한 문장이라고 생각해서 그대로 긁어왔어요:

> Remember: almost all objects have a **prototype**, but only a relatively small
> number of objects have `prototype` property. It is these objects with
> `prototype` properties that define the **prototypes** for all the other
> objects.

Object.create의 인자는 생성된 객체의 프로토타입이 됩니다:

```js
let obj1 = {};
console.log(String(obj1));

let obj2 = Object.create(null);
console.log(String(obj2));
```

### 3. Querying and Setting Properties

일반 객체가 연관 배열(딕셔너리)로 자주 활용되기는 하지만 Map 클래스가 더 나은
경우가 있습니다.

같은 이름의 프로퍼티가 프로토타입 체인의 다른 곳에 위치할 수 있습니다:

```js
let a = { x: 1 };
let b = Object.create(a);
console.log(a, b);

b.x = 2;
console.log(a, b);
```

위 코드와 같은 특징 덕분에 상속받은 프로퍼티를 선택적으로 override할 수
있도록합니다. 다만 setter 메서드 관련해서 예외가 있습니다:

```js
let parent = {
  set val(x) {
    this.y = 1;
  },
};

let child = Object.create(parent);

child.val = 2; // child에 프로퍼티가 추가되지 않고 parent의 setter가 호출됩니다.
console.log(parent, child); // setter에서 추가한 프로퍼티는 child에 추가됩니다.
```

### 4. Deleting Properties

delete 연산자는 객체 자신의 프로퍼티만 삭제합니다.

암묵적으로/명시적으로 선언된 변수들의 차이가 delete 연산자에 관련하여 있습니다:

```js
// 원래는 var로 선언한 경우 삭제가 안되어야하는데
// 콘솔 컴포넌트를 eval로 구현해서 차이가 생기는 것 같아요 (확인 필요)
// 브라우저 콘솔에서 실행해보세요 :(
var a = 10;
console.log(globalThis.a);
delete globalThis.a;
console.log(globalThis.a);

b = 20;
console.log(globalThis.b);
delete globalThis.b;
console.log(globalThis.b);
```

### 5. Testing Properties

```js
let a = Object.create({ x: 1 });
a.y = 2;

console.log('x' in a);
console.log(a.hasOwnProperty('x'));

// 스스로의 enumerable한 프로퍼티인지
console.log(a.propertyIsEnumerable('x'));
console.log(a.propertyIsEnumerable('y'));
```

프로퍼티 유무 확인에서 in 연산자와 !== undefined의 차이:

```js
let a = { x: undefined };
console.log('x' in a, a.x !== undefined);
console.log('y' in a, a.y !== undefined);
```

### 6. Enumerating Properties

```js
let a = { x: 1 };
let b = Object.create(a);
b.y = 2;
b[Symbol()] = 3;

// own&inherited enumerable string
for (i in b) console.log(i);
// own enumerable string
console.log(Object.keys(b));
// own (non)enumerable string
console.log(Object.getOwnPropertyNames(b));
// own (non)enumerable symbols
console.log(Object.getOwnPropertySymbols(b));
// own (non)enumeratble string&symbols
console.log(Reflect.ownKeys(b));
```

각종 메서드들의 프로퍼티 순회 순서입니다:

1. 0이상의 자연수를 순서대로
1. 문자열은 추가한 순서대로(리터럴에 있는 순서대로)
1. 심볼도 추가한 순서대로

for-in의 순서는 표준에 자세히 명시되어있진 않다는데,,, 최근에 수정된 것
같습니다:

https://stackoverflow.com/questions/30076219/does-es6-introduce-a-well-defined-order-of-enumeration-for-object-properties

### 7. Extending Objects

객체의 복사가 자주 있어서 ES6에서 `Object.assign()`을 추가했습니다. 두번째 이후
인자들의 enumerable/own/string+symbol 프로퍼티들을 첫번째 인자 객체로
복사합니다.

### 8. Serializing Objects

```js
console.log(JSON.stringify([NaN, Infinity, -Infinity]));
console.log(JSON.parse(JSON.stringify(new Date()))); // parse 후에도 문자열입니다.
```

stringify는 own enumerable property만 처리합니다.

### 9. Object Methods

Object.prototype에서 상속되는 메서드들:

```js
let point = {
  x: 3,
  y: 4,

  toString() {
    return `(${this.x}, ${this.y})`;
  },

  toLocaleString() {
    return `(${this.x.toLocaleString()}, ${this.y.toLocaleString()})`;
  },

  valueOf() {
    return Math.hypot(this.x, this.y);
  },

  // Object.prototype에는 없지만 JSON.stringify가 봅니다
  toJSON() {
    return this.toString();
  },
};

console.log(String(point), Number(point), JSON.stringify(point));
```

### 10. Extended Object Literal Syntax

심볼은 opaque value입니다:

> In computer science, an opaque data type is a data type whose concrete data
> structure is not defined in an interface.
>
> https://en.wikipedia.org/wiki/Opaque_data_type

Symbol은 객체가 아닌 원시값이고 `Symbol()`은 생성자 함수가 아닌 팩토리
함수입니다.

Symbol이 값을 완전히 숨길 수는 없는데 `Object.getOwnPropertySymbols()`로 심볼을
얻어내고 프로퍼티를 수정 혹은 삭제할 수 있기 때문입니다. 프로퍼티가 덮어씌워지는
사고 방지(?)의 목적으로 생각하면 될 것 같아요.

스프레드 연산자는 enumerable own 프로퍼티를 복사합니다. Mdn 문서에 스프레드
연산자와 `Object.assign`과의 차이에 대한 재밌는 예제 코드가 있어서 가져왔어요.
전자는 setter를 호출하지만 후자는 그렇지 않습니다.

> ```js
> const objectAssign = Object.assign(
>   {
>     set foo(val) {
>       console.log(val);
>     },
>   },
>   { foo: 1 },
> );
> // Logs "1"; objectAssign.foo is still the original setter
>
> const spread = {
>   set foo(val) {
>     console.log(val);
>   },
>   ...{ foo: 1 },
> };
> // Nothing is logged; spread.foo is 1
> ```
>
> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax

아래 두 코드는 동일합니다. 후자가 더 간략해요:

```js
// @noexec
let square = {
  area: function () {
    return this.side ** 2;
  },
  side: 10,
};

square = {
  area() {
    return this.side ** 2;
  },
  size: 10,
};
```

getter가 정의되는 위치와 enumerable함에 대한 참고 링크:

https://stackoverflow.com/questions/34517538

## 7. Arrays

### 1. Creating Arrays

Spread operator를 통한 배열 생성은 모든 이터러블 객체에서 가능해요:

```js
console.log([...'0123456789ABCDEF']);

// 중복 원소 없애기
console.log([...new Set([...'hello world'])]);
```

Array 생성자에 하나의 숫자를 전달하면 length 속성이 해당 숫자로 설정된
array(?)가 반환됩니다:

```js
let a = new Array(10);
console.log(a.length, a[0], 0 in a);

// 이럴 때 말고 언제 쓰는지는 저는 잘 모르겠네요 ㅎ,,,
console.log([...Array(10).keys()].join(' '));
```

`Array.of`는 전달된 인자들을 가지는 배열을 반환하는 팩토리 매서드에요:

```js
console.log(Array.of(1));
console.log(Array.of(1, 2, 3));
```

`Array.form`은 이터러블이나 유사 배열을 배열로 변환하는 팩토리 메서드로 스프레드
연산자와 유사하게 동작해요. **Web API에서 종종 유사배열을 반환하기에 이 때
유용하게 사용돼요**. 두번째 인자로 함수를 건네줄 수 있는데 상황에 따라 배열의
생성과 매핑을 한번에 할 수 있어 배열 생성 후 별도로 map을 하는 것보다
효율적입니다:

```js
let arraylike = { 0: 1, 1: 2, 2: 3, length: 3 };
console.log(Array.from(arraylike, (x) => 2 * x));
```

### 2. Reading and Writing Array Elements

배열 인덱스(array index)와 객체의 프로퍼티명(object property name)을 구분하는
것이 도움이 됩니다. 모든 배열 인덱스는 프로퍼티명이지만, 프로퍼티명 중에 0이상
2^32-1미만의 정수만 인덱스로 기능할 수 있어요.

https://stackoverflow.com/questions/6154989/maximum-size-of-an-array-in-javascript

### 3. Sparse Arrays

배열 표현식에서 쉼표 사이가 비어있으면 희소 배열이 됩니다. undefined인 요소가
있는 것과 희소 배열인 것은 달라요:

```js
let a = [undefined, , undefined];
console.log(0 in a, 1 in a);
console.log(a[0], a[1]);
```

희소 배열의 length 프로퍼티 값은 배열 요소의 개수보다 큽니다:

```js
let a = new Array(5); // 희소 배열입니다.
console.log(a.length);

a = [];
console.log(a.length);

a[1000] = 0;
console.log(a.length);
```

희소 배열이 희소(sparse)할수록 느리지만 메모리 효율적인 방식으로 처리됩니다.

### 4. Array Length

Invariant: 배열 요소의 인덱스는 항상 length값 미만입니다.

```js
a = [1, 2, 3, 4, 5];
a.length = 3;
console.log(a);
```

### 5. Adding and Deleting Array Elements

재미로만 보는 push와 a[a.length]의 성능 테스트:

```js
let ITER = 123456;

let arr = new Array();
let t = performance.now();
for (let i = 0; i < ITER; i++) {
  arr[arr.length] = i;
}

console.log(performance.now() - t);

arr = new Array();
t = performance.now();
for (let i = 0; i < ITER; i++) {
  arr.push(i);
}

console.log(performance.now() - t);
```

https://stackoverflow.com/questions/6772757/using-the-push-method-or-length-when-adding-to-array

요소를 delete한다고 길이가 달라지지는 않습니다:

```js
let a = [1, 2, 3];
delete a[2];
console.log(2 in a, a[2], a.length);
```

### 6. Iterating Arrays

맨날 `Object.entries(arr)`로 썼는데 배열이면 아래처럼 바로 쓸 수도 있네요:

```js
for (const [k, v] of [...'abcdef'].entries()) console.log(k, v);
```

> 배열에 실제로 존재하는 키만 포함하는 Object.keys()와 달리, keys() 반복자는
> 누락된 속성을 나타내는 빈 공간을 무시하지 않습니다.
>
> https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/keys

### 7. Multidimensional Arrays

> 희소 배열의 빈 슬롯은 배열 메서드 간에 일관성 없이 동작합니다. 일반적으로
> 오래된 메서드(forEach 등)는 빈 슬롯을 건너뛰는 반면, 최신 메서드(for/of 등)는
> 빈 슬롯을 undefined로 처리합니다.
>
> https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array
>
> ```js
> let a = [1, , 3];
> a.forEach((i) => console.log(i));
> for (const i of a) console.log(i);
> ```

#### Array Iterator Methods

```js
let a = [1, , 3];
a.forEach(
  // forEach 외에 다른 대부분의 메서드들도 val, idx, arr을 함수에 건네줍니다.
  function (val, idx, arr) {
    console.log(val, idx, arr, this);
  },
  // 다른 대부분의 메서드들도 두번째 인자의 값이 (있다면) 함수 내부의 this가 됩니다.
  { val: 'hello' },
);
```

forEach와 for문은 유사하지만 for문의 break에 대응되는 문법은 없습니다.

filter 함수는 predicate 함수를 받아요:

https://stackoverflow.com/questions/3230944/what-does-predicate-mean-in-the-context-of-computer-science

희소 배열의 간격 없애기 예제:

```js
console.log([1, , 2, , , 3, 4, , 5, , , 6, , ,].filter(() => true));
```

수학적 관습?으로 인해 빈 배열에 대해서 every와 some의 결과는 다음과 같습니다:

```js
console.log([].every((x) => true));
console.log([].some((x) => true));
```

reduce 함수는 첫번째 인자로 지금까지의 누적된 결과를 전달합니다. 함수에 initial
value를 전달해주지 않으면 첫번째 요소을 사용합니다:

```js
let ret = [1, , , 2, , , 3].reduce((acc, val, idx, arr) => {
  console.log(acc, val, idx, arr);
  return acc + val;
}, 0); // 인자 0을 지워보세요

console.log(ret);
```

<br />

```js
[].reduce((acc, val) => acc + val);
```

reduceRight는 인덱스 내림차순으로 처리합니다. (왜 써본 적이 없지,,,)

reduce/reduceRight는 this를 설정하는 인자가 없습니다. 설정해야된다면 나중에 배울
bind를 쓰면 돼요.

#### Flattening arrays with flat() and flatMap()

```js
let arr = [1, [2, [3, [4]]]];
console.log(arr.flat());
console.log(arr.flat(1));
console.log(arr.flat(2));
console.log(arr.flat(3));
```

`a.flatMap(f)`는 `a.map(f).flat()`과 같지만 더 효율적입니다. 입력 배열의 각
요소마다 N(>=0)개의 요소를 대응시킬 수 있도록 일반화된 `map`으로 생각할 수
있어요:

```js
let phrases = ['hello world!', 'hello visitors!'];
console.log(phrases.flatMap((x) => x.split(' ')));

let numbers = [-2, -1, 0, 1, 2];
console.log(numbers.flatMap((x) => (x < 0 ? [] : Math.sqrt(x))));
```

#### Adding arrays with concat()

기존 배열을 바꾸지 않아요.

```js
console.log([1, 2].concat([3, [4]], 5));
```

#### Stacks and Queues with push(), pop(), shift(), and unshift()

저는 shift랑 unshift를 자꾸 까먹어요:

```js
let a = [1, 2, 3];
console.log(a.shift());
a.unshift(4, 5);
console.log(a);
```

#### Subarrays with slice(), splice(), fill(), and copyWithin()

```js
let a = [1, 2, 3, 4, 5];
console.log(a.slice(1, 3));
console.log(a.slice(1));
console.log(a.slice(-3, -1));
```

splice는 start index, length, 삽입할 요소들을 인자로 받습니다:

```js
let a = [1, 2, 3, 4, 5];
console.log(a.splice(1, 2), a);
console.log(a.splice(0, 2, [1, 2], 3), a);
```

<br />

```js
let a = new Array(5);
console.log(a.fill(0));
console.log(a.fill(9, 1));
console.log(a.fill(8, 2, -1));
```

copyWithin은 배열 일부분을 배열의 다른 곳으로 옯겨요. 고성능 메서드로 설계되었고
나중에 배울 typed array에 유용합니다. C의 memmove()를 본땄다고 하네요. 목적지
인덱스, 시작 인덱스(없으면 0), 개수 인덱스(없으면 배열 길이) 순으로 인자를
받아요:

```js
let a = [1, 2, 3, 4, 5];
console.log(a.copyWithin(1));
console.log(a.copyWithin(2, 3));
console.log(a.copyWithin(0, -2));
```

#### Array Searching and Sorting Methods

```js
let a = [1, 2, 3, 2, 1];
console.log(a.indexOf(2));
console.log(a.lastIndexOf(2));
console.log(a.indexOf(4));
```

indexOf의 두번째 인자는 탐색을 시작할 인덱스를 의미합니다:

```js
let findAll = (a, x) => {
  let results = [];
  let pos = 0;
  while (pos < a.length) {
    pos = a.indexOf(x, pos);
    if (pos === -1) break;
    results.push(pos++);
  }
  return results;
};

console.log(findAll([1, 2, 3, 2, 1], 2));
```

includes 메서드는 NaN 처리를 합니다:

```js
let a = [1, NaN, 3];
console.log(a.indexOf(NaN));
console.log(a.includes(NaN));
```

https://stackoverflow.com/questions/66743472/why-does-nan-includesnan-return-true-in-javascript

`sort`는 요소를 문자열로 바꿔서 사전순으로 정렬합니다. 대신 undefined는
마지막으로 간대요:

```js
console.log([undefined, 9, 10, '200'].sort());
console.log([33, 4, 1111, 222].sort());
console.log([33, 4, 1111, 222].sort((a, b) => a - b));
```

#### Array to String Conversions

Array 객체의 toString은 인자 없는 join처럼 동작합니다:

```js
console.log([1, 2, 3].toString());
console.log([, , ,].toString());

let a = { toLocaleString: () => 'aaa' };
let b = { toLocaleString: () => 'bbb' };
console.log([a, b].toString());
console.log([a, b].toLocaleString());
```

#### Static Array Functions

> Array.isArray()는 프로토타입 체인에 Array.prototype이 있지만 실제 배열이 아닌
> 객체를 거부합니다. instanceof Array는 이를 허용합니다.
>
> https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray

> Determining with absolute accuracy whether or not a JavaScript object is an
> array
>
> https://web.mit.edu/jwalden/www/isArray.html

### 9. Array-Like Objects

배열 관련된 많은 알고리즘들이 객체가 length 프로퍼티와 0 이상 정수 프로퍼티들을
가지기만해도 잘 동작합니다:

```js
let a = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
console.log(Array.prototype.join.call(a, '+'));
```

Client-side JS에서 많은 HTML document 메서드들이 유사 배열 객체를 반환합니다.

### 10. Strings as Arrays

```js
let a = 'Javascript';
console.log(Array.prototype.join.call(a, ' '));

// string은 immutable합니다
console.log(Array.prototype.push.call(a, '!'));
```

## 8. Functions

호출된 함수는 전달받은 인자 외에도 **invocation context**라는 값을 별도로
가져요. `this` 키워드의 값이 바로 이 값이에요. 함수가 객체를 통해(객체의
메서드로서) 호출되면 해당 객체가 invocation context가 됩니다.

따라서 `this`는 암묵적으로 전달된 함수 인자로도 볼 수 있어요. 이런 관점이 보다
명확한 파이썬의 `self`를 참고해보세요:

https://stackoverflow.com/questions/2709821/what-is-the-purpose-of-the-self-parameter-why-is-it-needed

### 1. Defining Functions

함수 선언문은 호이스팅됩니다. 함수 표현식은 호이스팅되지 않습니다:

```js
f();
g();

function f() {
  console.log('f');
}
let g = () => console.log('g');
```

화살표함수는 정의된 환경의 this 값을 그대로 사용하며 `prototype` 프로퍼티를
가지지 않아 클래스 생성자로서 사용될 수 없습니다.

```js
// 일반 객체 예제
const obj = {
  i: 10,
  b: () => this.i,
  c() {
    return this.i;
  },
};

console.log(obj.b(), obj.c());

let { b, c } = obj;
console.log(b(), c());

// 클래스 예제
class A {
  i = 10;
  d = () => this.i;
  e() {
    return this.i;
  }
}

let a = new A();
console.log(a.d(), a.e());

let { d, e } = a;
console.log(d());
console.log(e());
```

화살표 함수의 `this`값이 일반 객체와 클래스에서 다른 이유:

> Because a class's body has a this context, arrow functions as class fields
> close over the class's this context, and the this inside the arrow function's
> body will correctly point to the instance (or the class itself, for static
> fields). However, because it is a **closure, not the function's own binding**,
> the value of this will not change based on the execution context.
>
> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions

### 2. Invoking Functions

함수는 다음 방법들로 호출될 수 있어요:

- 함수로
- 메서드로
- 생성자로
- call이나 apply 메서드를 사용해 간접적으로
- JS에 의해 암묵적으로
  - get/set
  - toString, valueOf
  - iteration 관련 함수들
  - tagged template literal,
  - Proxy등...

this에 해당하는 객체가 없을 때 strict mode면 undefined, 아니면 전역 객체가 돼요:

```js
// 아래 예제는 현재 블로그상에서 작동하지 않습니다 :(
// 상위에 JS 샌드박스가 있어서 strict mode에 상관없이 this가 항상 window가 돼요.
// 브라우저 콘솔에서 실행해보세요 🙇‍♂️🙇‍♂️

// 'use strict'
const isStrict = (function () {
  return !this;
})();

console.log(isStrict);
```

함수가 this를 반환하도록하면 **method chaining** 스타일의 API를 만들 수 있어요:

```js
class Square {
  x(val) {
    this.x = val;
    return this;
  }
  y(val) {
    this.y = val;
    return this;
  }
  outline(color) {
    this.outline = color;
    return this;
  }
  toString() {
    return `Square\n - x: ${this.x}\n - y: ${this.y}\n - outline: ${this.outline}`;
  }
}

console.log(String(new Square().x(100).y(100).outline('red')));
```

중첩 함수의 this는 외부 스코프의 this값과 다를 수 있어요. 책 말로는 JS의
결함으로 여겨진다고 하네요:

```js
let o = {
  m: function () {
    console.log(this + '');
    let self = this;

    function f() {
      console.log(this + '');
      console.log(self + '');
    }

    f();
  },
  toString() {
    return '[object O]';
  },
};

o.m();
```

위 코드처럼 self와 같은 별도의 변수를 사용하거나, bind 메서드를 사용하거나,
화살표 함수를 사용하면 해결할 수 있습니다.

new 키워드를 붙이면 타겟 함수는 <strong>생성자(constructor)</strong>로 기능하고
일반 함수 호출과 다르게 처리돼요.

- 생성자의 `prototype` 프로퍼티를 상속받는 객체가 생성되고 함수 본문의 `this`가
  이 객체를 가르킵니다.
- 함수 본문의 return에서 객체를 반환한다면 그 객체가 반환되고, 객체가 아닌걸
  반환하면 해당 return문은 무시됩니다.

### 3. Function Arguments and Parameters

```js
function getPropertyNames(o, a = []) {
  for (let property in o) a.push(property);
  return a;
}

console.log(getPropertyNames({ a: 1 }));
console.log(getPropertyNames(document));
```

인자의 기본값(위 코드에서는 빈 배열 `a`)은 호출마다 초기화되고 이는 파이썬과의
차이점이에요.

<ImageViewer
  src={pythonArg}
  alt="파이썬 인자 특"
  widthPercentage="50%"
  priority
  href="https://twitter.com/holdenmatt/status/1774866242282672365"
/>

기본값이 상수일 필요는 없고 다른 인자값에 의존적인 것도 가능합니다:

```js
let rec = (width, height = width) => ({ width, height });
console.log(rec(1));
```

Rest parameter 예시:

```js
// Edge case인 빈 배열을 인자 기본값을 주어 해결한게 신기했어요
function max(first = -Infinity, ...rest) {
  // rest는 대응되는 인자가 없으면 빈 배열입니다.
  let maxVal = first;
  for (let n of rest) maxVal = maxVal < n ? n : maxVal;
  return maxVal;
}

console.log(max(3, 1, 4, 1, 5, 9, 2));
```

Spread operator를 사용한 재밌는 예시:

```js
function timed(f) {
  return function (...args) {
    console.log(`Entering ${f.name}`);
    let startTime = performance.now();
    try {
      return f(...args);
    } finally {
      // finally문으로 처리했기에 f에서 에러를 던져도 괜찮습니다.
      console.log(`Exiting ${f.name} after ${performance.now() - startTime}ms`);
    }
  };
}

let fibo = (n) => (n <= 2 ? 1 : fibo(n - 1) + fibo(n - 2));

let fibo2 = (n) => {
  if (n <= 2) return 1;
  if (fibo2[n]) return fibo2[n];

  return (fibo2[n] = fibo2(n - 1) + fibo2(n - 2));
};

let N = 30;
timed(fibo)(N);
timed(fibo2)(N);
```

함수 매개변수에서도 destructuring이 아래와 같이 가능합니다:

```js
function vectorAdd([x1, y1], [x2, y2]) {
  return [x1 + x2, y1 + y2];
}

console.log(vectorAdd([1, 2], [3, 4]));

let vectorMultiply = ({ x, y, z = 0 }, scalar) => ({
  x: x * scalar,
  y: y * scalar,
  z: z * scalar,
});

console.log(vectorMultiply({ x: 1, y: 2 }, 10));
```

### 4. Functions as Values

위의 `fibo2` 예제에서 미리 보여드렸지만, 함수도 객체이므로 프로퍼티를 가질 수
있어요:

```js
uniqueInteger.counter = 0;

function uniqueInteger() {
  return uniqueInteger.counter++;
}

console.log(uniqueInteger());
console.log(uniqueInteger());
```

### 5. Functions as Namespaces

> 즉시 실행 함수 표현(IIFE, Immediately Invoked Function Expression) 은
> 정의되자마자 즉시 실행되는 Javascript Function 를 말한다.
>
> https://developer.mozilla.org/ko/docs/Glossary/IIFE

IIFE를 네임스페이스로 활용할 수 있습니다.

```js
(function () {
  let val = 10;
  console.log('IIFE');
  // 변수 val로 이것저것 하기
})();

// IIFE 내부의 변수에 접근할 수 없습니다.
console.log(val);
```

### 6. Closures

> 렉시컬 스코프 규칙을 따르는 자바스크립트의 함수는 호출 스택과 관계없이 각각의
> (this를 제외한) 대응표를 소스코드 기준으로 정의하고, 런타임에 그 대응표를
> 변경시키지 않는다.
>
> 클로저 = 함수 + 함수를 둘러싼 환경(lexical environment)
>
> https://ui.toast.com/weekly-pick/ko_20160311

렉시컬 스코프를 구현하기 위해 함수 객체는 함수 정의가 위치한 스코프에 대한
정보도 가지고 있어야합니다. 이러한 객체와 스코프의 조합을 **클로저**라고 해요.

```js
let scope = 'global scope';

function foo() {
  let scope = 'local scope';
  return () => scope;
}

console.log(foo()());
```

여러 함수가 같은 스코프를 공유할 수도 있어요:

```js
let createCounter = (n) => {
  return {
    // 함수 인자도 클로저에서 사용할 수 있습니다
    count: () => n++,
    reset: () => (n = 0),
  };
};

let c1 = createCounter(0),
  c2 = createCounter(10);

console.log(c1.count(), c2.count());
c1.reset();
console.log(c1.count(), c2.count());
```

var와 클로저의 조합으로 버그가 생긴 코드:

```js
// 목표: 0-9를 반환하는 함수의 배열을 반환합니다.
const foo = () => {
  let funcs = [];
  // var가 함수 단위로 정의되어 i가 클로저들간에 공유됩니다.
  // var -> let 으로 바꿔보세요
  for (var i = 0; i < 10; i++) funcs[i] = () => i;
  return funcs;
};

let a = foo();
console.log(a[5]());
```

상위 함수의 `this`를 사용하는 클로저가 필요하다면...:

```js
let obj = {
  x: 123,
  f() {
    // ⚠️ 일반 함수는 바깥 스코프의 this를 사용하지 않습니다.
    let g1 = function () {
      return this;
    };

    // ✅ 따라서 화살표 함수를 사용하거나,
    let g2 = () => this;

    // ✅ bind를 사용하거나,
    let g3 = g1.bind(this);

    // ✅ this를 클로저 내부의 별도 변수에 할당합니다.
    let self = this;
    let g4 = function () {
      return self;
    };

    // ✍️ 다른 g 함수들을 대신 반환해보세요
    return g1;
  },

  toString() {
    return '[object obj]';
  },
};

console.log(String(obj.f()()));
```

### 7. Function Properties, Methods, and Constructor

```js
let sum2 = (a, b) => a + b;
let sum3 = (a, b, c) => a + b + c;
let sum = (...args) => args.reduce((prev, cur) => prev + cur, 0);

console.log(sum2.length, sum3.length, sum.length);
console.log(sum2.name);
```

모든 함수는 서로 다른 프로토타입 객체를 가집니다. 함수가 생성자로 호출되면 새로
생긴 객체는 이 프로토타입 객체를 상속받습니다:

```js
function f() {}
function g() {}

console.log(f.prototype, g.prototype, f.prototype === g.prototype);

let a = new f();
let b = new g();
console.log(Object.getPrototypeOf(a) === f.prototype);
```

`call`과 `apply` 메서드는 함수가 다른 객체의 메서드인 것처럼 동작하게 해요:

```js
function f() {
  console.log(this);
}

let o = { x: 123 };

f();
f.call(o, 1, 2);
f.apply(o, [1, 2]);
```

`bind`는 함수 내 this 키워드에 해당하는 객체를 지정하고 인자 일부를 제공할 수
있어요:

```js
// this 객체 지정하기
let obj1 = { x: 123 };
let obj2 = { x: 456 };
function f() {
  console.log(this.x);
}

let boundf1 = f.bind(obj1);
// ⚠️ 한 번 bind된 함수는 override 할 수 없습니다
let boundf2 = f.bind(obj1).bind(obj2);
boundf1();
boundf2();

// 인자 일부를 미리 제공하기
let sum = (x, y) => x + y;
let inc = sum.bind(null, 1);
console.log(inc(10));

// 함수 이름도 바뀌어요
console.log(inc.name);
console.log(inc.bind().bind().bind().bind().name);
```

Function 생성자로 함수를 만들 수 있고 전역 함수인 것처럼 동작합니다:

```js
let sum = new Function('x', 'y', 'return x+y');
console.log(sum(1, 2));
```

### 8. Functional Programming

**고차 함수**(Higher order function)는 함수를 인자로 받거나 함수를 반환하는
함수입니다:

```js
// 고차함수 예시
function not(f) {
  return function (...args) {
    // ⚠️ return !f(args)
    return !f.apply(this, args);
  };
}

Array.prototype.isEmpty = function () {
  return this.length === 0;
};

Array.prototype.notEmpty = not(Array.prototype.isEmpty);

console.log([].isEmpty(), [].notEmpty());
console.log([1].isEmpty(), [1].notEmpty());
```

합성함수 예제:

```js
function compose(f, g) {
  return function (...args) {
    // 🤔 왜 하나는 call이고 하나는 apply인지 고민해보세요
    return f.call(this, g.apply(this, args));
  };
}

const sum = (x, y) => x + y;
const square = (x) => x * x;
console.log(compose(square, sum)(2, 3));
```

## 9. Classes

자바스크립트는 프로토타입 기반 상속을 사용합니다.

### 1. Classes and Prototypes

range 객체를 생성해 반환하는 팩토리 함수 예제입니다. 프로토타입을 연결하는
과정이 명시적으로 드러나요:

```js
function createRange(from, to) {
  // 프로토타입 객체를 인자로 전달합니다.
  let r = Object.create(createRange.methods);
  r.from = from;
  r.to = to;
  return r;
}

// 프로토타입 객체를 정의합니다.
createRange.methods = {
  includes(x) {
    return this.from <= x && x < this.to;
  },
};

let r = createRange(1, 4);
console.log(r.includes(2), r.includes(5));
```

### 2. Classes and Constructors

`new` 키워드로 객체의 생성과 프로토타입 연결을 자동화할 수 있습니다:

```js
function Range(from, to) {
  if (!new.target) throw new Error('일반 함수로 호출되었어요');
  this.from = from;
  this.to = to;
}

Range.prototype = {
  includes(x) {
    return this.from <= x && x < this.to;
  },
};

// ✍️ new를 지워보세요
let r = new Range(1, 4);
console.log(r.includes(2), r.includes(5));
```

서로 다른 생성자 함수를 사용했어도 두 생성자 함수가 같은 `prototype` 프로퍼티를
가진다면 같은 클래스의 인스턴스로 취급됩니다. 다르게 말하면 객체가 정확히 어떤
생성자를 사용해 만들었는지 `instanceOf`로는 알 수 없습니다:

```js
function A() {}
function B() {}
A.prototype = B.prototype = {};

let a = new A();
let b = new B();
console.log(a instanceof A, a instanceof B);
console.log(b instanceof A, b instanceof B);

// 이런 함수도 있네요.
// createRange 예제처럼 생성자 함수가 없는 경우는
// 아래 방법으로 프로토타입을 확인할 수 있습니다.
console.log(A.prototype.isPrototypeOf(a));
```

정확한 생성자가 궁금하다면 `constructor` 프로퍼티를 활용할 수 있어요:

```js
function A() {}
let a = new A();

console.log(A === A.prototype.constructor);
console.log(A === a.constructor);
```

따라서 프로토타입 객체를 직접 만들었다면 `constructor` 프로퍼티를 잘
설정해줘야합니다:

```js
function A() {}

// 방법 1
A.prototype = {
  constructor: A,
  foo() {
    console.log('foo');
  },
};

function B() {}

// 방법 2
B.prototype.foo = function () {
  console.log('foo');
};

console.log(new A().constructor === A, new B().constructor === B);
```

### 3. Classes with the class keyword

ES6에 추가된 `class` 문법으로 클래스를 만들어봅시다:

```js
class Range {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }

  includes(x) {
    return this.from <= x && x < this.to;
  }
}
let r = new Range(1, 4);
console.log(r.includes(2), r.includes(5));
```

클래스의 본문은 자동으로 strict mode가 적용되며, 클래스 선언은 함수 선언과
다르게 호이스팅되지 않습니다.

static 메서드는 프로토타입 객체가 아닌 함수 자체에 추가됩니다.

```js
class A {
  static foo() {
    console.log('foo');
  }
}

console.log('foo' in A, 'foo' in A.prototype);
```

비교적 최근에 메서드가 아닌 프로퍼티도 클래스 본문에서 초기화할 수 있게
되었습니다:

```js
class Buffer {
  static val = 10;

  // private instance field
  // (protected 접근제어자는 JS에 따로 없습니다)
  #size = 0;

  // ✍️ 아래 두 줄의 순서를 바꿔보세요
  // 결과가 달라지는 이유는 뒤에 인스턴스 생성 순서를 다룰 때 설명할게요
  capacity = 4096;
  buffer = new Uint8Array(this.capacity);

  constructor() {
    console.log(this.buffer.length);
  }
}

console.log(Buffer.val);
new Buffer();
```

### 4. Adding Methods to Existing Classes

프로토타입 객체를 수정해 클래스를 동적으로 수정할 수 있습니다.

```js
// ✍️ 화살표 함수로 바꾸고 결과를 확인해보세요
Number.prototype.tree = function () {
  let n = this.valueOf();
  for (let i = 1; i <= n; i++) console.log('*'.repeat(i));
};

(3).tree();
```

다만 위 예제처럼 빌트인 객체를 수정하는 것은 다른 라이브러리와의, 혹은 JS
버전간의 충돌이 있을 수 있어 좋지 않습니다.

### 5. Subclasses

ES6 이전 방식:

```js
function Range(from, to) {
  this.from = from;
  this.to = to;
}

Range.prototype = {
  includes(x) {
    return this.from <= x && x < this.to;
  },
  constructor: Range,
};

function Span(start, span) {
  // 부모 클래스의 구현에 호환되도록 자식 클래스에서도 초기화를 해야합니다.
  // ES6 전까지는 부모 클래스의 메서드나 생성자를 호출하는 방법(super)을 제공하지 않기에
  // 부모 클래스의 구현을 정확히 알아야합니다.
  this.from = start;
  this.to = start + span;
}

// ⭐ 아래 줄을 이해해보세요
Span.prototype = Object.create(Range.prototype);
Span.prototype.constructor = Span;

console.log(new Span(5, 5).includes(8));
```

`extends`와 `super`를 사용해 서브클래스 만들기:

```js
class Range {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
  includes(x) {
    return this.from <= x && x < this.to;
  }
}

class Span extends Range {
  constructor(start, span) {
    super(start, start + span);
  }
}

console.log(new Span(5, 5).includes(8));
```

여담으로 클래스 표현식을 사용해 아래와 같은 표기도 가능하긴 가능합니다:

```js
class Span extends class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
  includes(x) {
    return this.from <= x && x < this.to;
  }
} {
  constructor(start, span) {
    super(start, start + span);
  }
}

console.log(new Span(5, 5).includes(8));
```

`extends`를 사용하면 static 메서드도 알아서 상속됩니다. 이런 기능은 ES6 이전에는
불가능했어요:

```js
class A {
  static foo() {}
}

class B extends A {}

console.log(A.foo === B.foo);
```

갑자기 생각난 예제:

```js
class A {
  static toString() {
    return 'class';
  }
  toString() {
    return 'instance';
  }
}

console.log(String(A));
console.log(String(new A()));
```

책에는 없었지만 클래스 선언과 인스턴스의 생성 과정이 궁금해서 찾아봤어요. 우선
클래스 선언문의 평가 순서입니다:

```js
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#evaluation_order

// 1️⃣ extends가 있다면 생성자 함수가 맞는지 확인합니다
// ✍️ 주석을 해제하고 어떤 에러가 뜨는지 확인해보세요
class A /* extends 1 */ {
  // 2️⃣ constructor 메서드를 extract(?)하고 없다면 기본 구현으로 대체합니다.
  constructor() {}

  // 3️⃣ 프로퍼티 '키'들을 선언 순서대로 평가합니다.

  // 4️⃣ 메서드와 접근자를 선언 순서대로 install합니다.

  // <인스턴스 메서드>는 prototype에,
  method1() {}

  // <private 인스턴스 메서드>는 나중에 인스턴스에 직접,
  #method2() {}

  // <static 메서드>는 클래스 자체에 install됩니다.
  static method3() {}

  // 5️⃣ 이제부터 클래스 A의 이름을 사용할 수 있습니다.
  // 이전 단계에서 사용하면 ReferenceError가 발생합니다.
  // ✍️ 맨 아래 logged 함수의 주석을 해제해보세요

  // 6️⃣ 프로퍼티 '값'들이 평가됩니다

  // <static 필드>의 '값'이 평가될 때 this는 클래스 자체입니다.
  static [logged('key1')] = logged('val1');
  static [logged('key2')] = (() => {
    console.log(A === this);
    // 🤔 왜 어떤건 undefined고 어떤건 아닌지 고민해보세요
    console.log(A.key1, A.key3, A.method3);
    return 'val2';
  })();
  static {
    console.log('Static initialization blocks', this.key2, this.key3);
  }
  static [logged('key3')] = logged('val3');

  // <인스턴스 필드>의 '값'들은 생성자 시작 전(base class인 경우) 혹은
  // super의 리턴 전(derived class인 경우)에 초기화됩니다.
  // 자세한건 나중 예제에서 볼게요
  [logged('key4')] = logged('val4');
}

// helper function
function logged(val) {
  // console.log(A);
  console.log(`log: ${val}`);
  return val;
}

// 7️⃣ 끝!
```

참고로, 위 코드에서 등장한 **static initialization blocks**은 클래스의 유연한
초기화를 가능하게 합니다:

```js
// @noexec
// ⚠️
class A {
  static init() {
    //
    // Access to private static fields is allowed here
  }
}

// exposes an implementation detail to the user
A.init();

// ✅
class B {
  static {
    // ...
  }
}
```

클래스 선언에서 키는 한 번, 인스턴스 필드 값은 매번 평가됨이 인상깊어서 아래
예제를 만들어봤어요:

```js
class A {
  [randomVal()] = randomVal();

  toString() {
    return JSON.stringify(this);
  }
}

// 키가 항상 같습니다
console.log(new A(), new A(), new A());

// helper function
function randomVal() {
  return Math.floor(Math.random() * 10);
}
```

인스턴스의 생성 과정 예제입니다:

```js
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor

class A {
  x = logged(123);

  constructor() {
    // this로 생성중인 객체, new.target으로 생성자 함수에 접근할 수 있습니다.
    // 프로토타입 체인이 연결되어있고 자식 클래스의 메서드도 다 있기에  String(this)가 B입니다.
    // 클래스가 잘 설계되었다면 부모쪽에서 자식 쪽 생성자를 궁금해할 이유가 없지만
    // 디버깅등등에 유용하게 사용될 수 있다네요.
    console.log(String(this), String(new.target));

    // 하지만 자식 클래스의 프로퍼티는 아직 없습니다
    console.log(this.y);
  }

  static toString() {
    return 'class A';
  }

  toString() {
    return 'instance of A';
  }
}

class B extends A {
  y = logged(456);

  constructor() {
    // 1️⃣ super 이전의 생성자 본문이 실행됩니다.
    // 아직은 this 접근이 불가능합니다.
    console.log('Before super');

    // 2️⃣ super가 호출되어 부모 클래스 부분을 초기화합니다.
    // 3️⃣ 이후 현재 클래스 필드들이 초기화됩니다.
    super();

    // 4️⃣ super 이후의 생성자 본문이 실행됩니다.
    // 이제 this를 사용할 수 있습니다.
    console.log('After super');
    console.log(this.y);
  }

  static toString() {
    // 생성자가 아닌 일반 메서드에는 `super`에 대한 제약이 없습니다
    // 부모 클래스 버전의 메서드를 호출해도, 하지 않아도 됩니다.
    console.log(super.toString());
    return 'class B';
  }

  toString() {
    return 'instance of B';
  }
}

new B();

// helper function
function logged(val) {
  console.log(`log: ${val}`);
  return val;
}
```

상속보다는 컴포지션(composition)을 선호하라는 말도 있습니다:

https://en.wikipedia.org/wiki/Composition_over_inheritance

JS가 abstract method나 abstract class를 공식적으로 지원하지는 않지만 아래와 같이
흉내는 낼 수 있습니다:

```js
// @noexec
class AbstractSet {
  has(x) {
    throw new Error('Abstract method');
  }
}
```

여담으로 타입스크립트에서 abstract class를 따로 지원합니다:

https://www.typescriptlang.org/docs/handbook/classes.html#abstract-classes

프로토타입 객체와 생성자 함수의 관계를 잘 보여주는 책 원문으로 챕터를
마무리할게요:

> Although the prototype object is the key feature of the class, the constructor
> function is the public identity of the class. @/components/ImageViewer
