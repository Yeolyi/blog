# JS로 부동 소수점 최적화해보기

https://www.youtube.com/watch?v=p8u_k2LIZyo

## 부동 소수점 이진수로 출력하기

검증은 아래 링크에서

https://www.h-schmidt.net/FloatConverter/IEEE754.html

> -123.45 == 0b11000010111101101110011001100110

실제 저장되는 값: -123.4499969482421875

```js
let val = -123.45;
let arr = new Uint8Array(new Float32Array([val]).buffer);

console.log(arr.reduceRight((cur, acc) => cur + acc.toString(2), ''));
```

## 목표

f(x) = 1 / sqrt(x) 를 빠르게 계산하기.

그래픽 엔진등에서 빛의 반사를 계산할 때 활용된다고 하네요. 벡터를 길이 1로
정규화할 때 위 식의 값이 사용됩니다.

sqrt 아주 느리고 나눗셈도 마찬가지.

## 성능 측정

테케는 당연히 양수

```js
// Memo: Number.MAX_VALUE 사용시 큰 쪽에 치우침
let createData = (size, max) =>
  [...Array(size).keys()].map(() => Math.random() * max);
```

시간 측정

```js
let measureTime = (f, data) => {
  // warm-up
  data.forEach(f);

  for (let i = 0; i < 5; i++) {
    let begin = performance.now();
    data.forEach(f);
    let end = performance.now();

    console.log(`${end - begin}ms`);
  }
};
```

예시:

```js

```

## 단순 구현

```js
let f = (x) => 1 / Math.sqrt(x);
console.log(f(2));
```

무식한 구현 성능:

```js
let createData = (size, max) =>
  [...Array(size).keys()].map(() => Math.random() * max);

let measureTime = (f, data) => {
  // warm-up
  data.forEach(f);

  for (let i = 0; i < 5; i++) {
    let begin = performance.now();
    data.forEach(f);
    let end = performance.now();

    console.log(`${end - begin}ms`);
  }
};

let f = (x) => 1 / Math.sqrt(x);
let data = createData(100000, 1000);

measureTime(f, data);

let float2Num = (x) => new Uint32Array(new Float32Array([x]).buffer)[0];
let num2Float = (x) => new Float32Array(new Uint32Array([x]).buffer)[0];

let fisr = (x) => {
  let x2 = x * 0.5;
  let y = x;
};

measureTime(fisr, data);
```

## Fast Inverse Square Root

float -> number

```js
let float2Num = (x) => new Uint32Array(new Float32Array([x]).buffer)[0];
let num2Float = (x) => new Float32Array(new Uint32Array([x]).buffer)[0];

let num = float2Num(-123.45);
console.log(num);
console.log(num2Float(num));

let fisr = (x) => {
  let x2 = x * 0.5;
  let y = x;
  let i = float2Num(y);
  i = 0x5f3759df - (i >> 1);
  y = num2Float(i);
  return y * (1.5 - x2 * y * y);
};

console.log(fisr(2));
```
