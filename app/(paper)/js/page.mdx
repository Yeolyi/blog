import ImageViewer from '@/components/image/ImageViewer';

[메인으로](./)

# 자바스크립트

자바스크립트 공부 기록입니다. 몰랐던 것들과 흥미로운 것들을 이곳에 기록해요.
아래 책으로 공부했습니다.

<ImageViewer src="/jsbook.jpeg" alt="책 표지" width={458} height={601} />

## 1. Introduction to Javascript

The core JavaScript does not include any input or output functionality. Input
and output (as well as more sophisticated features, such as networking, storage,
and graphics) are the responsibility of the “host environment” within which
JavaScript is embedded.

### 3. A Tour of JavaScript

```js
console.log([1, 2] + [3, 4, 5]);
```

Roughly, an **expression** is something that computes a value but doesn’t do
anything: it doesn’t alter the program state in any way. **Statements**, on the
other hand, don’t have a value, but they do alter the state

## 2. Lexical Structure

The lexical structure of a programming language is the set of elementary rules
that specifies how you write programs in that language.

### 4. Identifiers and Reserved Words

쓸 일은 없지만, let도 변수명으로 경우에 따라 쓸 수는 있습니다.

```js
var let = 'hello, world!';
console.log(let);
```

### 5. Unicode

```js
const π = 3.14;
console.log(π, '\u{1F600}'); // 숫자 직접 바꿔보세요!

// const 🥲 = 'cry';
// swift는 되던데,,,
```

모양이 같은 문자더라도 다른 유니코드 값일 수 있습니다. 유니코드 표준에
normalization 방법이 정의되어있는데 JS가 이걸 해주지는 않으므로 식별자 모양은
같은데 다른 값인 상황을 만들지 않으려면 에디터 등에서 잘 해주는지 확인합시다.

### 6. Optional Semicolons

세미콜론이 없으면 안되는 경우가 있습니다.

```js
// prettier-ignore
let y = 1 + 2
(3 + 4).toString()
```

## 3. Types, Values, and Variables

JavaScript differs from more static languages in that functions and classes are
**not just part of the language syntax**: they are themselves values that can be
manipulated by JavaScript programs

### 1. Overview and Definitions

Strings can be thought of as arrays of characters, and you might expect them to
be mutable. In JavaScript, however, **strings are immutable**: you can access
the text at any index of a string, but JavaScript provides no way to alter the
text of an existing string.

```js
const str = 'davascript';
str[0] = 'j';
console.log(str);
```

### 2. Numbers

64비트 부동소수점을 사용합니다. 오버플로우가 발생해도 에러를 던지지는 않습니다.

```js
let val = Number.MAX_VALUE;
// (val + 1은 왜 Infinity가 아니지?)
console.log(val, val + 1, val ** 2);
console.log(val === val + 1);
```

하지만 배열 인덱싱이나 비트 연산등은 32비트 정수 연산을 합니다.

```js
console.log(1 << 30, 1 << 31, 1 << 32);
```

16진수도 아래처럼 바로 입력할 수 있습니다. CSS 색상값 넣을 때 종종 씁니다(저는
문자열이 익숙해서 볼때마다 흠칫하지만).

```js
console.log(0x333);
```

이외에도 특이한 경우가 많습니다.

```js
console.log(1 / 0, 0 / 0, Infinity / 0, Infinity / Infinity);

let zero = 0;
let negZero = -0;
console.log(zero === negZero);
console.log(1 / zero === 1 / negZero);
```

NaN은 모든 값과 비교 결과가 false입니다. Number.isNaN 이나 isNaN을 씁시다.
https://stackoverflow.com/questions/33164725/confusion-between-isnan-and-number-isnan-in-javascript

```js
const val = NaN;
console.log(val === NaN, Number.isNaN(val));
```

아래와 같은 경우를 이해하려면 부동소수점 표준인 IEEE-754를 공부해봅시다.

```js
let x = 0.3 - 0.2;
let y = 0.2 - 0.1;
console.log(x === 0.1, y === 0.1);
```

If these floating-point approximations are problematic for your programs,
consider using scaled integers. For example, you might manipulate monetary
values as integer cents rather than fractional dollars. 이더리움에서는 wei라는
최소 단위(=10^(-18)ether)를 쓰던데 이게 여기서 말하는 scaled integer과 비슷한 것
같습니다.

BigInt와 Number간의 연산은 두 자료형이 포함관계가 아니므로 불가능합니다. 비교
연산은 가능합니다.

BigInt는 암호학에 쓰기는 부적합한데
[timing attack](https://timing.attacks.cr.yp.to/programming.html)에 대응하지
않기 때문입니다.

### 3. Text

UTF-16 인코딩을 사용합니다. Unicode characters whose codepoints do not fit in 16
bits are encoded using the rules of UTF-16 as a sequence (known as a **surrogate
pair**) of two 16-bit values. 대부분의 문자열 관련 메서드는 16비트 단위로
동작하고 surrogate pair를 특별 취급하지 않습니다. 다만 이터러블
관련(for/of...)은 실제 문자열처럼 되게 처리해줍니다.

```js
const euro = '€';
const love = '💙';
console.log(euro.length);
console.log(love.length);
console.log(love === '\ud83d\udc99');
console.log(love[0]);
for (const c of love) console.log(c);
```

문자열 표기법 별로 미묘하게 다른 newline 차이입니다.

```js
console.log(
  'one\
long\
line',
);

console.log(`two 
line`);
```

이런저런 문자열 관련 메서드들입니다:

```js
// d83d + dc99
const love = '💙';

console.log(love.charAt(0));

// returns an integer between 0 and 65535
// representing the UTF-16 code unit at the given index.
// may return lone surrogates
console.log(0xd83d === love.charCodeAt(0));
// 왜 0x1f499인지는..모르겠음..
console.log(love.codePointAt(0).toString(16));
```

[String.prototype.normalize](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)도
있는데 자세히는 보지 않았습니다.

Tagged tempalte literals는 styled-component에서 활용하는걸로 알고 있습니다:

```js
const str = String.raw`\n`;
console.log(str);
```

### 4. Boolean Values

```js
console.log(!!undefined);
console.log(!!null);
console.log(!!0);
console.log(!!-0);
console.log(!!NaN);
console.log(!!'');
```

### 5. null and undefined

**undefined** is a predefined global constant (not a language keyword like null,
though this is not an important distinction in practice) that is initialized to
the undefined value.

### 6. Symbols

If you use symbolic property names and do not share those symbols, you can be
confident that other modules of code in your program will not accidentally
overwrite your properties.

```js
const sym = Symbol();
let obj = {
  a: 1,
  [sym]: 2,
};

console.log(obj, Object.values(obj));
console.log(obj[sym]);
```

ES6에서 이터러블을 정의할 때 이터레이터 메서드를 특정 문자열 이름으로 표준화하면
기존 코드가 망가질 염려가 있었기에 symbolic name을 도입했습니다. Symbol.for
메서드는 비슷한 맥락에서 global Symbol registry로 기능합니다:

```js
let s = Symbol.for('shared');
let t = Symbol.for('shared');
console.log(s === t, s.toString(), Symbol.keyFor(t));
```

### 7. The Global Object

The properties of this object are the globally defined identifiers that are
available to a JavaScript program. undefined, isNaN(), String(), Math 등등...

브라우저에서 window 객체는 스스로를 참조하는 window 프로퍼티가 있어서 이
프로퍼티를 사용해 전역 객체에 접근할 수 있습니다. Web worker 스레드에서는 좀
다르다는데 이후 챕터해서 공부해봅시다.

원래는 노드에서는 global, 브라우저에서는 window로 전역 객체에 접근했지만
ES2020부터는 globalThis로 표준화되었습니다.

```js
console.log(window === globalThis);
```

### 8. Immutable Primitive Values and Mutable Object References

객체는 참조하는 대상이 같아야 같습니다:

```js
let a = [1, 2, 3];
let b = [1, 2, 3];
console.log(a === b);
```

### 9. Type Conversions

~이딴게.. 언어...?~

원시값->원시값 변환 표입니다:

| Value     | to String   | to Number | to Boolean |
| --------- | ----------- | --------- | ---------- |
| undefined | 'undefined' | NaN       | false      |
| null      | 'null'      | 0         | false      |
| true      | 'true'      | 1         |            |
| false     | 'false'     | 0         |            |
| ""        |             | 0         | false      |
| " 1.2"    |             | 1.2       | true       |
| "one"     |             | NaN       | true       |
| 0         | '0'         |           | false      |
| -0        | '0'         |           | false      |
| 1         | '1'         |           | true       |
| Infinity  | 'Infinity'  |           | true       |
| -Infinity | '-Infinity' |           | true       |
| NaN       | 'NaN'       |           | false      |

객체->원시값 변환은 뒤에서 살펴볼게요.

#### Conversions and Equality

어떤 값이 다른 값으로 바뀐다고 두 값이 같음(==)을 의미하지는 않습니다. 아래
예제를 볼게요.

```js
console.log(undefined ? 'true' : 'false'); // false로 변환됐습니다.
console.log(undefined == false); // 그렇다고 false와 == 하지는 않습니다.
```

타입 변환 알고리즘과 연산자에서 사용하는 알고리즘이 상이하기 때문입니다. 뒤에서
살펴보겠지만 == 연산자는 피연산자를 불 값으로 변환하지 않습니다.

#### Explicit Conversions

wrapper 객체를 사용한 형변환 방식은 하위호환을 위해 있으니 사용하지 맙시다:

```js
const val = new Boolean('true');
console.log(typeof val);
```

숫자 관련 메서드들입니다:

```js
let n = 17;
console.log(`0b${n.toString(2)}`);
console.log(`0o${n.toString(8)}`);
console.log(`0x${n.toString(16)}`);
console.log();

n = 123456.789;
console.log(n.toFixed(2));
console.log(n.toFixed(5));
console.log(n.toExponential(1));
console.log(n.toExponential(3));
console.log(n.toPrecision(4)); // precesion값이 정수 부분을 표현하지 못할 정도면 지수 표기법을 사용합니다.
console.log(n.toPrecision(10));
console.log();

console.log(Number('3 eggs'));
console.log(parseInt('  3 eggs'));
console.log(parseInt('3.14'));
console.log(parseInt('0xF'));
console.log(parseFloat('.1'));
console.log(parseInt('.1'));
console.log(parseInt('ff'));
console.log(parseInt('ff', 16));
```

#### Object to Primitive Conversions

객체를 원시값으로 변환하는 알고리즘은 prefer-string, prefer-number,
no-preference로 나뉩니다. no-preference는 클래스마다 알아서 정의하는데 빌트인
타입 중에서는 prefer-string인 Date 빼고는 모두 prefer-number입니다. 각각의
알고리즘에 대해서는 곧 설명할게요.

모든 객체는 불 값으로 변환시 true가 됩니다:

```js
console.log(Boolean(new Boolean(false)));
```

객체를 문자열로 변환해야하면 prefer-string 알고리즘으로 우선 변환하고 결과값을
필요시 위 표에 따라 문자열로 변환합니다.

숫자도 마찬가지로 prefer-number를 돌리고 숫자로 변환합니다.

숫자를 받는 연산자도 이 방식을 사용하는데 예외가 있습니다. '+' 연산자는 둘 중
하나가 문자열이면 나머지를 문자열로 수정하고, 그렇지 않다면 숫자로 둘 다
수정합니다. '==' 와 '!='는 하나가 원시값이고 하나가 객체면 객체를 no-preference
알고리즘을 사용해 원시값으로 수정 후 비교합니다. 부등호 연산자는 둘 다 객체면
prefer-number 알고리즘으로 변환 후 비교합니다. 다만 이때는 이후 숫자로 수정되지
않습니다. 덕분에 Date의 비교가 가능해집니다.

#### The toString() and valueOf() methods

모든 객체가 이 두 메서드를 상속받습니다.

각 클래스는 각자의 toString을 구현합니다.

valueOf는 (만약 있다면) 객체를 표현하는 원시값을 반환합니다. 대부분은 이런
원시값이 없기에 객체 자신을 반환합니다.

```js
console.log(new Boolean(true).valueOf());
console.log({ a: 1 }.valueOf());
console.log(new Date().valueOf());
```

#### object-to-primitive conversion algorithms

- prefer-string: toString이 원시값 반환하면 이를 사용, 아니면 valueOf가 원시값
  반환하면 이를 사용, 아니면 TypeError.
- prefer-number: prefer-string에서 valueOf 이후 toString 시도.
- no-preference: Date면 prefer-string, 아니면 prefer-number

```js
console.log(Number([])); // valueOf 실패, toString에서 "", 0으로 변환
console.log(Number([9])); // valueOf 실패, toString에서 "9", 9로 변환
```

### 10. Variable Declaration and Assignment
