import ImageViewer from '@/components/image/ImageViewer';

[메인으로](./)

# 자바스크립트

자바스크립트 공부 기록입니다. 몰랐던 것들과 흥미로운 것들을 이곳에 기록해요.
아래 책으로 공부했습니다.

<ImageViewer src="/jsbook.jpeg" alt="책 표지" width={458} height={601} />

## 1. Introduction to Javascript

The core JavaScript does not include any input or output functionality. Input
and output (as well as more sophisticated features, such as networking, storage,
and graphics) are the responsibility of the “host environment” within which
JavaScript is embedded.

### 3. A Tour of JavaScript

```js
// console
console.log([1, 2] + [3, 4, 5]);
```

Roughly, an **expression** is something that computes a value but doesn’t do
anything: it doesn’t alter the program state in any way. **Statements**, on the
other hand, don’t have a value, but they do alter the state

## 2. Lexical Structure

The lexical structure of a programming language is the set of elementary rules
that specifies how you write programs in that language.

### 4. Identifiers and Reserved Words

쓸 일은 없지만, let도 변수명으로 경우에 따라 쓸 수는 있습니다.

```js
// console
var let = 'hello, world!';
console.log(let);
```

### 5. Unicode

```js
// console
const π = 3.14;
console.log(π, '\u{1F600}'); // 숫자 직접 바꿔보세요!

// const 🥲 = 'cry';
// swift는 되던데,,,
```

모양이 같은 문자더라도 다른 유니코드 값일 수 있습니다. 유니코드 표준에
normalization 방법이 정의되어있는데 JS가 이걸 해주지는 않으므로 식별자 모양은
같은데 다른 값인 상황을 만들지 않으려면 에디터 등에서 잘 해주는지 확인합시다.

### 6. Optional Semicolons

세미콜론이 없으면 안되는 경우가 있습니다.

```js
// console

// prettier-ignore
let y = 1 + 2
(3 + 4).toString()
```

## 3. Types, Values, and Variables

JavaScript differs from more static languages in that functions and classes are
**not just part of the language syntax**: they are themselves values that can be
manipulated by JavaScript programs

### 1. Overview and Definitions

Strings can be thought of as arrays of characters, and you might expect them to
be mutable. In JavaScript, however, **strings are immutable**: you can access
the text at any index of a string, but JavaScript provides no way to alter the
text of an existing string.

```js
// console
const str = 'davascript';
str[0] = 'j';
console.log(str);
```

### 2. Numbers

64비트 부동소수점을 사용합니다. 오버플로우가 발생해도 에러를 던지지는 않습니다.

```js
// console
let val = Number.MAX_VALUE;
// (val + 1은 왜 Infinity가 아니지?)
console.log(val, val + 1, val ** 2);
console.log(val === val + 1);
```

하지만 배열 인덱싱이나 비트 연산등은 32비트 정수 연산을 합니다.

```js
// console
console.log(1 << 30, 1 << 31, 1 << 32);
```

16진수도 아래처럼 바로 입력할 수 있습니다. CSS 색상값 넣을 때 종종 씁니다(저는
문자열이 익숙해서 볼때마다 흠칫하지만).

```js
// console
console.log(0x333);
```

이외에도 특이한 경우가 많습니다.

```js
// console
console.log(1 / 0, 0 / 0, Infinity / 0, Infinity / Infinity);

let zero = 0;
let negZero = -0;
console.log(zero === negZero);
console.log(1 / zero === 1 / negZero);
```

NaN은 모든 값과 비교 결과가 false입니다. Number.isNaN 이나 isNaN을 씁시다.
https://stackoverflow.com/questions/33164725/confusion-between-isnan-and-number-isnan-in-javascript

```js
// console
const val = NaN;
console.log(val === NaN, Number.isNaN(val));
```

아래와 같은 경우를 이해하려면 부동소수점 표준인 IEEE-754를 공부해봅시다.

```js
// console
let x = 0.3 - 0.2;
let y = 0.2 - 0.1;
console.log(x === 0.1, y === 0.1);
```

If these floating-point approximations are problematic for your programs,
consider using scaled integers. For example, you might manipulate monetary
values as integer cents rather than fractional dollars. 이더리움에서는 wei라는
최소 단위(=10^(-18)ether)를 쓰던데 이게 여기서 말하는 scaled integer과 비슷한 것
같습니다.

BigInt와 Number간의 연산은 두 자료형이 포함관계가 아니므로 불가능합니다. 비교
연산은 가능합니다.

BigInt는 암호학에 쓰기는 부적합한데
[timing attack](https://timing.attacks.cr.yp.to/programming.html)에 대응하지
않기 때문입니다.

### 3. Text

UTF-16 인코딩을 사용합니다. Unicode characters whose codepoints do not fit in 16
bits are encoded using the rules of UTF-16 as a sequence (known as a **surrogate
pair**) of two 16-bit values. 대부분의 문자열 관련 메서드는 16비트 단위로
동작하고 surrogate pair를 특별 취급하지 않습니다. 다만 이터러블
관련(for/of...)은 실제 문자열처럼 되게 처리해줍니다.

```js
// console
const euro = '€';
const love = '💙';
console.log(euro.length);
console.log(love.length);
console.log(love === '\ud83d\udc99');
console.log(love[0]);
for (const c of love) console.log(c);
```

문자열 표기법 별로 미묘하게 다른 newline 차이입니다.

```js
// console
console.log(
  'one\
long\
line',
);

console.log(`two 
line`);
```

이런저런 문자열 관련 메서드들입니다:

```js
// console
// d83d + dc99
const love = '💙';

console.log(love.charAt(0));

// returns an integer between 0 and 65535
// representing the UTF-16 code unit at the given index.
// may return lone surrogates
console.log(0xd83d === love.charCodeAt(0));
// 왜 0x1f499인지는..모르겠음..
console.log(love.codePointAt(0).toString(16));
```

[String.prototype.normalize](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)도
있는데 자세히는 보지 않았습니다.

Tagged tempalte literals는 styled-component에서 활용하는걸로 알고 있습니다:

```js
// console
const str = String.raw`\n`;
console.log(str);
```

### 4. Boolean Values

```js
// console
console.log(!!undefined);
console.log(!!null);
console.log(!!0);
console.log(!!-0);
console.log(!!NaN);
console.log(!!'');
```

### 5. null and undefined

**undefined** is a predefined global constant (not a language keyword like null,
though this is not an important distinction in practice) that is initialized to
the undefined value.

### 6. Symbols

If you use symbolic property names and do not share those symbols, you can be
confident that other modules of code in your program will not accidentally
overwrite your properties.

```js
// console
const sym = Symbol();
let obj = {
  a: 1,
  [sym]: 2,
};

console.log(obj, Object.values(obj));
console.log(obj[sym]);
```

ES6에서 이터러블을 정의할 때 이터레이터 메서드를 특정 문자열 이름으로 표준화하면
기존 코드가 망가질 염려가 있었기에 symbolic name을 도입했습니다. Symbol.for
메서드는 비슷한 맥락에서 global Symbol registry로 기능합니다:

```js
// console
let s = Symbol.for('shared');
let t = Symbol.for('shared');
console.log(s === t, s.toString(), Symbol.keyFor(t));
```

### 7. The Global Object

The properties of this object are the globally defined identifiers that are
available to a JavaScript program. undefined, isNaN(), String(), Math 등등...

브라우저에서 window 객체는 스스로를 참조하는 window 프로퍼티가 있어서 이
프로퍼티를 사용해 전역 객체에 접근할 수 있습니다. Web worker 스레드에서는 좀
다르다는데 이후 챕터해서 공부해봅시다.

원래는 노드에서는 global, 브라우저에서는 window로 전역 객체에 접근했지만
ES2020부터는 globalThis로 표준화되었습니다.

```js
// console
console.log(window === globalThis);
```

### 8. Immutable Primitive Values and Mutable Object References

객체는 참조하는 대상이 같아야 같습니다:

```js
// console
let a = [1, 2, 3];
let b = [1, 2, 3];
console.log(a === b);
```

### 9. Type Conversions

이딴게.. 언어...?
