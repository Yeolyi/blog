
[https://swr.vercel.app/ko](https://swr.vercel.app/ko)

> The name “SWR” is derived from stale-while-revalidate, a HTTP cache invalidation strategy popularized by HTTP RFC 5861. SWR is a strategy to first return the data from cache (stale), then send the fetch request (revalidate), and finally come with the up-to-date data.

## RFC 5861

<https://datatracker.ietf.org/doc/html/rfc5861>

HTTP Cache-Control Extensions for Stale Content

<https://iborymagic.tistory.com/135>

stale-while-revalidate는 '캐싱 전략'의 일종이다. (아직 비표준 단계의 HTTP Cache-Control) 데이터가 stale response인지 아닌지는 Cache-Control 헤더에 함께 포함된 max-age로 판단한다.

```http
Cache-Control: max-age=600, stale-while-revalidate=30
```

캐싱된 데이터가 아직 최신 상태라면 해당 데이터를 그대로 응답해준다.

만약 데이터가 최신 상태가 아니라고(max-age보다 오래됐다고) 해도, 일단은 요청에 최대한 빠르게 응답하기 위해서 캐싱된 데이터를 응답으로 바로 보내준다. 하지만 그 사이에, 다음 클라이언트 요청이 올 것을 대비해 '재검증(revalidate)' 요청이 이루어진다. 이 때, 새로 가져온 데이터가 이전에 캐시된 데이터와 동일한지를 검증하여 아니라면 캐시를 갱신한다.

max-age 뿐만 아니라 stale-while-revalidate 값보다도 오래된 'truly' stale 데이터라면 stale-while-revalidate는 동작을 멈추고 (캐싱된 데이터를 사용하지 않고) 그냥 서버에 새로 요청을 보낸다.

즉시성과 최신성 사이의 균형을 맞추기 위해 고안된 방법이다.

## Overview

```tsx
import useSWR from 'swr';

function Profile() {
  // useSWR(key, fetcher)
  // key is a unique identifier of the data(normally the API URL)
  // fetcher can be any async function which returns the data(axios etc)
  const { data, error, isLoading } = useSWR('/api/user', fetcher);

  if (error) return <div>failed to load</div>;
  if (isLoading) return <div>loading...</div>;
  return <div>hello {data.name}!</div>;
}
```

- Fast, lightweight and reusable data fetching
- Built-in cache and request deduplication
- Real-time experience
- Transport and protocol agnostic
- SSR / ISR / SSG support
- TypeScript ready
- React Native

- Fast page navigation
- Polling on interval
- Data dependency
- Revalidation on focus
- Revalidation on network recovery
- Local mutation (Optimistic UI)
- Smart error retry
- Pagination and scroll position recovery
- React Suspense

## Getting Started

First you need to create a fetcher function.

```js
const fetcher = (...args) => fetch(...args).then((res) => res.json());
```

따로 훅으로 분리해 재활용할 수 있다. You can forget about fetching data in the imperative way. Instead, your code is more declarative.

Usually, we need to keep all the data fetching in the top level component and add props to every component deep down the tree.

Context를 사용해도 되지만 dynamic content problem이 있다. 하위 컴포넌트의 컨텐츠가 동적일 수 있고 child component에게 무슨 데이터가 필요한지 부모 컴포넌트는 모를 수 있다?

Same SWR key and request is deduped, cached and shared automatically.

## API

```js
const { data, error, isLoading, isValidating, mutate } = useSWR(key, fetcher, options);
```

이것저것,,,

## Global Configuration

```tsx
<SWRConfig value={options}>
  <Component />
</SWRConfig>
```

refrechInterval, fetcher...

parent context의 것을 받아 쓸 수도 있다.

Cache Provider도 지정 가능.

useSWRConfig.

## Data Fetching

Note that fetcher can be omitted from the parameters if it's provided globally.

```tsx
import axios from 'axios';

const fetcher = (url) => axios.get(url).then((res) => res.data);

function App() {
  const { data, error } = useSWR('/api/data', fetcher);
  // ...
}
```

## Automatic Revalidation

When you re-focus a page or switch between tabs, SWR automatically revalidates data.

revalidateOnFocus, refreshInterval.

refreshWhenHidden, refreshWhenOffline.

revalidateOnReconnect

If the resource is immutable, that will never change if we revalidate again, we can disable all kinds of automatic revalidations for it.

```tsx
useSWR(key, fetcher, {
  revalidateIfStale: false,
  revalidateOnFocus: false,
  revalidateOnReconnect: false,
});

// equivalent to
useSWRImmutable(key, fetcher);
```

The revalidateIfStale controls if SWR should revalidate when it mounts and there is stale data.

revalidateOnMount?? 뭔소리지

## Arguments

```js
// 같다.
// key가 fetcher에게 argument로 전달된다.
useSWR('/api/user', () => fetcher('/api/user'));
useSWR('/api/user', (url) => fetcher(url));
useSWR('/api/user', fetcher);
```

```js
// 안된다. 캐시의 키 값이 그대로라서 token이 반영되지 않는 느낌인듯
useSWR('/api/user', (url) => fetchWithToken(url, token));
// 된다.
const { data: user } = useSWR(['/api/user', token], ([url, token]) => fetchWithToken(url, token));
```

Since SWR 1.1.0, object-like keys will be serialized under the hood automatically.

## Mutation & Revalidation

SWR provides the mutate and useSWRMutation APIs for mutating remote data and related cache.

### mutate

There're 2 ways to use the mutate API to mutate the data, the **global mutate API** which can mutate any key and the **bound mutate API** which only can mutate the data of corresponding SWR hook.

Using global mutator only with the key parameter will not update the cache or trigger revalidation unless there is a mounted SWR hook using the same key.

```jsx
// Global mutate
import { useSWRConfig } from 'swr';

function App() {
  const { mutate } = useSWRConfig();
  mutate(key, data, options);
}
```

```jsx
// Bound Mutate
import useSWR from 'swr';

function Profile() {
  const { data, mutate } = useSWR('/api/user', fetcher);

  return (
    <div>
      <h1>My name is {data.name}.</h1>
      <button
        onClick={async () => {
          const newName = data.name.toUpperCase();
          // send a request to the API to update the data
          await requestUpdateUsername(newName);
          // update the local data immediately and revalidate (refetch)
          // NOTE: key is not required when using useSWR's mutate as it's pre-bound
          mutate({ ...data, name: newName });
        }}
      >
        Uppercase my name!
      </button>
    </div>
  );
}
```

임시 값을 넣고 revalidate 시키는 느낌인가?

data 없이 key만 넣으면 revalidation(mark the data as expired and trigger a refetch)을 트리거한다.

### useSWRMutation

SWR also provides useSWRMutation as a hook for remote mutations.

나머지는 다음에,,,

## Error Handling

The error object will be defined if the fetch promise is rejected.

Note that data and error can exist at the same time. So the UI can display the existing data, while knowing the upcoming request has failed.

onErrorRetry

In case you want to handle the error globally, to notify the UI to show a toast (opens in a new tab) or a snackbar (opens in a new tab), or report it somewhere such as Sentry (opens in a new tab), there's an onError event.

## Conditional Fetching

Use null or pass a function as key to conditionally fetch data.

SWR also allows you to fetch data that depends on other data.

## Pagination

다음에 읽어보자.

```jsx
// 이런 식으로 미리 가져올 수도 있다.
function App() {
  const [pageIndex, setPageIndex] = useState(0);

  return (
    <div>
      <Page index={pageIndex} />
      <div style={{ display: 'none' }}>
        <Page index={pageIndex + 1} />
      </div>
      <button onClick={() => setPageIndex(pageIndex - 1)}>Previous</button>
      <button onClick={() => setPageIndex(pageIndex + 1)}>Next</button>
    </div>
  );
}
```

## Subscription

useSWRSubscription is a React hook that allows subscribing to real-time data sources with SWR.

```jsx
import useSWRSubscription from 'swr/subscription';

function App() {
  const { data, error } = useSWRSubscription('ws://...', (key, { next }) => {
    const socket = new WebSocket(key);
    socket.addEventListener('message', (event) => next(null, event.data));
    socket.addEventListener('error', (event) => next(event.error));
    return () => socket.close();
  });
  if (error) return <div>failed to load</div>;
  if (!data) return <div>loading...</div>;
  return <div>hello {data}!</div>;
}
```

얘도 다음에

## Prefetching

```html
<link
  rel="preload"
  href="/api/data"
  as="fetch"
  crossorigin="anonymous"
/>
```

SWR provides the preload API to prefetch the resources programmatically and store the results in the cache.

## Usage with Next.js

You could only import the key serialization APIs from SWR in RSC.

Together with SWR, you can pre-render the page for SEO, and also have features such as caching, revalidation, focus tracking, refetching on interval on the client side.

## TypeScript

SWR will also infer the argument types of fetcher from key.

## Suspense

React still doesn't recommend using Suspense in data frameworks like SWR. These APIs may change in the future as the results of our research.

## Middleware

The middleware feature is a new addition in SWR 1.0 that enables you to execute logic before and after SWR hooks.

## Advanced

### Understanding SWR

useSWR returns data, error, isLoading, and isValidating depending on the state of the fetcher function.

- isValidating becomes true whenever there is an ongoing request whether the data is loaded or not
- isLoading becomes true when there is an ongoing request and data is not loaded yet.

Simply saying you can use isValidating for indicating everytime there is an ongoing revalidation, and isLoading for indicating that SWR is revalidating but there is no data yet to display.

Fallback data and previous data are not considered "loaded data," so when you use fallback data or enable the keepPreviousData option, you might have data to display.

```jsx
function Stock() {
  const { data, isLoading, isValidating } = useSWR(STOCK_API, fetcher, {
    refreshInterval: 3000,
  });

  // If it's still loading the initial data, there is nothing to display.
  // We return a skeleton here.
  if (isLoading) return <div className="skeleton" />;

  // Otherwise, display the data and a spinner that indicates a background
  // revalidation.
  return (
    <>
      <div>${data}</div>
      {isValidating ? <div className="spinner" /> : null}
    </>
  );
}
```

SWR only triggers re-rendering when the states used in the component have been updated.

### Cache

In most cases, you shouldn't directly write to the cache, which might cause undefined behaviors of SWR.

### Performance

SWR deep compares data changes by default. If the data value isn’t changed, a re-render will not be triggered.

useSWR returns 4 stateful values: data, error, isLoading and isValidating, each one can be updated independently.

```txt
In the worst case (the first request failed, then the retry was successful)
console.log(data, error, isLoading, isValidating)

undefined undefined true true  // => start fetching
undefined Error false false    // => end fetching, got an error
undefined Error true true      // => start retrying
Data undefined false false     // => end retrying, get the data
```

SWR only updates the states that are used by the component.

### React Native

### Developer Tools
