
## 출처

[https://www.typescriptlang.org/play](https://www.typescriptlang.org/play)

## Primitives

### Any

> Any is the TypeScript escape clause. Any declares to TypeScript to trust your code as being safe because you know more about it.

JSON 파싱등에서 사용될 수 있다. never를 제외한 모든 타입을 교체 가능.

```ts
// TypeScript will take into account the position of the
// anys in different forms
function swap(x: [number, string]): [string, number] {
  return [x[1], x[0]];
}

const pair: [any, any] = [1, 'hello'];
console.log(swap(pair));
```

Unknown is a sibling type to any, if any is about saying "I know what's best", then unknown is a way to say "I'm not sure what is best, so you need to tell TS the type"

### Literals

> A literal is a more concrete subtype of a collective type.

What this means is that "Hello World" is a string, but a string is not "Hello World" inside the type system??

```ts
function allowsFirstFiveNumbers(arg: 1 | 2 | 3 | 4 | 5) {
  console.log(arg);
}

// allowsFirstFiveNumbers(10);

// let number = 1;
// allowsFirstFiveNumbers(number);

const number = 1;
allowsFirstFiveNumbers(number);

// const obj = { num: 1 };
// allowsFirstFiveNumbers(obj.num);

const obj = { num: 1 } as const;
allowsFirstFiveNumbers(obj.num);

// "as const" is a great tool for fixtured data, and places
// where you treat code as literals inline. "as const" also
// works with arrays:
```

### Union and Intersection Types

```ts
interface ErrorHandling {
  success: boolean;
  error?: { message: string };
}
interface ArtworksData {
  artworks: { title: string }[];
}
type ArtworksResponse = ArtworksData & ErrorHandling;

const handleArtistsResponse = (response: ArtworksResponse) => {
  if (response.error) {
    console.error(response.error.message);
    return;
  }
  console.log(response.artworks);
};
```

### Unknown and Never

**Unknown**

Where any allows for ambiguity - unknown requires specifics.

```ts
// 리턴값이 unknown이므로 타입을 명시하기 전까지는 반환값을 사용할 수 없다.
const jsonParserUnknown = (jsonString: string): unknown => JSON.parse(jsonString);
type User = { name: string };
const myUserAccount = jsonParserUnknown(`{ "name": "Samuel" }`) as User;
myUserAccount.name;
```

API 사용자가 타입을 신경쓰도록 강제할 수 있다.

**Never**

Because TypeScript supports code flow analysis, the language needs to be able to represent when code logically cannot happen.

A very popular use for never, is to ensure that a switch is exhaustive. E.g., that every path is covered.

```ts
enum Flower {
  Rose,
  Rhododendron,
  Violet,
  Daisy,
  Tulip,
}

const flowerLatinName = (flower: Flower) => {
  switch (flower) {
    case Flower.Rose:
      return 'Rosa rubiginosa';
    case Flower.Rhododendron:
      return 'Rhododendron ferrugineum';
    case Flower.Violet:
      return 'Viola reichenbachiana';
    case Flower.Daisy:
      return 'Bellis perennis';

    default:
      // 'Flower' 형식은 'never' 형식에 할당할 수 없습니다.
      const _exhaustiveCheck: never = flower;
      return _exhaustiveCheck;
  }
};
```

## Type Primitives

### Tuples

> TypeScript has special analysis around arrays which contain multiple types, and where the order in which they are indexed is important. These are called tuples.

A tuple can feel like a good pattern for short bits of connected data or for fixtures.

```ts
const notTuple = ['Not Found', 404];
// const notTuple: (string | number)[]

const tuple: [string, number] = ['{}', 200];
// const tuple: [string, number]

const tuple2: [number, number] = [1, 2];
// 아래 둘 다 가능,,, 근데 쓸까?
// const unknownLengthTuple: [string, ...[...number[]][]] = ['Hello', tuple2, tuple2];
const unknownLengthTuple: [string, ...number[][]] = ['Hello', tuple2, tuple2];
```

### Built-in Utility Types

```ts
interface Person {
  name: string;
  age: number;
}

// 모두 optional로 변경
type PersonUpdateParam = Partial<Person>;
const param: PersonUpdateParam = {};

// 프로퍼티를 read-only로
type PersonFromAPI = Readonly<Person>;

// Record<KeysFrom, Type>
// KeysFrom를 키 값으로 각각에게 Type인 값을 부여
type NavigationPages = 'name' | 'age';
interface PageInfo {
  title: string;
}
const navigationInfo: Record<NavigationPages, PageInfo> = {
  name: { title: 'name' },
  age: { title: 'age' },
};

// Pick<Type, Keys>
// 타입에서 선택된 프로퍼티만 남김
type PersonSortPreview = Pick<Person, 'name'>;

// Omit<Type, Keys>

// Exclude<Type, RemoveUnion>
// Extract<Type, MatchUnion>

type PersonLookupResult = Person | undefined | null;
type ValidatedResult = NonNullable<PersonLookupResult>;

function getPersonByID(id: number): Promise<Person> | void {}
type PersonResponse = ReturnType<typeof getPersonByID>;

// Converts all optional properties to required ones.
type AccessiblePageInfo = Required<PageInfo>;

// ThisType<Type>, InstanceType<Type> 생략
```

[omit vs exclude](https://stackoverflow.com/questions/56916532/difference-b-w-only-exclude-and-omit-pick-exclude-typescript)

### Nullable Types

Undefined is when something cannot be found or set.

Null is meant to be used when there is a conscious lack of a value.

2.0버전 이전까지는 null과 undefined가 타입 시스템에서 무시되었다. Version 2.0 added a compiler flag called "strictNullChecks" and this flag required people to treat undefined and null as types which needs to be handled via code-flow analysis.

```ts
type PotentialString = string | null | undefined;
// strict mode가 켜져있다면 string으로 보인다.
```

## Meta Types

### Conditional Types

Conditional Types provide a way to do simple logic in the TypeScript type system.

normal day to day code에서 사용할 일 없다고 하니 일단 생략.

### Discriminate Types

> A discriminated type union is where you use code flow analysis to reduce a set of potential objects down to one specific object.

```ts
type APIResponses =
  | { version: 0; msg: string }
  | { version: 1; message: string; status: number }
  | { error: string };

const handleResponse = (response: APIResponses) => {
  if ('error' in response) {
    console.error(response.error);
    return;
  }

  if (response.version === 0) {
    console.log(response.msg);
  } else if (response.version === 1) {
    console.log(response.status, response.message);
  }
};
```

### Indexed Types

```ts
interface ArtworkSearchResponse {
  artists: {
    name: string;
    artworks: {
      name: string;
      deathdate: string | null;
      bio: string;
    }[];
  }[];
}
// artworks 부분을 수동으로 빼오면 out of sync할 위험성이 있다.
// 0 첨자 접근은 반드시 있어야 하네
type InferredArtwork = ArtworkSearchResponse['artists'][0]['artworks'][0];
```

### Mapped Types

> Mapped types are a way to create new types based on another type. Effectively a transformational type.

```ts
interface Artist {
  id: number;
  name: string;
  bio: string;
}

type MyPartialType<Type> = {
  [Property in keyof Type]?: Type[Property];
} & { id: number };

type MappedArtistForEdit = MyPartialType<Artist>;

// const artistForEdit: MappedArtistForEdit = {}
// 'id' 속성이 '{}' 형식에 없지만 '{ id: number; }' 형식에서 필수입니다.
```

## Language

### Soundness

> Soundness is the idea that the compiler can make guarantees about the type a value has at runtime, and not just during compilation.

Simplicity, Usability and Soundness에서 타입스크립트는 모든 JS 코드를 수용하기위해 Soundness에서 타협함.

```ts
// Type Assertion은 개발자에게 모든 것을 맡긴다.
const usersAge = '23' as any as number;
console.log(typeof usersAge); // string

// Function Parameter Bi-variance
// 여기는 무슨 소린지 모르겠어서 나중에 다시 보기

// Rest parameters are assumed to all be optional

// Void Functions Can Match to a Function With a Return Value
```

### Structural Typing

TypeScript is a Structural Type System.

> A structural type system means that when comparing types, TypeScript only takes into account the members on the type.

> This is in contrast to nominal type systems, where you could create two types but could not assign them to each other.

```ts
let createBall = (diameter: number) => ({ diameter });
let createSphere = (diameter: number, useInches: boolean) => {
  return { diameter: useInches ? diameter * 0.39 : diameter };
};

createSphere = createBall;
// createBall = createSphere; 할당 불가

// TypeScript will discard the boolean in the first assignment because it's very common for JavaScript code to skip passing params when they're not needed.

// 리턴 타입도 유사한 규칙이 적용
let createRedBall = (diameter: number) => ({ diameter, color: 'red' });

createBall = createRedBall;
// createRedBall = createBall; 할당 불가
```

### Type Guards

> Type Guarding is the term where you influence the code flow analysis via code.

> A type predicate function is a function where the return type offers information to the code flow analysis when the function returns true.

```ts
interface A {
  aProp: string;
}
interface B {
  bProp: string;
}
type AorB = A | B;

declare function getAorB(): AorB;
const aOrB = getAorB();

function notTypePredicateFunction(aOrB: AorB): boolean {
  return 'aProp' in aOrB;
}
if (notTypePredicateFunction(aOrB)) {
  // console.log(aOrB.aProp); 에러
}

function typePredicateFunction(aOrB: AorB): aOrB is A {
  return 'aProp' in aOrB;
}
if (typePredicateFunction(aOrB)) {
  console.log(aOrB.aProp);
}
```

### Type Widening and Narrowing

> Widening and Narrowing types is about expanding and reducing the possibilities which a type could represent.

## Language Extensions

### Enums

```ts
enum StatusCodes {
  OK = 200,
  BadRequest = 400,
  Unauthorized,
  PaymentRequired,
  Forbidden,
  NotFound,
}

const okNumber = StatusCodes.OK;
const stringBadRequest = StatusCodes[400]; // BadRequest

// A const enum's value is replaced by TypeScript during
// transpilation of your code, instead of being looked up
// via an object at runtime.

const enum MouseAction {
  MouseDown,
  MouseUpOutside,
  MouseUpInside,
}
```

### Nominal Typing

Structural Typing은 단점이 있다. For example there are cases where a string or number can have special context and you don't want to ever make the values transferrable. For example:

- User Input Strings (unsafe)
- Translation Strings
- User Identification Numbers
- Access Tokens

```ts
// __brand는 관례
type ValidatedInputString = string & { __brand: 'User Input Post Validation' };

// We're just _telling_ TypeScript that it's true.
const validateUserInput = (input: string) => {
  const simpleValidatedInput = input.replace(/\</g, '≤');
  return simpleValidatedInput as ValidatedInputString;
};

const printName = (name: ValidatedInputString) => {
  console.log(name);
};

const input = "alert('bobby tables')";
const validatedInput = validateUserInput(input);
printName(validatedInput);
```

### Types vs Interfaces

That said, we recommend you use interfaces over type aliases. Specifically, because you will get better error messages.

One major difference between type aliases vs interfaces are that interfaces are open and type aliases are closed. This means you can extend an interface by declaring it a second time.

[Interfaces vs Types](https://stackoverflow.com/questions/37233735/interfaces-vs-types-in-typescript/52682220#52682220)
