
[web.dev](https://web.dev/learn/forms/)

> A course about HTML forms to help you improve your web developer expertise.

You'll learn how to build a basic HTML form, about HTML form elements, styling forms, help users re-entering data, ensuring the form is accessible, and secure, how to test your forms, and about specific form types.

A **form control** is an element that enables user interaction and data entry or selection: an <input>, <select>, <textarea> or <button>.

Sometimes **form field** is used to refer to form controls, in particular elements for text entry: <input> and <textarea>.

## Get started with forms

### Use forms to get data from users

> Learn the basics of using a form on the web with this introduction to the form element.

```html
<form>
  <label for="animal">What is your favorite animal?</label>
  <input
    type="text"
    id="animal"
    name="animal"
  />
  <button>Save</button>
</form>
```

When a form is submitted the browser makes a request. A script can respond to that request and process the data. You can select the location of the script by using the action attribute.

```html
<form
  action="https://example.com/animals"
  method="post"
></form>
```

By default, form data is sent as a GET request, with the submitted data appended to the URL.

Using POST, the data is included in the body of the request. The data will not be visible in the URL like GET.

For forms that process sensitive data use the POST method. If you are using HTTPS the data will obly accessible by the backend script.

If the data is shareable, you can use the GET method. This way the data will be added to your browser history as it is included in the URL.

### Help users enter data in forms

> An overview of the various form elements you can choose from to build your form.

Based on the input element name and the type attribute, browsers show different user interfaces, use different validation rules, and provide many other features.

To describe form controls, use a <label> for each form control. The for attribute on the label element matches the id attribute on the input. This makes the form control accessible to screen readers.

Use the **name** attribute to identify the data the user enters with the control. The name is included in the request.

Based on the **type** attribute, the browser renders different user interfaces, shows different on-screen keyboards, uses different validation rules, and more. Default value for type is text.

For multiple lines of text, use <textarea>.

Use a <select> element to give users a list of options to select from. Each option has a unique value attribute, so you can tell them apart when processing the form data. The text inside the option element is the human-readable value.

With the **selected** attribute you can pre-select one option.

If you want to enable text input with additional predefined options, you can also use an <input> element together with the datalist element.

```html
<body>
  <label for="ice-cream-choice">Choose a flavor:</label>
  <input
    list="ice-cream-flavors"
    id="ice-cream-choice"
    name="ice-cream-choice"
  />

  <datalist id="ice-cream-flavors">
    <option value="Chocolate"></option>
    <option value="Coconut"></option>
    <option value="Mint"></option>
  </datalist>

  <label for="color">Color</label>
  <select
    id="color"
    name="color"
  >
    <option value="orange">Orange</option>
    <option
      value="pink"
      selected
    >
      Pink
    </option>
  </select>
</body>
```

Sometimes you need to group form controls. You can use the <fieldset> element to do that. <legend> element is used to describe the group of form contorls. Every <fieldset> element requires it.

Sometimes you need to group form controls. You can use the <fieldset> element to do that. To disable the default Submit behavior, you can add type="button" to the <button>

```html
<!-- 버튼 대용 -->
<input
  type="submit"
  value="Submit"
/>
```

### Help users avoid re-entering data in forms

> Make it more convenient for users to fill out forms.

**Autofill** can offer you the option to fill in the same data for other forms automatically.

Browsers use heuristics to identify an same type of field regardless of design.

To help browsers with autofill, use sensible attribute values, use autocomplete attribute.

```html
<label for="name">Name</label>
<input
  type="text"
  name="name"
  id="name"
  autocomplete="name"
/>
```

You can learn more about using autocomplete and autofill in a later module.

### Help users enter the right data in forms.

> Learn how to validate your forms on the frontend.

[Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)

The required attribute tells the browser that the field is mandatory.

```html
<body>
  <!-- form 태그 빼먹으니까 안되네 ㅋㅋㅎㅎ -->
  <form>
    <label for="name">Name (required)</label>
    <input
      required
      type="text"
      id="name"
      name="name"
    />

    <label for="password">Password (required)</label>
    <input
      required
      minlength="8"
      type="password"
      id="password"
      name="password"
      aria-describedby="password-minlength"
    />
    <div id="password-minlength">Enter at least eight characters</div>

    <label for="animal">What is your favorite animal? (required)</label>
    <input
      required
      pattern="[a-z]{2,20}"
      type="text"
      id="animal"
      name="animal"
    />

    <button>SAVE</button>
  </form>

  <script>
    const nameInput = document.querySelector('[name="name"]');

    nameInput.addEventListener('invalid', () => {
      nameInput.setCustomValidity('Please enter your name!!!!!');
    });
  </script>
</body>
```

minlength / maxlength attribute. For numerical input types use min and max to achieve the same result.

Make sure all users understand your validation rules. For this, connect the form control with an element that explains the rules. To do so, add an aria-describedby attribute to the element with the id of the form.

You can define a regex in pattern attribute.

You can style required fields with the :required CSS pseudo class. You can use the :invalid pseudo-class to add styles to invalid form controls.

In practice :invalid is tricky to work with. Invalid form fields are already marked as :invalid before user interaction, which may confuse users. The **:user-invalid** pseudo-class solves this issue, as the styles are only applied after user interaction.

To further enhance validation of your forms you can use the JavaScript [Constraint Validation API](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation).

```js
document.addEventListener(
  'blur',
  function (event) {
    // Validate the field
    const isValid = event.target.validity.valid;
    const message = event.target.validationMessage;
    const connectedValidationId = event.target.getAttribute('aria-describedby');
    const connectedValidation = connectedValidationId
      ? document.getElementById(connectedValidationId)
      : false;

    if (connectedValidation && message && !isValid) {
      connectedValidation.innerText = message;
    } else {
      connectedValidation.innerText = '';
    }
  },
  true
);
```

### Test your forms

> Learn how to test and analyze your forms.

Test on different input methods, screen sizes, browsers, OS.

You should measure how your form performs. PageSpeed provides a performance report using lab and field data. A fast site is the first sign that your form is usable. Lighthouse helps you identify performance, search engine optimization (SEO), best practice, and accessibility issues.

There are many tools to identify common issues. One way is to use the Form troubleshooter chrome extension. You can also use an accessibility evaluation tool like WAVE or axe.

Monitoring real user experience of your forms helps you identify new issues quickly. PSI API, Lighthouse...

How can you collect statistics about your users and how they interact with your form? You can use an analytics tool. Google Analytics...

Monitoring the real-world experience of your users is sometimes called Real User Monitoring (RUM).

## General best practice

### Design basics

> Learn how to build user-friendly forms.

Use a label for every form control. Never misuse the placeholder attribute as a label.

[Research](https://ai.googleblog.com/2014/07/simple-is-better-making-your-web-forms.html) shows that putting field labels above rather than adjacent to the fields in the form led also to improvements in the way users scanned the form.

Depending on the type or inputmode attribute (more about this later) a different on-screen keyboard is shown on touch devices.

The recommended tap target size of a button is at least 48px.

Use at least 1rem (which for most browsers has a default value of 16px) as the font-size for your form controls. This prevents a page zoom on iOS Safari when a form control is focused.

```css
/* pointer device, for example, a mouse */
@media (pointer: fine) {
  input[type='checkbox'] {
    width: 15px;
    height: 15px;
  }
}

/* pointer device of limited accuracy, for example, a touch-based device */
@media (pointer: coarse) {
  input[type='checkbox'] {
    width: 30px;
    height: 30px;
  }
}
```

### Accessibility

> How to build inclusive forms.

Every form control must have an associated <label> element. In addition, tapping or clicking the <label> focuses the associated form control, making it a larger target.

Use meaningful HTML to access built-in browser features. Built-in form elements have other features such as on-screen keyboard with appropriate characters. Ensure users are aware of the expected data format. Use area-describedby attribute.

Help users find the error message for a form control. Use aria-live="assertive" for the error message. ARIA live regions announce an error to screen reader users the moment the error is shown.

Ensure users recognize errors. In addition to color, use an icon, or prefix your error messages with the error type.

Help users to navigate your form. A disconnect between visual order and keyboard navigation (DOM order) is problematic for screen reader and keyboard users.

Help users to identify the currently focused form control. If you want to remove the default :focus styles but still show focus indicators for keyboard users, you can use the :focus-visible CSS pseudo-class.

Ensure your form is usable #

### Internationalization and localization

### Security and privacy

### Autofill

## Testing and monitoring

### How to test forms for usability

### Test forms across devices and platforms

### Gathering data

## Elements and attributes

### The form element in depth

### Form fields in depth

### Form attributes in depth

## CSS

### Styling forms

### Styling form controls

## JavaScript

## Specific form types

### Identitiy

### Payment forms

### Address forms

## Wrap up

### Conclusion and next steps
