
### Reacting to Input with State

With React, you won’t modify the UI from code directly. For example, you won’t write commands like “disable the button”, “enable the button”, “show the success message”, etc. Instead, you will describe the UI you want to see for the different visual states of your component (“initial state”, “typing state”, “success state”), and then trigger the state changes in response to user input.

In imperative programming, ... You have to write the exact instructions to manipulate the UI depending on what just happened. ... it gets **exponentially** more difficult to manage in more complex systems.

In React, you don’t directly manipulate the UI—meaning you don’t enable, disable, show, or hide components directly. Instead, you declare what you want to show, and React figures out how to update the UI.

> Declarative programming means describing the UI for each visual state rather than micromanaging the UI (imperative).

1. Identify your component’s different visual states
2. Determine what triggers those state changes(state diagram?)
3. Represent the state in memory using useState
4. Remove any non-essential state variables
5. Connect the event handlers to set the state

If a component has a lot of visual states, it can be convenient to show them all on one page. Pages like this are often called “living styleguides” or “storybooks”.

**Your goal is to prevent the cases where the state in memory doesn’t represent any valid UI that you’d want a user to see.**

To model the state more precisely, you can extract it into a reducer. Reducers let you unify multiple state variables into a single object and consolidate all the related logic!

Expressing all interactions as state changes lets you later introduce new visual states without breaking existing ones. It also lets you change what should be displayed in each state without changing the logic of the interaction itself.

### Choosing the State Structure

- Group related state.
- Avoid contradictions in state.
- Avoid redundant state.
- Avoid duplication in state.
- Avoid deeply nested state.

If some two state variables always change together, it might be a good idea to unify them into a single state variable.

```jsx
const isSending = status === 'sending';
// 한 렌더링 안에서는 state가 바뀌지 않으니 이렇게 써도 상관 없는 듯?
```

**Don't mirror props in state**. “Mirroring” props into state only makes sense when you want to ignore all updates for a specific prop. By convention, start the prop name with initial or default to clarify that its new values are ignored.

```jsx
// X
function Message({ messageColor }) {
  const [color, setColor] = useState(messageColor);
}

// “Mirroring” props into state only makes sense when you want to ignore all updates for a specific prop.
function Message({ initialColor }) {
  // The `color` state variable holds the *first* value of `initialColor`.
  // Further changes to the `initialColor` prop are ignored.
  const [color, setColor] = useState(initialColor);
}
```

Instead of a tree-like structure where each place has an array of its child places, you can have each place hold an array of its child place IDs. Then store a mapping from each place ID to the corresponding place. 얘는 예제 다시 보는걸로. 재귀적으로 컴포넌트 구성하는게 재밌음.

### Sharing State Between Components

Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as lifting state up, and it’s one of the most common things you will do writing React code.

> It is common to call a component with some local state “uncontrolled”.

> In contrast, you might say a component is “controlled” when the important information in it is driven by props rather than its own local state.

In practice, “controlled” and “uncontrolled” aren’t strict technical terms—each component usually has some mix of both local state and props. However, this is a useful way to talk about how components are designed and what capabilities they offer.

When writing a component, consider which information in it should be controlled (via props), and which information should be uncontrolled (via state)

[Single source of truth](https://en.wikipedia.org/wiki/Single_source_of_truth)

### Preserving and Resetting State

[Accessibility tree](https://developer.mozilla.org/docs/Glossary/Accessibility_tree). 이런 것도 있네,,,

From components, React creates a UI tree which React DOM uses to render the DOM

React associates each piece of state it’s holding with the correct component by where that component sits in the UI tree.

State is not kept in JSX tags. It’s associated with the tree position in which you put that JSX.

React preserves a component’s state for as long as it’s being rendered at its position in the UI tree.

When you render a different component in the same position, it resets the state of its entire subtree.

**As a rule of thumb, if you want to preserve the state between re-renders, the structure of your tree needs to “match up” from one render to another.**

Nested Component는 렌더때마다 새로운 component function이 생성되므로 state가 렌더마다 초기화되는 문제가 있다.

There are two ways to reset state when switching between them:

- Render components in different positions
- Give each component an explicit identity with key

Remember that keys are not globally unique. They only specify the position within the parent.

Resetting state with a key is particularly useful when dealing with forms.

컴포넌트가 제거돼도 그 내용을 보관하는 방법

- 앱이 간단하다면 모두 렌더하고 CSS를 통해 숨길건 숨기기
- state를 상위로 옮기기. 가장 일반적인 방법.
- localStorage에 저장된 값을 토대로 렌더링하기.

### Extracting State Login into a Reducer

To reduce this complexity and keep all your logic in one easy-to-access place, you can move that state logic into a single function outside your component, called a “reducer.”

Instead of telling React “what to do” by setting state, you specify “what the user just did” by dispatching “actions” from your event handlers.

```jsx
// The object you pass to dispatch is called an “action”:
function handleDeleteTask(taskId) {
  dispatch(
    // "action" object:
    {
      type: 'deleted',
      id: taskId,
    }
  );
}
```

Generally it should contain the minimal information about what happened.보통 발생한 일을 묘사하는 type 문자열을 포함한다.

A reducer function is where you will put your state logic. It takes two arguments, the current state and the action object, and it returns the next state:

It’s a convention to use switch statements inside reducers.

We recommend wrapping each case block into the { and } curly braces so that variables declared inside of different cases don’t clash with each other. Also, a case should usually end with a return. If you forget to return, the code will “fall through” to the next case, which can lead to mistakes!

```jsx
function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [
        ...tasks,
        {
          id: action.id,
          text: action.text,
          done: false,
        },
      ];
    }
    case 'changed': {
      return tasks.map((t) => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

js의 reduce 함수에 전달되는 함수를 reducer라고한다. useReducer도 마찬가지로 지금까지의 state와 action을 받아 다음 state를 반환한다. Accumulate actions over time into state.

```jsx
const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
```

Now the event handlers only specify what happened by dispatching actions, and the reducer function determines how the state updates in response to them.

A reducer is a pure function that doesn’t depend on your component.

Reducers must be pure, 렌더링 중에 실행된다. **Each action describes a single user interaction**, even if that leads to multiple changes in the data.

State updater function처럼 reducer도 렌더링 중 동작한다??. They should not send requests, schedule timeouts, or perform any side effects.

useImmerReducer도 있네 ㅋㅋ

### Passing Data Deeply with Context

> Context lets the parent component make some information available to any component in the tree below it—no matter how deep—without passing it explicitly through props.

> Lifting state up that high can lead to a situation sometimes called **“prop drilling.”**

**...That would require some way for a child to “ask” for data from somewhere above in the tree.**

다른 컴포넌트가 사용할 수 있게 createContext한 것은 export해줘야한다.

The component will use the value of the nearest <LevelContext.Provider> in the UI tree above it.

If you don’t provide the context, React will use the default value you’ve specified in the previous step. 이를 활용해서 Provider가 없는 상황에서도 useContext를 하고 이때는 default value를 활용할 수 있다.

```jsx
// 이런게 되네
import { useContext } from 'react';
import { LevelContext } from './LevelContext.js';

export default function Section({ children }) {
  const level = useContext(LevelContext);
  return (
    <section className="section">
      <LevelContext.Provider value={level + 1}>{children}</LevelContext.Provider>
    </section>
  );
}
```

Context lets you write components that “adapt to their surroundings” and display themselves differently depending on where (or, in other words, in which context) they are being rendered.

Just because you need to pass some props several levels deep doesn’t mean you should put that information into context.

Start by passing props, extract components and pass JSX as children them.

If you pass some data through many layers of intermediate components that don’t use that data (and only pass it further down), this often means that you forgot to extract some components along the way.

Theming, Current account, Routing, Managing state...

It is common to use a reducer together with context to manage complex state and pass it down to distant components without too much hassle.

Context is not limited to static values. If you pass a different value on the next render, React will update all the components reading it below! This is why context is often used in combination with state. 어떻게 아는거지,, context가 루트에 있다고 모든 컴포넌트가 렌더링되는건 아니겠지?? 커밋과는 별개로.

그나저나 예전에 클래스 컴포넌트는 읽지도 말걸 ㅋㅋ ㅠ

### Scaling Up with Reducer and Context

1. Create the context.
1. Put state and dispatch into context.
1. Use context anywhere in the tree.

You don’t have to do this, but you could further declutter the components by moving both reducer and context into a single file.

```jsx
import { createContext } from 'react';

// 사용처가 다르니 두개를 분리해놓은듯?
export const TasksContext = createContext(null);
export const TasksDispatchContext = createContext(null);

export function TasksProvider({ children }) {
  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

  return (
    <TasksContext.Provider value={tasks}>
      <TasksDispatchContext.Provider value={dispatch}>{children}</TasksDispatchContext.Provider>
    </TasksContext.Provider>
  );
}

// You can also export functions that use the context from TasksContext.js:
export function useTasks() {
  return useContext(TasksContext);
}

export function useTasksDispatch() {
  return useContext(TasksDispatchContext);
}
```

Custom Hooks. Your function is considered a custom Hook if its name starts with use. This lets you use other Hooks, like useContext, inside it.
