
[링크](https://c-faq.com/index.html)

## 1. Declarations and Initializations

> If you might need large values, use long. Otherwise, if space is very important, use short. Otherwise, use int.

int 대신 char를 쓰는게 변환에 필요한 연산이 추가되기에 이득이 크지 않을 수도 있다.

C 표준에는 char is at least 8 bits, short int and int are at least 16 bits, and long int is at least 32 bits만 정의되어있다.

비트를 명확하게 정의할 수 있는 곳은 구조체의 bit-field밖에 없다. 그래도 이런 짓이 필요한 경우는 거의 없음.

int는 기계의 natural word size를 표현한다 간주된다.

타입의 크기를 명확하게 정의하고 싶으면 <inttypes.h>를 살펴보자.

선언은 *base_type thing_that_gives_base_type ;*의 형태로 구성된다. thing어쩌구는 declarator.

> The best arrangement is to place each definition in some relevant .c file. Then, put an external declaration in a header (``.h'') file, and #include it wherever the declaration is needed. The .c file containing the definition should also #include the same header file, so the compiler can check that the definition matches the declarations

```c
// declarations

extern int i;

extern int f();

// definitions
int i = 0;

int f() {
    return 1;
}
```

> In particular, never place a prototype for an external function in a .c file--if the definition of the function ever changes, it would be too easy to forget to change the prototype, and an incompatible prototype is worse than useless.

```c
typedef char *String_t;
#define String_d char *
String_t s1, s2;
// 고장난다.
String_d s3, s4;
```

#define은 #ifdef가 작동한다는 장점을, typedef는 스코프가 있다는 장점을 지닌다.

```c
struct a {
    int afield;
    struct b *bpointer;
};

struct b {
    int bfield;
    struct a *apointer;
};
```

1.22는 와닿지 않는데 다시 읽어보자.

```c
typedef int (*funcptr)();        /* generic function pointer */
typedef funcptr (*ptrfuncptr)(); /* ptr to fcn returning g.f.p. */

funcptr start(), stop();
funcptr state1(), state2(), state3();

void statemachine() {
    ptrfuncptr state = start;

    while (state != stop)
        state = (ptrfuncptr)(*state)();
}

funcptr start() {
    return (funcptr)state1;
}
```

1.29도 겪어본 적이 없어서 ㅎ;

> Function calls are allowed in initializers only for automatic variables (that is, for local, non-static variables).

```c
// 배열을 초기화
char a[] = "string literal";
// 읽기 전용 메모리로의 포인터
char *p  = "string literal";
```

## 2. Structures, Unions, and Enumerations

```c
// structure tag
struct x1 { ... };
// typedef, 사용자가 타입이 struct임을 알 필요가 없다.
typedef struct { ... } x2;
// tag와 typedef가 다른 namespace에 있어서 ㄱㅊ
typedef struct x3 { ... } x3;
```

> C is not C++. Typedef names are not automatically generated for structure tags.

> How can I implement opaque (abstract) data types in C?
>
> One good way is for clients to use structure pointers (perhaps additionally hidden behind typedefs) which point to structure types which are not publicly defined. In other words, a client uses structure pointers (and calls functions accepting and returning structure pointers) without knowing anything about what the fields of the structure are. (As long as the details of the structure aren't needed--e.g. as long as the -> and sizeof operators are not used--C is perfectly happy to handle pointers to structures of incomplete type.[footnote] ) Only within the source files implementing the abstract data type are complete declarations for the structures actually in scope.

[How can I implement object-oriented (OO) inheritance in C with structures?](https://c-faq.com/struct/oop.jxh.html)

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct name {
    int namelen;
    char namestr[1];
};

struct name *makename(char *newname) {
    struct name *ret =
        malloc(sizeof(struct name) - 1 + strlen(newname) + 1);
    /* -1 for initial [1]; +1 for \0 */
    if (ret != NULL) {
        ret->namelen = strlen(newname);
        strcpy(ret->namestr, newname);
    }

    return ret;
}

int main() {
    struct name *myName = makename("seongyeol yi");
    printf("%d, %s\n", myName->namelen, myName->namestr);
}
```

엄격하게 따지면 C 표준은 아니지만 모든 컴파일러가 지원한다. 컴파일러보다 개발자가 사이즈에 대해서 더 잘 알기 때문에 조심해야된다.

> (Obviously, the ``convenience'' of having the length and the string stored in the same block of memory has now been lost, and freeing instances of this structure will require two calls to free; see question 7.23.)

> C99 introduces the concept of a flexible array member, which allows the size of an array to be omitted if it is the last member in a structure, thus providing a well-defined solution.

```c
// struct를 받는 함수에 상수 struct 값을 전달하기.
plotpoint((struct point){1, 2});
plotpoint((struct point){.x=1, .y=2});
```

struct를 파일에 저장하는 방법은 padding이나 byte order 때문에 portable하지 않다. write/read 함수를 따로 작성해야함.

[A bit more explanation of ``alignment'' and why it requires paddding](https://c-faq.com/struct/align.html)

[구조체 멤버들 사이의 순서는 유지되는 것 같다.](https://stackoverflow.com/a/26818050)

```c
#include <stdio.h>

struct {
    char c1;
    int i;
    char c2;
} s1;

struct {
    int i;
    char c1;
    char c2;
} s2;

int main() {
    printf("%lu %lu\n", sizeof(s1), sizeof(s2));
}
```

구조체가 배열에 있을 때 정렬을 위해 뒤쪽에 패딩이 있을 수 있다.

> ANSI C defines the offsetof() macro in <stddef.h>, which lets you compute the offset of field f in struct s as offsetof(struct s, f).

> #define offsetof(type, f) ((size_t) ((char \_)&((type \_)0)->f - (char \_)(type \_)0)) null 포인터의 값이 0이 아니어도 사용할 수 있다. The nonportability is in pretending, if only for the purposes of address calculation, that there is an instance of the type sitting at address 0??

배열 참조가 포인터로 바뀌는 규칙은 배열 한정이어서 구조체는 그대로 전달됨. 이는 배열이 C에서 second class이기 때문. 구조체는 first class이다.

> C standard allows compiler to put bit-fields in any order. There is no reliable and portable way to determine the order. ... If you do (unsigned)number & 1, it will always give you LSB, and endianness is irrelevant. Byte-endianness: If you inspect bytes of number, then byte which has LSB is implementation defined. On little-endian system, LSB can be found on first byte. Bit-endianness: It's impossible to know the order of bits in single byte in C. In short: You need to care about byte-edianness if you write code which converts data to bytes or back. You don't really need to care about bit-endianness, since C has no ability to take address of the single bit.[Order of fields when using a bit field in C](https://stackoverflow.com/questions/19376426/order-of-fields-when-using-a-bit-field-in-c)

enum은 #define에 비해 디버깅이 용이하고 스코프를 가진다는 장점을 가진다.

사람들이 Bit-field 대신에 explicit mask와 bit-twiddling 코드를 사용하는 이유. 비트 필드는 nonportable하다. 사실 int, char 등등 모든 타입이 정확히 얼마나 큰지도 모르고, 메모리에서 어떻게 배치되는지도 모른다. 이 사실은 externally-imposed storage layout에 대응해야될 때만 문제다.

## 3. Expressions

```c
#include <stdio.h>

int arr[1];

int main() {
    int i = 0;
    // warning: unsequenced modification and access to 'i'
    // 왜 애매한거지!!!
    arr[i] = i++;
    // warning: multiple unsequenced modifications to 'i'
    i = i++;

    // swap
    int a = 123, b = 7654;
    // warning: unsequenced modification and access to 'a'
    // It attempts to modify the variable a twice between sequence points, so its behavior is undefined.
    a ^= b ^= a ^= b;
    printf("%d, %d\n", a, b);
}
```

++와 --가 former 값을 yield한 '이후' 연산을 하는건 맞지만 여기서 말한 '이후'가 직후를 의미하는 것은 아니다. It is merely guaranteed that the update will be performed sometime before the expression is considered finished.

> Don't even try to find out how your compiler implements such things, let alone write code which depends on them (contrary to the ill-advised exercises in many C textbooks); as Kernighan and Ritchie wisely point out, ``if you don't know how they are done on various machines, that innocence may help to protect you.''

[XOR swap algorithm](https://en.wikipedia.org/wiki/XOR_swap_algorithm)

```c
// 연산자 우선순위가 함수 평가의 순서도 보장하지는 않는다.
// short-circuting은 예외
// When you need to ensure the order of subexpression evaluation, you may need to use explicit temporary variables and separate statements.
f() + g() * h()
```

> The comma operator does guarantee left-to-right evaluation, but the commas separating the arguments in a function call are not comma operators.

> A sequence point is a point in time at which the dust has settled and all side effects which have been seen so far are guaranteed to be complete.

표준에 따르면...

> Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior value shall be accessed only to determine the value to be stored.

개복잡함 나중에 다시 읽어보자. 3.10/3.11 어려운데 중요할 것 같음.

```c
int a = 1000, b = 1000;
long int c = a * b;
// int로 계산되어 오버플로우의 가능성이 있다.
// 둘 중 하나라도 캐스트해야됨.
```

```c
#include <stdio.h>

int main() {
    unsigned short us = 10;
    int i = -5;
    if (i > us)
        printf("whoops!\n");

    unsigned char uc = 0x80;
    unsigned long ul = 0;
    ul |= uc << 8;
    printf("0x%lx\n", ul);
    int* p = &i;
}
```

3.19 내용. 내 컴퓨터에서는 괜찮은데 portablity 관련해서 알아야 하는 내용인듯. 일단은 생략.

## 4. Pointers

> In C, a cast operator does not mean ``pretend these bits have a different type, and treat them accordingly''; it is a conversion operator, and by definition it yields an rvalue, which cannot be assigned to, or incremented with ++.

error: assignment to cast is illegal, lvalue casts are not supported.

C에는 generic한 pointer-to-pointer 타입이 없다. 4.9는 상황이 이해가 안감 ㅠ

```c
#include <stdio.h>

void foo(int* x) {
    printf("%d\n", *x);
}

int main() {
    foo((int[]){1, 2, 3, 4, 5});
}
```

> C always uses pass by value.

function-like 전처리 매크로으로 pass by name을 구현?할 수 있다.[Pass-By-Name Parameter Passing](https://www2.cs.sfu.ca/~cameron/Teaching/383/PassByName.html)

함수 이름도 어차피 포인터니 함수 포인터 fp에 대해서 fp()로 냅다 호출하는 것도 말이 된다.

void\*는 데이터 포인터만 가능하다. 함수는 안됨. Total generic pointer type은 없다. 몇몇 기계에서는 함수 주소가 데이터 주소보다 클 수 있기 떄문. 대신에 함수타입끼리는 변환이 돼서 void(\*)()를 쓰면 된다.

> Pointer-to-integer and integer-to-pointer conversions are implementation-defined.

## 5. Null Pointers

> ... there is a special value--the `null pointer'--which is distinguishable from all other pointer values and which is guaranteed to compare unequal to a pointer to any object or function.

포인터 타입별로 널 포인터가 있기에 각각 타입에 대한 널 포인터의 값은 다를 수 있다.

> According to the language definition, an ``integral constant expression with the value 0'' in a pointer context is converted into a null pointer at compile time.

따라서 아래는 legal하다.

```c
char *p = 0;
if (p != 0)
```

가변 인수 함수와 같은 경우는 타입이 불분명하니 (char\*)0 이런식으로 캐스팅해줘야한다.

코드 여기저기에 0이 어떨떈 상수로, 어떨땐 널 포인터로 있으면 안좋으니 NULL 매크로가 0으로 등록되어있다. Stylish convention뿐이긴 함.

> Whenever a programmer requests a null pointer, either by writing 0 or NULL, it is the compiler's responsibility to generate whatever bit pattern the machine uses for that null pointer.

> Some programs carelessly attempt to generate null pointers by using the NULL macro, without casts, in non-pointer contexts.

> C programmers must understand that NULL and 0 are interchangeable in 'pointer contexts', and that an uncast 0 is perfectly acceptable.

```c
execl("/bin/sh", "sh", "-c", "date", NULL);	/* WRONG */
// portable code uses an explicit cast
execl("/bin/sh", "sh", "-c", "date", (char *)NULL);
```

```c
#include <stdio.h>

int main() {
    int* p = NULL;
}
```

```s
.section	__TEXT,__text,regular,pure_instructions
	.build_version macos, 13, 0	sdk_version 13, 1
	.globl	_main                           ; -- Begin function main
	.p2align	2
_main:                                  ; @main
	.cfi_startproc
; %bb.0:
	sub	sp, sp, #16
	.cfi_def_cfa_offset 16
                                        ; kill: def $x8 killed $xzr
	str	xzr, [sp, #8]
	mov	w0, #0
	add	sp, sp, #16
	ret
	.cfi_endproc
                                        ; -- End function
.subsections_via_symbols
```

## 6. Arrays and Pointers

> In other words, a[3] is three places past (the start of) the object named a, while p[3] is three places past the object pointed to by p.

> ... "equilivance of pointers and arrays" ... What it means is that array and pointer arithmetic is defined such that a pointer can be conveniently used to access an array or to simulate an array

> pointer arithmetic and array indexing are equivalent in C, pointers and arrays are different

> Specifically, the cornerstone of the equivalence is this key definition:
>
> A reference to an object of type array-of-T which appears in an expression decays (with three exceptions) into a pointer to its first element; the type of the resultant pointer is pointer-to-T.

> That is, whenever an array appears in an expression, the compiler implicitly generates a pointer to the array's first element, just as if the programmer had written &a[0]. (The exceptions are when the array is the operand of a sizeof or & operator, or is a string literal initializer for a character array.)

결과적으로 컴파일러는 배열과 포인터에서 [] 연산자를 그리 다르게 처리하지 않는다.

덕분에 함수가 배열을 인수로 받는 것처럼 흉내낼 수 있다.

> This conversion of array-like declarators into pointers holds only within function formal parameter declarations, nowhere else.

> Arrays are ``second-class citizens'' in C; one upshot of this prejudice is that you cannot assign to them.

> The term `lvalue' doesn't quite mean 'something you can assign to'; a better definition is ``something that has a location (in memory).'

일반적으로 생각하는 lvalue는 modifiable lvalue이다.

> Someone explained to me that arrays were really just constant pointers.
>
> This is a bit of an oversimplification. An array name is `constant' in that it cannot be assigned to, but an array is not a pointer.

arr과 &arr은 타입이 다르다.

> In Standard C, &arr yields a pointer, of type pointer-to-array-of-T, to the entire array.

> True pointers to arrays, when subscripted or incremented, step over entire arrays, and are generally useful only when operating on arrays of arrays, if at all.

VLA를 활용하면 함수 인수에 있는 배열과 같은 크기의 local 배열을 만들 수 있다. malloc을 사용한 방법은 local이 아니라서 아닌듯.

> An array of arrays (i.e. a two-dimensional array in C) decays into a pointer to an array, not a pointer to a pointer.

```c
// 이런 선언은 배열을 평평하게 만들어서 의미가 없다.
extern g(int **ipp);
```

```c
#include <stdlib.h>
#define NCOLUMNS 10
#define NROWS 10

extern int nrows;
extern int ncolumns;

int main() {
    int **array1 = malloc(nrows * sizeof(int *));
    for (int i = 0; i < nrows; i++)
        array1[i] = malloc(ncolumns * sizeof(int));

    int **array2 = malloc(nrows * sizeof(int *));
    array2[0] = malloc(nrows * ncolumns * sizeof(int));
    for (int i = 1; i < nrows; i++)
        array2[i] = array2[0] + i * ncolumns;

    // 이러면 첨자 접근이 귀찮긴 하다.
    int *array3 = malloc(nrows * ncolumns * sizeof(int));

    int(*array4)[NCOLUMNS] = malloc(nrows * sizeof(*array4));
    int(*array5)[NROWS][NCOLUMNS] = malloc(sizeof(*array5));
}
```

## 7. Memory Allocation

malloc에서 받은 포인터를 캐스팅하는건 스타일의 차이다. C++에서는 캐스팅이 필요하다.

sizeof(char)은 정의에 의해 반드시 1이다.

> My application depends heavily on dynamic allocation of nodes for data structures, and malloc/free overhead is becoming a bottleneck. What can I do?
>
> One improvement, which is particularly attractive if all nodes are the same size, is to place unused nodes on your own free list, rather than actually freeing them. (This approach works well when one kind of data structure dominates a program's memory use, but it can cause as many problems as it solves if so much memory is tied up in the list of unused nodes that it isn't available for other purposes.)

> A pointer value which has been freed is, strictly speaking, invalid, and any use of it, even if it is not dereferenced (i.e. even if the use of it is a seemingly innocuous assignment or comparison), can theoretically lead to trouble.

> Must I free allocated memory before the program exits?
>
> You shouldn't have to. A real operating system definitively reclaims all memory and other resources when a program exits;
>
> In any case, it can be considered good practice to explicitly free all memory--for example, in case the program is ever rewritten to perform its main task more than once (perhaps under a Graphical User Interface).

> Most implementations of malloc/free do not return freed memory to the operating system, but merely make it available for future malloc calls within the same program.

> How does free know how many bytes to free?
>
> The malloc/free implementation remembers the size of each block as it is allocated, so it is not necessary to remind it of the size when freeing. (Typically, the size is stored adjacent to the allocated block, which is why things usually break badly if the bounds of the allocated block are even slightly overstepped; see also question 7.19.)

> If realloc cannot find enough space at all, it returns a null pointer, and leaves the previous region allocated. Therefore, you usually don't want to immediately assign the new pointer to the old variable. Instead, use a temporary pointer

```c
#include <stdio.h>
#include <stdlib.h>

// Passing an initially - null pointer to realloc can make it easier to write a self - starting incremental allocation algorithm.
// Here is an example-- this function reads an arbitrarily long line into dynamically - allocated memory,
// reallocating the input buffer as necessary.(The caller must free the returned pointer when it is no longer needed.)

    /* read a line from fp into malloc'ed memory */
    /* returns NULL on EOF or error */
    /* (use feof or ferror to distinguish) */

    char *agetline(FILE *fp) {
    char *retbuf = NULL;
    size_t nchmax = 0;
    register int c;
    size_t nchread = 0;
    char *newbuf;

    while ((c = getc(fp)) != EOF) {
        if (nchread >= nchmax) {
            // In production code, a line like this can prove troublesome, 
            // as the function may do lots of reallocating. 
            // Many programmers favor multiplicative reallocation, e.g. nchmax *= 2, 
            // although it obviously isn't quite as self-starting, 
            // and can run into problems if it has to allocate a huge array but memory is limited.
            nchmax += 20;
            if (nchread >= nchmax) { /* in case nchmax overflowed */
                free(retbuf);
                return NULL;
            }
#ifdef SAFEREALLOC
            newbuf = realloc(retbuf, nchmax + 1);
#else
            if (retbuf == NULL) /* in case pre-ANSI realloc */
                newbuf = malloc(nchmax + 1);
            else
                newbuf = realloc(retbuf, nchmax + 1);
#endif
            /* +1 for \0 */
            if (newbuf == NULL) {
                free(retbuf);
                return NULL;
            }

            retbuf = newbuf;
        }

        if (c == '\n')
            break;

        retbuf[nchread++] = c;
    }

    if (retbuf != NULL) {
        retbuf[nchread] = '\0';

        newbuf = realloc(retbuf, nchread + 1);
        if (newbuf != NULL)
            retbuf = newbuf;
    }

    return retbuf;
}
```

> calloc's zero fill is all-bits-zero, and is therefore guaranteed to yield the value 0 for all integral types (including '\0' for character types). But it does not guarantee useful null pointer values (see section 5 of this list) or floating-point zero values.

> alloca allocates memory which is automatically freed when the function which called alloca returns. ... alloca cannot be written portably.

## 8. Characters and Strings

> To convert back and forth between the digit characters and the corresponding integers in the range 0-9, add or subtract the constant '0' (that is, the character value '0').

\n와 같은 char 시퀀스는 컴파일 시점에 해석되기에 유저가 입력한 것은 newline으로 해석되지 않는다.

```c
#include <stdio.h>

// Character constants in C are of type int.
int main() {
    printf("%zu\n", sizeof(char));
    printf("%zu\n", sizeof('a'));
}
```

## 9. Boolean Expressions and Variables

> C99 _does_ define a standard Boolean type, as long as you include <stdbool.h>.

모든 nonzero 값들이 참으로 간주되어도 TRUE를 1로 정의하는 것이 상관없는데 이는 유저 입력값이나 외부 라이브러리를 제외하고는 빌트인 연산자가 0이나 1을 만들도록 보장되어있기 때문이다.

> A good rule of thumb is to use TRUE and FALSE (or the like) only for assignment to a Boolean variable or function parameter, or as the return value from a Boolean function, but never in a comparison.

## 10. C Preprocessor

> As a general rule, it's a good idea if the use of preprocessor macros follows the syntax of the C language.

> If a parameter appears several times in the expansion, the macro may not work properly if the actual argument is an expression with side effects.

[const vs #define](https://c-faq.com/cpp/constdefine2.html)

> the #include directive should be used to pull in header files, not other .c files.

> The <> syntax is typically used with Standard or system-supplied headers, while "" is typically used for a program's own header files.

[m4 (computer language)](<https://en.wikipedia.org/wiki/M4_(computer_language)>)

그냥 함수 쓰자,,, #define을 꼭 써야될 때 와서 다시 읽어보기

## 11. ANSI/ISO Standard

```c
// In a quirk of C's normal block scoping rules, a structure declared (or even mentioned) for the first time within a prototype cannot be compatible with other structures declared in the same source file.
extern int f(struct x *p);
```

const qualifier는 런타임에 객체를 qualify하기에 이를 통해 정적 배열을 선언할 수는 없다. C++는 좀 달라서 진짜 const처럼 된다는 듯? C에서는 #define을 사용하자.

```c
// Why can't I pass a char ** to a function which expects a const char **?
// p1 ends up pointing to c, which is const.
const char c = 'x';		/* 1 */
char *p1;			    /* 2 */
const char **p2 = &p1;	/* 3 */
*p2 = &c;			    /* 4 */
*p1 = 'X';			    /* 5 */
```

```c
typedef char *charp;
const charp p;
// p가 const된다.
// The typedef'ed declaration of p does not ``look inside'' the typedef to see that there is a pointer involved.
```

```c
// Valid한 main 선언
int main(void)
int main(int argc, char **argv)
int main()
```

> Declaring a function as void does not merely shut off or rearrange warnings: it may also result in a different function call/return sequence, incompatible with what the caller (in main's case, the C run-time startup code) expects.

main의 세번째 인자 envp는 비표준이지만 자주 사용된다. 전역 변수 environ도 낫지만 얘도 비표준이다.

11.16이랑 16.4는 나중에 다시 읽어보기. OS 관련인가?

> The #pragma directive provides a single, well-defined ``escape hatch'' which can be used for all sorts of (nonportable) implementation-specific controls and extensions: source listing control, structure packing, warning suppression (like lint's old /_ NOTREACHED _/ comments), etc.

> #pragma once. It is an extension implemented by some preprocessors to help make header files idempotent.

> memmove offers guaranteed behavior if the memory regions pointed to by the source and destination arguments overlap. memcpy makes no such guarantee, and may therefore be more efficiently implementable. When in doubt, it's safer to use memmove.

memmove는 뒤에서부터 복사하도록하면 overlap되는걸 막을 수 있다.

> **implementation-defined**: The implementation must pick some behavior; it may not fail to compile the program. (The program using the construct is not incorrect.) The choice must be documented. The Standard may specify a set of allowable behaviors from which to choose, or it may impose no particular requirements.

> **unspecified**: Like implementation-defined, except that the choice need not be documented.

> **undefined**: Anything at all can happen; the Standard imposes no requirements. The program may fail to compile, or it may execute incorrectly (either crashing or silently generating incorrect results), or it may fortuitously do exactly what the programmer intended.

portable한 코드를 원한다면 세 개 중 어떤 것에도 의지하면 안된다.

## 12. Stdio

EOF는 모든 가능한 char값들과 구분되기에 EOF도 반환하는 getchar은 char가 아닌 int값을 반환한다.

> Depending on your operating system, you indicate end-of-file from the keyboard using various keystroke combinations, usually either control-D or control-Z.

```c
// 안된다
while(!feof(infp)) {
    fgets(buf, MAXLINE, infp);
    fputs(buf, outfp);
}
```

> feof, or more likely ferror, may be useful _after_ a stdio call has returned EOF or NULL, to distinguish between an end-of-file condition and a read error.

%를 프린트하고싶으면 \%가 아니라 %%를 사용한다. \%에서 \는 컴파일러의 escape character로 컴파일 시점에 어떻게 할지 결정하는 역할이다. 여기서는 printf가 런타임에 어떻게 할지 결정하는거니 %%를 사용한다.

printf와 같은 가변 길이 함수의 인자에는 default argument promotion이 일어나 float가 double로 promote된다. 그래서 printf에서 %f는 float나 double에 둘 다 작동함.

scanf는 포인터를 받기에 promotion의 적용을 받지 못한다. 따라서 %f와 %lf를 구분한다.

```c
#include <math.h>
#include <stdio.h>

int main() {
    int w;
    scanf("%d", &w);
    printf("%.*f\n", w, M_PI);
}
```

scanf에 공백 문자가 있다면 공백 문자를 읽으면 버리라는 뜻이다. 사실 %d도 이런 기능이 있어서 scanf에 공백 문자가 필요하지는 않다.

```c
#include <stdio.h>

int main() {
    int n;
    scanf("%d\n", &n);
    printf("you typed %d\n", n);
}
```

```c
#include <stdio.h>

int main() {
    int n;
    char str[80];

    printf("enter a number: ");
    scanf("%d", &n);
    printf("enter a string: ");
    gets(str);
    printf("you typed %d and \"%s\"\n", n, str);
}
```

42\na string을 입력하면 scanf가 42까지만 읽고, input stream에 남아있던 개행문자만으로 gets가 satisfy된다.

> scanf's peculiar treatment of newlines almost always leads to trouble. Either use scanf to read everything or nothing.

```c
#include <stdio.h>

// 안맞는 문자는 버퍼에서 안사라져서 무한루프.
int main() {
    int n = 314;

    while (1) {
        printf("enter a number: ");
        if (scanf("%d", &n) == 1)
            break;
        printf("try again: %d", n);
    }

    printf("you typed %d\n", n);
}
```

> scanf never gets past the bad character(s) to encounter later, valid data.

> The problem is a standard one in lexical analysis: when scanning an arbitrary-length numeric constant or alphanumeric identifier, you never know where it ends until you've read `too far'. This is one reason that ungetc exists.

[Standard streams](https://en.wikipedia.org/wiki/Standard_streams)

> Unlike fgets(), gets() cannot be told the size of the buffer it's to read into, so it cannot be prevented from overflowing that buffer if an input line is longer than expected.

> One other difference between fgets() and gets() is that fgets() retains the '\n'.

> fflush is defined only for output streams. Since its definition of ``flush'' is to complete the writing of buffered characters (not to discard them), discarding unread input would not be an analogous meaning for fflush on input streams.

> ... printf's close cousin sprintf, which 'prints' to a string:

> fseek or fflush is always required between reading and writing in the read/write "+" modes.

> When you're reading a binary data file, you should specify "rb" mode when calling fopen, to make sure that text file translations do not occur.

## 13. Library Functions

> sprintf can also be thought of as the opposite of atol and atof. atoi의 반대 역할도 할 수 있다.

```c
// substring 빼오는 방법들
char dest[LEN+1];
strncpy(dest, &source[POS], LEN);
dest[LEN] = '\0';

char dest[LEN+1] = "";
// strncat은 목적지 문자열이 \0으로 시작하면 strncpy와 유사하게 동작한다.
strncat(dest, source + POS, LEN);
```

> In general, it is a bad idea to insert casts just to 'shut the compiler up'.

> Algorithms like insertion sort and merge sort lend themselves ideally to use with linked lists.

일정 범위의 랜덤값이 필요할 때 mod N 연산을 하는 것은 low-order 비트들이 랜덤이 아닐 가능성이 있기에 좋지 않다. 아래 방법이 더 낫다.

```c
(int)((double)rand() / ((double)RAND_MAX + 1) * N)
rand() / (RAND_MAX / N + 1)
```

> In the general case of calling code in an external library, using #include to pull in the right header file(s) is only half of the story; you also have to tell the linker to search the external library itself. The declarations in the header file only tell the compiler how to call the external functions; the header file doesn't supply the definitions of the external functions, or tell the compiler/linker where to find those definitions.

## 14. Floating Point

> Among other things, the associative and distributive laws do not hold completely; that is, order of operation may be important, and repeated addition is not necessarily equivalent to multiplication.

> ... the best way of comparing two floating point values is to use an accuracy threshold which is relative to the magnitude of the numbers being compared.

```c
#include <math.h>
// 우변에서 a랑 곱하네?
if(fabs(a - b) <= epsilon * fabs(a)>)
// 작은 수는 차이가 작고, 큰 수는 차이가 클 것이라 적합하지 않다.
if(fabs(a - b) <= 0.001)
```

> Note that because truncation is otherwise the default, it's usually a good idea to use an explicit rounding step when converting floating-point numbers to integers. Unless you're careful, it's quite possible for a number which you thought was 8.0 to be represented internally as 7.999999 and to be truncated to 7.

```c
#define isnan(x) ((x) != (x))
```

## 15. Variable-Length Argument Lists

Default argument promotion으로 인해 %c도 사실 int값을 본다.

> Use vprintf, vfprintf, or vsprintf. These routines are like their counterparts printf, fprintf, and sprintf, except that instead of a variable-length argument list, they accept a single va_list pointer.

> C99 (but not any earlier C Standard) supports vscanf, vfscanf, and vsscanf.

> ... Therefore, it is never correct to invoke va_arg(argp, float); instead you should always use va_arg(argp, double).

## 16. Strange Problems

> C has only functions, and function calls always require parenthesized argument lists, even if empty.

다른 언어와 다르게 프로시저가 없다는 뜻인가?

main 함수의 exit 이후 cleanup하는 atexit라는 함수가 있던데 언제 쓰는걸까?

> ... Under Unix, any of these problems almost invariably leads to a 'core dump': a file named core, created in the current directory, containing a memory image of the crashed process, for debugging.

> The distinction between 'Bus error' and 'Segmentation Violation' may or may not be significant; different versions of Unix generate these signals under different sets of circumstances. Roughly speaking, a segmentation violation indicates an attempt to access memory which doesn't even exist, and a bus error indicates an attempt to access memory in an illegal way (perhaps due to an unaligned pointer; see question 16.7).

## 17. Style

> It is more important that the layout chosen be consistent (with itself, and with nearby or common code) than that it be 'perfect'.

> The elusive quality of ``good style'' involves much more than mere code layout details; don't spend time on formatting to the exclusion of more substantive code quality issues.

> Programming style, like writing style, is somewhat of an art and cannot be codified by inflexible rules, although discussions about style often seem to center exclusively around such rules.

> Most observations or ``rules'' about programming style (Structured Programming is Good, goto's are Bad, functions should fit on one page, etc.) usually work better as guidelines than rules, and work much better if programmers understand what the guidelines are trying to accomplish.

## 18. Tools and Resources

> The GNU C Library project provides the core libraries for the GNU system and GNU/Linux systems, as well as many other systems that use Linux as the kernel. [The GNU C Library (glibc)](https://www.gnu.org/software/libc/)

## 19. System Dependencies

> Input to a computer program typically passes through several stages. At the lowest level, device-dependent routines within the operating system handle the details of interfacing with particular devices such as keyboards, serial lines, disk drives, etc. Above that, modern operating systems tend to have a device-independent I/O layer, unifying access to any file or device. Finally, a C program is usually insulated from the operating system's I/O facilities by the portable functions of the stdio library.
>
> At some level, interactive keyboard input is usually collected and presented to the requesting program a line at a time. This gives the operating system a chance to support input line editing (backspace/delete/rubout, etc.) in a consistent way, without requiring that it be built into every program.
>
> When a program wants to read each character immediately as it arrives, its course of action will depend on where in the input stream the line collection is happening and how it can be disabled.
>
> Therefore, when you need to do character-at-a-time input (or disable keyboard echo, which is an analogous problem), you will have to use a technique specific to the system you're using, assuming it provides one.

```c
#include <sgtty.h>
#include <stdio.h>

static struct sgttyb savemodes;
static int havemodes = 0;

int tty_break() {
    struct sgttyb modmodes;
    if (ioctl(fileno(stdin), TIOCGETP, &savemodes) < 0)
        return -1;
    havemodes = 1;
    modmodes = savemodes;
    modmodes.sg_flags |= CBREAK;
    return ioctl(fileno(stdin), TIOCSETN, &modmodes);
}

int tty_getchar() {
    return getchar();
}

int tty_fix() {
    if (!havemodes)
        return 0;
    return ioctl(fileno(stdin), TIOCSETN, &savemodes);
}

int main() {
    int i;
    if (tty_break() != 0)
        return 1;
    for (i = 0; i < 10; i++)
        printf(" = %d\n", tty_getchar());
    tty_fix();
    return 0;
}
```

> Printing the character '\r' will usually give you a carriage return without a line feed, so that you can overwrite the current line. The character '\b' is a backspace, and will usually move the cursor one position to the left.

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    const int lotsa = 10;
    for (int i = 0; i < lotsa; i++) {
        printf("%c\b", "|/-\\"[i % 4]);
        fflush(stdout);
        usleep(500000);
    }

    for (int i = 0; i < lotsa; i++) {
        printf("\r%3d%%", (int)(100L * i / lotsa));
        fflush(stdout);
        usleep(500000);
    }

    printf("\ndone.\n");
}
```

> The above means, that write operations on output streams are not performed immediately, they are buffered, when you call fflush() then they are flushed to the disk, you don't need to fflush() explicitly all the time ... the "\n" at the end of the printed text, triggers a flush automatically, also when you call fclose() or exit the program the buffers are flushed. [the use of fflush(FILE\* stream)](https://stackoverflow.com/questions/30383901/the-use-of-fflushfile-stream)

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    printf("\033[2J");             /* clear screen */
    printf("\033[%d;%dH", 10, 20); /* move cursor (row 10, col 20) */
    printf("Hello, ");
    printf("\033[7mworld\033[0m!"); /* inverse video */
}
```

> Under Unix, you typically open, read, and write a device file in /dev, and use the facilities of the terminal driver to adjust its characteristics.

[serial port I/O](https://en.wikipedia.org/wiki/Serial_port)

> If the device is accessed via a dedicated 'I/O port', use system-specific functions to communicate with it. Under MS-DOS, for example, there were quasistandard 'inport' and ``outport'' instructions.
>
> If the device uses ``memory-mapped I/O'', that is, if the device register(s) are accessed as if they were normal memory at particular, known locations within the processor's addressing space, use contrived pointer variables to access those locations.

파일의 존재 유무 테스트는 테스트 도중에 다른 프로세스에 의해 파일이 생기고 사라질 수 있기 때문에 어렵다. 19.11 무슨 얘길까,,,

> How can I find out the size of a file, prior to reading it in?
>
> Under Unix, the stat call (specifically, the st_size field of the stat structure) will give you an exact answer.

> How can I read a directory in a C program?
>
> See if you can use the opendir and readdir functions, which are part of the POSIX standard and are available on most Unix variants.

```c
#include <dirent.h>
#include <stdio.h>
#include <sys/types.h>

int main() {
    struct dirent *dp;
    DIR *dfd = opendir(".");
    if (dfd != NULL) {
        while ((dp = readdir(dfd)) != NULL)
            printf("%s\n", dp->d_name);
        closedir(dfd);
    }
    return 0;
}
```

```c
// For example, on an MS-DOS machine in an 80x25 text mode, given the declaration

unsigned short (far * videomem)[80] =
		(unsigned short (far *)[80])0xb8000000;

// you can access the character and attribute byte at row i, column j with videomem[i][j].
```

> Many operating systems execute user-mode programs in a protected mode where direct access to I/O devices (or to any address outside the running process) is simply not possible. In such cases you will have to ask the operating system to carry out I/O operations for you.

> Under Unix, a process can modify its own environment (some systems provide setenv or putenv functions for the purpose), and the modified environment is generally passed on to child processes, but it is not propagated back to the parent process.

> However, clock gives elapsed processor time used by the current program, which on a multitasking system (or in a non-CPU-intensive program) may differ considerably from real time.

```c
#include <signal.h>

void func(int) {
}

int main() {
    // The test and extra call ensure that a keyboard interrupt typed in the foreground won't inadvertently interrupt a program running in the background (and it doesn't hurt to code calls to signal this way on any system).
    if (signal(SIGINT, SIG_IGN) != SIG_IGN)
        signal(SIGINT, func);
    for (size_t i = 0; i < 100000000000; i++) {
        /* code */
    }
}
```

> But I can't use all these nonstandard, system-dependent functions, because my program has to be ANSI compatible!
>
> You're out of luck. Either you misunderstood your requirement, or it's an impossible one to meet. ANSI/ISO Standard C simply does not define ways of doing these things; it is a language standard, not an operating system standard. An international standard which does address many of these issues is POSIX (IEEE 1003.1, ISO/IEC 9945-1), and many operating systems (not just Unix) now have POSIX-compatible programming interfaces.
>
> It is possible, and desirable, for most of a program to be ANSI-compatible, deferring the system-dependent functionality to a few routines in a few files which are either heavily #ifdeffed or rewritten entirely for each system ported to.

[19.42](https://c-faq.com/osdep/sysdep.html)

## 20. Miscellaneous

여기 챕터는 예제들이 많으니 필요할 떄 훑어보기.

> In general, you should detect errors by checking return values, and use errno only to distinguish among the various causes of an error, such as 'File not found' or 'Permission denied'.

```c
int chkadd(int a, int b) {
	if(INT_MAX - b < a) {
		fputs("int overflow\n", stderr);
		return INT_MAX;
	}
	return a + b;
}
```

> To avoid surprises involving the sign bit, it is often a good idea to use unsigned integral types in code which manipulates bits and bytes.

```c
#include <stdio.h>
#include <stdlib.h>

char *baseconv(unsigned int num, int base) {
    static char retbuf[33];
    char *p;

    if (base < 2 || base > 16)
        return NULL;

    p = &retbuf[sizeof(retbuf) - 1];
    *p = '\0';

    do {
        *--p = "0123456789abcdef"[num % base];
        num /= base;
    } while (num != 0);

    return p;
}

int main() {
    printf("%s\n", baseconv(21, 2));
    printf("%s\n", baseconv(21, 16));
}
```

[What's the best way of making my program efficient?](https://c-faq.com/misc/efficiency.html)

> The reasons for using ++i or i += 1 over i = i + 1 have to do with style, not efficiency.

```c
#include <stdio.h>

int main() {
    printf("%d\n", -7 >> 1);
}
```

> The switch statement was originally designed to be quite simple for the compiler to translate, therefore case labels are limited to single, constant, integral expressions.

> A hypothetical multi-level break, on the other hand, would rapidly lose the inherent cleanliness of the single break--programmers and readers of code would have to carefully count nesting levels to figure out what a given break did, and the insertion of a new intermediately-nested loop could, er, break things badly.

> But when you find the need for a multi-level break, it's often a sign that the loop should be broken out to its own function, at which point you can achieve roughly the same effect as that multi-level break by using a premature return.

> Assertions should not be used to catch expected errors, such as malloc or fopen failures.

> Hashing is the process of mapping strings to integers, usually in a relatively small range. A 'hash function'' maps a string (or some other data structure) to a bounded number (the 'hash bucket') which can more easily be used as an index in an array, or for performing repeated comparisons.
>
> When the set of strings is known in advance, it is also possible to devise ``perfect'' hashing functions which guarantee a collisionless, dense mapping.

> Simply speaking, an lvalue is an expression that could appear on the left-hand sign of an assignment; you can also think of it as denoting an object that has a location. (But see question 6.7 concerning arrays.) An rvalue is any expression that has a value (and that can therefore appear on the right-hand sign of an assignment).

```c
#include <stdio.h>
#define q(k)main(){return!puts(#k"\nq("#k")");}
q(#define q(k)main(){return!puts(#k"\nq("#k")");})
```
