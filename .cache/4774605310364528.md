
[Stateful vs Stateless Authentication](https://github.com/OpenIdentityPlatform/OpenAM/wiki/Stateful-vs-Stateless-Authentication)

- Stateful Methodologies: Authentication session can be revoked.
- Stateless Methodologies: Authentication session can't be revoked.

### Basic Authentication

1. Client tries to access some protected URL
1. Server checks if the request has Authorization header with valid username and password.
1. (If credentials don't exist or are invalid)
1. Browsers notice the www-authentication header in response and presents the alert for credentials.
1. User submits the credentials. Browser encodes them using base64 and sends in the next request.
1. Go to step 2.

realm or protection space is group of pages where the same credentials are used. Browser can cache the valid credentials for given realm and use them in future. Server is responsible for defining realms.

Basic auth is not considered secure unless used with TLS/HTTPS cause anyone can eavesdrop and decode the credentials.

```
Authorization: Basic aGlt0m922XJhY2hp2X2lcg==
```

[Example](https://httpbin.org/basic-auth/user/passwd)

### Session Based Authentication

User is assigned some unique identifier and this identifier is stored on the server in memory. Cliend sends this session id in all the requests and server uses it to identify the user.

Server keeps track of the loggedin users in memory or in storage.

1. Client sends the login request.
1. Server validates the credentials, creates a session and stores in memory and returns back the generated session id.
1. Client received the session id and stores it(ex. in cookie).
1. client sends next requests with session id.
1. When the user logs out, the session is destroyed. Same session ID cannot be reused.

### Token Based Authentication

Unlike the basic auth where username and passwords are send in each request, in token based authentication a token is sent from client to server in each request.

1. Client sends the credentials to generate a token.
1. Server validates the credentials.
1. Client stores this token in local storage or a cookie and sends in subsequent requests.
1. Server validates this token and returns response if token is valid.

**Characteristics of token**

- Some random looking string
- Has an expiry after which token is not usable
- Normally sent in the Authorization header
- Can be opaque(random string without any data) or self-contained(has data can be viewd by the clients)

SWT(Simple Web Token), JWT(JSON Web Tokens), OAuth(Open Authorization), SAML(Security Assertions Markup Language), OpenID.

### JWT Authentication

Works just like any other token based auth strategy. Only difference is how the token is generated.

Token is self contained. It carries the data. Anyone can view the content.

header.payload.signature.

**Header** is generated using base64. Token meta.

```json
{
  "typ": "jwt",
  "alg": "HS256" // hashing algorithm for the signiture part
}
```

**Payload** is string generated using base64. Our data.

```json
{
  "userId": "ASD",
  "email": "john@doe.com",
  "exp": "1592427938", // expiry time
  "iat": "1590969600" // issued at
}
```

Properties? are called claims. There are three types of claims. Registered / Public / Private claims.

**Signature** is string generated by hashing the header.

```js
signature = HMACSHA256(header + '.' + payload, 'secret').
// secret held at server and used to generate and verify tokens.
```

[if you can decode jwt how are they secure](https://stackoverflow.com/questions/27301557/if-you-can-decode-jwt-how-are-they-secure). So anyone will be able to decode them and to read them, we cannot store any sensitive data in here. But that's not a problem at all because in the third part, so in the signature, is where things really get interesting.

[What to Consider Before Using JWT](https://serengetitech.com/tech/what-to-consider-before-using-jwt/#:~:text=Because%20JWTs%20are%20used%20to,user%27s%20username%20and%20password%20instead.)

Because JWTs are used to identify the client, if one is stolen or compromised, the attacker has full access to the user’s account in the same way they would if the attacker had compromised the user’s username and password instead.

For instance, if an attacker gets hold of your JWT, they could start sending requests to the server identifying themselves as you and perform actions like making service changes, user account updates, etc. Once an attacker has your JWT, it’s game over.

However, there is one thing that makes a stolen JWT slightly better than a stolen username and password: timing. Because JWTs can be configured to automatically expire after a set amount of time – a minute, an hour, a day, etc. – attackers can only use your JWT to access the service until it expires.

### OAuth - Open Authrization

Open protocol for authorization that allows users to share their private resources to a third party.

2.0 version is active. 2.1 is draft.

There are 4 types of authorization flows(also called grant types) for generating a token which client uses to access protected resource.

**Authorization Code Grant Flow**

Implicit / Client / Password Grant Flow.

### SSO - Single Sign-On

Authentication strategy that allows a user to login with single username and password to serveral related but independent services.

SAML - Security Assertion Markup Language. Open Standard for exchanging authentication and authorization data between parties. There are three parties involved.

- User: Party that needs to access some resources.
- Identity Provider(IDP): Source of truth for who the user is and what they can do.
- Service Provider(SP): Services to which access is to be granted.
