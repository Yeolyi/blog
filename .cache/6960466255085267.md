
## Preface

The three easy pieces refer to the three major thematic elements the book is organized around: virtualization, concurrency, and persistence.

[프로젝트](https://github.com/remzi-arpacidusseau/ostep-projects)

[예제 코드](https://github.com/remzi-arpacidusseau/ostep-code)

[HW 솔루션](https://github.com/xxyzz/ostep-hw/tree/master/5)

Reading the famous papers of our field is certainly one of the best ways to learn.

And thus the real point of the educational process: to go forth, to study many new and fascinating topics, to learn, to mature, and most importantly, to find something that lights a fire for you.

## 2. Introducing to Operating Systems

> We will use the “crux of the problem”, in shaded boxes such as this one, as a way to call out specific problems we are trying to solve in building an operating system.

> **THE CRUX OF THE PROBLEM**: HOW TO VIRTUALIZE RESOURCES

### 2.1 Virtualizing The CPU

```c
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#include "../include/common.h"

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "usage: cpu<string>\n");
        exit(1);
    }
    char *str = argv[1];
    while (1) {
        Spin(1);
        printf("%s\n", str);
    }
    return 0;
}
```

> ./cpu A & ./cpu B & ./cpu C

### 2.2 Virtualizing Memory

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "../include/common.h"

int main(int argc, char *argv[]) {
    int *p = malloc(sizeof(int));
    assert(p != NULL);
    printf("(%d) address pointed to by p: %p\n", getpid(), p);
    *p = 0;
    while (1) {
        Spin(1);
        (*p)++;
        printf("(%d) p: %d\n", getpid(), *p);
    }
    return 0;
}
```

> ./mem &; ./mem &

For this example to work, you need to make sure address-space randomization is disabled; randomization, as it turns out, can be a good defense against certain kinds of security flaws.

### 2.3 Concurrency

```c
#include <stdio.h>
#include <stdlib.h>

#include "../include/common.h"
#include "../include/common_threads.h"

volatile int counter = 0;
int loops;

void *worker(void *arg) {
    int i;
    for (int i = 0; i < loops; i++)
        counter++;
    return NULL;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "usage: threads <value>\n");
        exit(1);
    }
    loops = atoi(argv[1]);
    pthread_t p1, p2;
    printf("Initial value: %d\n", counter);

    Pthread_create(&p1, NULL, worker, NULL);
    Pthread_create(&p2, NULL, worker, NULL);

    Pthread_join(p1, NULL);
    Pthread_join(p2, NULL);

    printf("Final value: %d\n", counter);
}
```

Because these three instructions do not execute atomically (all at once), strange things can happen. It is this problem of concurrency that we will address in great detail in the second part of this book.

> **THE CRUX OF THE PROBLEM**: HOW TO BUILD CORRECT CONCURRENT PROGRAMS

### 2.4 Persistence

The software in the operating system that usually manages the disk is called the **file system**; it is thus responsible for storing any files the user creates in a reliable and efficient manner on the disks of the system.

```c
#include <assert.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    int fd = open("/tmp/file", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXG);
    assert(fd > -1);
    int rc = write(fd, "hello world\n", 13);
    assert(rc == 13);
    close(fd);
    return 0;
}
```

These system calls are routed to the part of the operating system called the **file system**.

A **device driver** is some code in the operating system that knows how to deal with a specific device.

OS provides a standard and simple way to access devices through its sys- tem calls. Thus, the OS is sometimes seen as a **standard library**.

> **THE CRUX OF THE PROBLEM**: HOW TO STORE DATA PERSISTENTLY

### 2.5 Design Goals

So now you have some idea of what an OS actually does: it takes physical resources, such as a CPU, memory, or disk, and virtualizes them. It handles tough and tricky issues related to concurrency. And it stores files persistently, thus making them safe over the long-term.

이외에도 protection, isolation, reliability, energy-efficiency, security, mobility 등등이 있다.

### 2.6. Some History

Early OS는 just a set of libraries of commonly-used functions.

Old mainframe system은 인간 operator가 일의 순서를 지정했다. 그래서 이 사람한테 잘보여야됨 ^^,,, This mode of computing was known as batch processing, as a number of jobs were set up and then run in a **batch** by the operator. 컴퓨터가 비싸서 batch로 해야 낭비가 없다. Interactive하게 동작하지 않았음.

라이브러리로 제공하기에는 애매한 기능들이 있다. Implementing a file system (to manage your files) as a library makes little sense.

Procedure call이 아닌 system call의 개념이 생겼다. Add a special pair of hardware instructions and hardware state to make the transition into the OS a more formal, controlled process.

When a system call is initiated (usually through a special hardware instruction called a **trap**), the hard- ware transfers control to a pre-specified **trap handler** (that the OS set up previously) and simultaneously raises the privilege level to kernel mode.

Minicomputer가 보급되면서 , instead of having one mainframe per large organization, now a smaller collection of people within an organization could likely have their own computer. Developer activity가 증가했다. **Multiprogramming** 등장. 이로인해 memory protection, concurrency등의 issue가 생김.

**UNIX** was the unifying principle of building small powerful programs that could be connected together to form larger workflows. shell, pipe...

**Linux**. Borrowed heavily on the principles and ideas behind the original system, but not from the code base, thus avoiding issues of legality. Free and could be readliy modified to suit companies needs.

## I. Virtualization

## 4. The Abstraction: The Process

The definition of a process, informally, is quite simple: it is a running program.

> **THE CRUX OF THE PROBLEM**: HOW TO PROVIDE THE ILLUSION OF MANY CPUS?

This basic technique, known as time sharing of the CPU, allows users to run as many concurrent processes as they would like.

To implement virtualization of the CPU, and to implement it well, the OS will need both some low-level machinery(mechanisms) and some high-level intelligence(policies). Mechanisms are low-level methods or protocols that implement a needed piece of functionality. Policies are algorithms for making some kind of decision within the OS.

### 4.1 The Abstraction: A Process

> In many operating systems, a common design paradigm is to separate high-level policies from their low-level mechanisms [L+75]. You can think of the mechanism as providing the answer to a how question about a system; for example, how does an operating system perform a context switch? The policy provides the answer to a which question; for example, which process should the operating system run right now? Separating the two allows one easily to change policies without having to rethink the mechanism and is thus a form of modularity, a general software design principle.

Memory, address space, PC, stack pointer, I/O information등이 프로세스에 포함될 수 있다.

### 4.2 Process API

Create, Destroy, Wait, Miscellaneous Control(suspend 등..), Status에 대한 인터페이스가 필요하고 모든 OS에 존재한다.

### 4.3 Process Creation: A Little More Detail

Before running anything, the OS clearly must do some work to get the important program bits from disk into memory.

이후 스택과 힙을 할당한다. 스택에 main 함수로 전달된 인자를 배치한다.

The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process by default has three open file descriptors, for standard input, output, and error; these descriptors let programs easily read input from the terminal and print output to the screen.

### 4.4 Process States

Running, Ready, Blocked. Schedule/Deschedule로 Running과 Ready를 오가고, I/O 상태에 따라 Blocked를 오간다.

### 4.5 Data Structures

To track the state of each process, for example, the OS likely will keep some kind of **process list** for all processes that are ready and some additional information to track which process is currently running.

Register context.

Sometimes people refer to the individual structure that stores information about a process as a **Process Control Block (PCB)**, a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).

Exit했지만 정리되지 않은 프로세스를 final state에 있다고 할 수도 있다. UNIX에서는 zombie state라고 함. 프로세스의 리턴 코드를 확인해야될 때 유용하다. 부모 프로세스에서 확인한 이후 wait() 호출로 정리하게 할 수 있다.

### 4.6 Summary

- The **process** is the major OS abstraction of a running program. At any point in time, the process can be described by its state: the contents of memory in its **address space**, the contents of CPU registers (including the program counter and stack pointer, among others), and information about I/O (such as open files which can be read or written).

- The **process API** consistes of calls of programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.

- Processes exist in one of many different **process states**, including running, ready to run, and blocked. Different events (e.g., getting scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.

- A **process list** contains information about all processes in the system. Each entry is found in what is sometimes called a **process control block** (PCB), which is really just a structure that contains information about a specific process.

### Homework

2. p0 p0 p0 p0 p1_io blocked\*5 p1_io_done. 11.

3. p0_io p1\*4 p0_blocked p0_io_done. 7

4. 11

5. 7

6. No!! 마지막으로 밀리게 된다.

7. 밀린 i/o 작업이 있을 수 있기 때문에?

8. io/io_done은 CPU인데 IOs는 아니네?

```
<SEED 1>
Process 0
  cpu
  io
  io_done
  io
  io_done

Process 1
  cpu
  cpu
  cpu

IO_RUN_IMMEDIATE / SWITCH_ON_IO = 15 / 8 / 10
IO_RUN_IMMEDIATE / SWITCH_ON_END = 18 / 8 / 10
IO_RUN_LATER / SWITCH_ON_IO = 15 / 8 / 10
IO_RUN_LATER / SWITCH_ON_END = 18 / 8 / 10 ?? 근데 이 조합이 의미가 있나

<SEED 2>
Process 0
  io
  io_done
  io
  io_done
  cpu

Process 1
  cpu
  io
  io_done
  io
  io_done

IO_RUN_IMMEDIATE / SWITCH_ON_IO = 16 / 10 / 14
IO_RUN_IMMEDIATE / SWITCH_ON_END = 30 / 10 / 20
IO_RUN_LATER / SWITCH_ON_IO = 16 / 10 / 14
IO_RUN_LATER / SWITCH_ON_END = 30 / 10 / 20

<SEED 3>
Process 0
  cpu
  io
  io_done
  cpu

Process 1
  io
  io_done
  io
  io_done
  cpu

IO_RUN_IMMEDIATE / SWITCH_ON_IO = 17 / 9 / 11
IO_RUN_IMMEDIATE / SWITCH_ON_END = 24 / 9 / 15
IO_RUN_LATER / SWITCH_ON_IO = 18 / 9 / 11
IO_RUN_LATER / SWITCH_ON_END = 24 / 9 / 15
```

### 5. Interlude: Process API

> CRUX: HOW TO CREATE AND CONTROL PROCESSES: What interfaces should the OS present for process creation and control? How should these interfaces be designed to enable powerful functionality, ease of use, and high performance?

### 5.1 The fork() System Call

[exit vs return](https://stackoverflow.com/questions/3463551/what-is-the-difference-between-exit-and-return)

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    printf("hello world (pid:%d)\n", (int)getpid());
    int rc = fork();
    if (rc < 0) {
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) {
        printf("hello, I am child (pid:%d)\n", (int)getpid());
    } else {
        printf("hello, I am parent of %d (pid:%d)\n", rc, (int)getpid());
    }
    return 0;
}
```

**PID(process identifier)**

While the parent receives the PID of the newly-created child, the child receives a return code of zero.

You might also have noticed: the output (of p1.c) is not **deterministic**. 뭐가 먼저 printf할지 알 수 없다.

### 5.2 The wait() System Call

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    printf("hello world (pid:%d)\n", (int)getpid());
    int rc = fork();
    if (rc < 0) {
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) {
        printf("hello, I am child (pid:%d)\n", (int)getpid());
    } else {
        int rc_wait = wait(NULL);
        printf("hello, I am parent of %d (rc_wait:%d) (pid:%d)\n", rc, rc_wait, (int)getpid());
    }
    return 0;
}
```

[man pages for bash builtin commands](https://stackoverflow.com/questions/22991942/where-to-view-man-pages-for-bash-builtin-commands). 왜 system call에 대한 man을 쉘에서 제공하지? [In Linux, how do I get man pages for C functions rather than for bash commands?](https://stackoverflow.com/questions/18920539/in-linux-how-do-i-get-man-pages-for-c-functions-rather-than-for-bash-commands). 쉘 명령어랑 C랑 man이 따로 있네. 쉘 스크립트에서도 fork와 같은 여러 작업을 할 수 있다.

```bash
echo "Hello World"
(sleep 5; echo "Hello World") &
wait
```

If job is not given then all currently active child processes are waited for.

[iterm2 vs zsh vs oh-my-zsh](https://stackoverflow.com/questions/64310320/difference-between-iterm2-zsh-and-oh-my-zsh)

bashFork 실행하려니까 chmod해줘야되네. [How to add chmod permissions to file in Git?](https://stackoverflow.com/questions/40978921/how-to-add-chmod-permissions-to-file-in-git).

### 5.3 Finally, The exec() System Call

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
    printf("hello world (pid:%d)\n", (int)getpid());
    int rc = fork();
    if (rc < 0) {
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) {
        printf("hello, I am child (pid:%d)\n", (int)getpid());
        char *myargs[3];
        myargs[0] = strdup("wc");
        myargs[1] = strdup("p3.c");
        myargs[2] = NULL;
        // char * const *
        execvp(myargs[0], myargs);
        printf("this shouldn't print out");
    } else {
        int rc_wait = wait(NULL);
        printf("hello, I am parent of %d (rc_wait:%d) (pid:%d) \n", rc, rc_wait, (int)getpid());
    }
    return 0;
}
```

It runs wc on the source file p3.c, thus telling us how many lines, words, and bytes are found in the file:

exec loads code (and static data) from excutable and overwrites its current code segment with it; the heap and stack and other parts of the memory space of the program are re-initialized. Thus, **it does not create a new process**.

[Why is strdup() used here?](https://stackoverflow.com/questions/69505245/why-is-strdup-used-here)

### 5.4 Why? Motivating The API

The separation of fork() and exec() is essential in building a UNIX shell, because it lets the shell run code after the call to fork() but before the call to exec(); this code can alter the environment of the about-to-be-run program, and thus enables a variety of interesting features to be readily built.

The shell is just a user program4. It shows you a **prompt** and then waits for you to type something into it. You then type a command (i.e., the name of an executable program, plus any arguments) into it; in most cases, the shell then figures out where in the file system the executable resides, calls fork() to create a new child process to run the command, calls some variant of exec() to run the command, and then waits for the command to complete by calling wait(). When the child completes, the shell returns from wait() and prints out a prompt again, ready for your next command.

```
prompt> wc p3.c > newfile.txt
```

```c
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
    int rc = fork();
    if (rc < 0) {
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) {
        close(STDOUT_FILENO);
        open("./p4.output", O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);

        char *myargs[3];
        myargs[0] = strdup("wc");
        myargs[1] = strdup("p3.c");
        myargs[2] = NULL;
        execvp(myargs[0], myargs);
    } else {
        int rc_wait = wait(NULL);
    }
    return 0;
}
```

When the child is created, before calling exec(), the shell closes standard output and opens the file newfile.txt. By doing so, any output from the soon-to-be-running program wc are sent to the file instead of the screen.

The reason this redirection works is due to an assumption about how the operating system manages file descriptors. Specifically, UNIX systems start looking for free file descriptors at zero. In this case, STDOUT FILENO will be the first available one and thus get assigned when open() is called. Subse- quent writes by the child process to the standard output file descriptor, for example by routines such as printf(), will then be routed transpar- ently to the newly-opened file instead of the screen.

UNIX pipes are implemented in a similar way, but with the pipe() system call. In this case, the output of one process is connected to an in- kernel **pipe**.

```
grep -o foo file | wc -l
```

### 5.5 Process Control And Users

There are a lot of other interfaces for interacting with processes in UNIX systems.

The kill() system call is used to send signals to a process, including di- rectives to pause, die, and other useful imperatives.

대부분의 유닉스 쉘에서 현재 running 중인 프로세스에 시그널을 보내기 위한 단축키가 설정되어있다. ctrl-c는 SIGINT(interrupt, 대부분 종료), ctrl-z는 SIGTSTP(pause, fg로 재시작).

단일 프로세스뿐만 아니라 process groups에 시그널을 보낼 수도 있다. signal() system call을 사용한다.

프로세스에 시그널을 보낼 수 있는 사람을 규정하기 위해 **user**라는 개념을 사용한다. 자기 자신의 프로세스만을 컨트롤할 수 있다.

[RTFM](https://namu.wiki/w/RTFM)

### 5.6 Useful Tools

Using the ps command allows you to see which processes are running.

The tool top is also quite helpful, as it displays the processes of the system and how much CPU and other resources they are eating up.

The command kill can be used to send arbitrary signals to processes, as can the slightly more user friendly killall.

### 5.7 Summary

[A fork() in the road](https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf)

A system generally needs a user who can administer the system, and is not limited in the way most users are. Such a user should be able to kill an arbitrary process.

In UNIX-based systems, these special abil- ities are given to the superuser (sometimes called root).

- A UNIX shell commonly uses fork(), wait(), and exec() to launch user commands; the separation of fork and exec enables features like input/output redirection, pipes, and other cool features, all without changing anything about the programs being run.

- Process control is available in the form of signals, which can cause jobs to stop, continue, or even terminate.

- Which processes can be controlled by a particular person is encapsulated in the notion of a user; the operating system allows multiple users onto the system, and ensures users can only control their own processes.

- A superuser can control all processes (and indeed do many other things); this role should be assumed infrequently and with caution for security reasons.

### Homework

Thus, all processes are related in a tree, rooted at the initial process. We will call this tree the `Process Tree`.

-R가 없으면 orphaned process가 initial process에 붙고 있으면 reparent to local parent한다.

```c
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

char data[] = "Hello, world!";
char data2[] = "Bye, world!";

// file descriptor도 복제 잘 되는 듯. 같은 값을 공유한다. 커서? 같은게 어디있는지는 따로 공유하는 듯.
// 신기한게 fork 이후 open을 해도 같은 file descriptor이다. 같은 파일이고 열려있으면 재활용하나봄?
// fork 이후 open을 하면 커서가 각각 처음부터 시작하는 것 같고, 반대는 뒤에 덧붙여진다. f값을 공유는 하는데 open이 불릴 때마다 커서 위치가 바뀌나?
// 뒤에 이어서 쓴다.
int main() {
    int f = open("./forkopen.txt", O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
    int rc = fork();
    printf("%d\n", f);

    if (rc < 0) {
        fprintf(stderr, "fork failed\n");
    } else if (rc == 0) {
        // sizeof 안된다,,
        write(f, data, strlen(data));
    } else {
        write(f, data2, strlen(data2));
    }

    close(f);

    return 0;
}
```

```c
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

// Using kill() to send SIGCONT signal to parent process.
// Read from pipe.
// https://github.com/xxyzz/ostep-hw/blob/master/5/3.c
int main() {
    pid_t rc = fork();

    if (rc < 0) {
        fprintf(stderr, "fork failed\n");
    } else if (rc == 0) {
        printf("goodbye\n");
    } else {
        printf("hello\n");
    }

    return 0;
}
```

[exec (system call): C language prototypes](<https://en.wikipedia.org/wiki/Exec_(system_call)#C_language_prototypes>)

wait는 기다릴게 없으면 -1을 반환한다.

The waitpid() function takes three arguments: the process ID of the child process to wait for (pid), a pointer to an integer to store the termination status of the child process (status), and options (we use 0 for no additional options).

```c
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
    int rc = fork();
    if (rc < 0) {
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) {
        close(STDOUT_FILENO);
        // print 안됨
        printf("Hello, world!");
    } else {
        int rc_wait = wait(NULL);
    }
    return 0;
}
```

```c
#include <stdio.h>
#include <string.h>
#include <unistd.h>

char message[] = "Hello, child process!";
char buffer[100];

int main() {
    int pipefd[2];
    pid_t pid;

    // Create a pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        return 1;
    }

    // Fork a child process
    pid = fork();

    if (pid == -1) {
        perror("fork");
        return 1;
    } else if (pid == 0) {
        // Close the write end of the pipe
        close(pipefd[1]);

        // Read from the pipe
        ssize_t bytesRead = read(pipefd[0], buffer, sizeof(buffer));

        if (bytesRead == -1) {
            perror("read");
            return 1;
        }

        printf("Child process received: %s\n", buffer);

        // Close the read end of the pipe
        close(pipefd[0]);
    } else {
        // Close the read end of the pipe
        close(pipefd[0]);

        // Write to the pipe
        ssize_t bytesWritten = write(pipefd[1], message, strlen(message));

        if (bytesWritten == -1) {
            perror("write");
            return 1;
        }

        printf("Parent process sent: %s\n", message);

        // Close the write end of the pipe
        close(pipefd[1]);
    }

    return 0;
}
```

[Is it really necessary to close the unused end of the pipe in a process](https://stackoverflow.com/questions/24766013/is-it-really-necessary-to-close-the-unused-end-of-the-pipe-in-a-process)

## 6. Mechanism: Limited Direct Execution

> **THE CRUX: HOW TO EFFICIENTLY VIRTUALIZE THE CPU WITH CONTROL**: The OS must virtualize the CPU in an efficient manner while retaining control over the system. To do so, both hardware and operating-system support will be required. The OS will often use a judicious bit of hardware support in order to accomplish its work effectively.

### 6.1 Basic Technique: Limited Direct Execution

Direct execution은 프로그램이 뭘 하는지 알 수 없고 프로그램의 실행을 멈출 수도 없다.

Without limits on running programs, the OS wouldn’t be in control of anything and thus would be "just a library".

### 6.2 Problem #1: Restricted Operations

> **THE CRUX: HOW TO PERFORM RESTRICTED OPERATIONS:** A process must be able to perform I/O and some other restricted oper- ations, but without giving the process complete control over the system. How can the OS and hardware work together to do so?

> **ASIDE: WHY SYSTEM CALLS LOOK LIKE PROCEDURE CALLS**: You may wonder why a call to a system call, such as open() or read(), looks exactly like a typical procedure call in C; that is, if it looks just like a procedure call, how does the system know it’s a system call, and do all the right stuff? The simple reason: it is a procedure call, but hidden inside that procedure call is the famous trap instruction. More specifically, when you call open() (for example), you are executing a procedure call into the C library. Therein, whether for open() or any of the other system calls provided, the library uses an agreed-upon calling convention with the kernel to put the arguments to open() in well-known locations (e.g., on the stack, or in specific registers), puts the system-call number into a well-known location as well (again, onto the stack or a register), and then executes the aforementioned trap instruction. The code in the library after the trap unpacks return values and returns control to the program that issued the system call. Thus, **the parts of the C library that make system calls are hand-coded in assembly**, as they need to carefully follow convention in order to process arguments and return values correctly, as well as execute the hardware-specific trap instruction. And now you know why you personally don’t have to write assembly code to trap into an OS; somebody has already written that assembly for you.

Two processor mode - user mode / kernel mode. 유저는 kernel mode로의 전환을 위해 system call을 수행할 수 있다. System calls allow the kernel to carefully expose certain key pieces of functionality to user programs. To execute a system call, a program must execute a special **trap** instruction. This instruction simultaneously jumps into the kernel and raises the privilege level to kernel mode.

[How does the linux kernel update itself?](https://unix.stackexchange.com/questions/563208/how-does-the-linux-kernel-update-itself)

Trap 실행 이후 원상복구를 위해 x86에서는 kernal stack에 백업해놓는다.

The geometry of innocent flesh on the bone: return-into-libc without function calls (on the x86).

How does the trap know which code to run inside the OS? The kernel does so by setting up a **trap table** at boot time. 근데 OS 고정 위치로 점프하게하고 거기서 system call number를 읽으면 안되나?

trap과 return-from-trap은 하드웨어가 담당하는 듯?

To specify the exact system call, a **system-call number** is usually assigned to each system call. User code cannot specify an exact address to jump to, but rather must request a particular service via number.

Kernel stack이 프로세스별로 있다고 가정하네? 한 개가 아닌건가. We assume each process has a kernel stack where registers (including general purpose registers and the program counter) are saved to and restored from (by the hardware) when transitioning into and out of the kernel. 백업하고 복원하는 작업은 하드웨어가 한다.

유저 프로그램은 결국에 exit system call 등으로 끝난다.

### 6.3 Problem #2: Switching Between Processes

> **THE CRUX: HOW TO REGAIN CONTROL OF THE CPU** How can the operating system regain control of the CPU so that it can switch between processes?

A Cooperative Approach: Wait For System Calls.

A Non-Cooperative Approach: The OS Takes Control.

> **THE CRUX: HOW TO GAIN CONTROL WITHOUT COOPERATION** How can the OS gain control of the CPU even if processes are not being cooperative? What can the OS do to ensure a rogue process does not take over the machine?

Timer interrupt. Pre-configured interrupt handler in the OS runs.

The timer can also be turned off, something we will discuss later when we understand concurrency in more detail.

Note that the hardware has some responsibility when an interrupt occurs, in particular to save enough of the state of the program that was running when the interrupt occurred such that a subsequent return-from-trap instruction will be able to resume the running program correctly. This set of actions is quite similar to the behavior of the hardware during an explicit system-call trap into the kernel, with various registers thus getting saved (e.g., onto a kernel stack) and thus easily restored by the return-from-trap instruction.

A **context switch** is conceptually simple: all the OS has to do is save a few register values for the currently-executing process (onto its kernel stack, for example) and restore a few for the soon-to-be-executing process (from its kernel stack). By doing so, the OS thus ensures that when the return-from-trap instruction is finally executed, instead of returning to the process that was running, the system resumes execution of another process.

...Because you only load the esp of the Kernel Stack from the PCB, and the rest of the registers from the Kernel Stack. [StackOverflow](https://stackoverflow.com/questions/67955845/during-a-context-switch-does-the-os-use-pcb-or-kernel-stack-to-restore-register)

The first is when the timer interrupt occurs; in this case, the user registers of the running process are implicitly saved by the hardware, using the kernel stack of that process. The second is when the OS decides to switch from A to B; in this case, the kernel registers are explicitly saved by the software (i.e., the OS), but this time into memory in the process structure of the process.

[What's the difference between user registers and kernel registers?](https://cs.stackexchange.com/questions/96550/whats-the-difference-between-user-registers-and-kernel-registers)

context switch는 나중에 다시 읽어보자,,

### 6.4 Worried About Concurrency?

The OS does indeed need to be concerned as to what happens if, during interrupt or trap handling, another interrupt occurs. This, in fact, is the exact topic of the entire second piece of this book, on concurrency;

Operating systems also have developed a number of sophisticated locking schemes to protect concurrent access to internal data structures. This enables multiple activities to be on-going within the kernel at the same time, particularly useful on multiprocessors.

## 7. Scheduling: Introduction

지금까지는 mechanism, 이제부터는 policy.

> **THE CRUX: HOW TO DEVELOP SCHEDULING POLICY** How should we develop a basic framework for thinking about scheduling policies? What are the key assumptions? What metrics are important? What basic approaches have been used in the earliest of computer systems?

스케쥴러 개념은 컴퓨터 공학 이전부터 있었다.

### 7.1 Workload Assumptions

Workload. Processes running in the system.

We will make the following assumptions about the processes, sometimes called **jobs**, that are running in the system:

1. Each job runs for the same amount of time.
2. All jobs arrive at the same time.
3. Once started, each job runs to completion.
4. All jobs only use the CPU (i.e., they perform no I/O)
5. The runtime of each job is known.

### 7.2 Scheduling Metrics

Policy의 비교를 위한 metric.

Turnaround time. T_turnaround = T_completion − T_arrival. 얘는 performance metric이고 faitness metric도 있다.

### 7.3 First In, First Out(FIFO)

Assumption 1을 제외하고 생각해보면 처음애 온 애가 오래 실행되면 불리하다. 이를 **convoy effect**라 한다.

### 7.4 Shortest Job First(SJF)

Assumption 2를 제외하면 얘도 좋지 않다. 긴 프로세스 중간에 짧은 프로세스가 오면 비효율적이다.

### 7.5 Shortest Time-to-Completion First(STCF)

preemptive / non-preemptive

이를 해결하기 위해 assumption 3를 빼보자. 이전에 배운 timer interrupt와 context switching을 활용하자. 새로운 작업이 들어오면 남은 작업들 중에 최소 시간이 남은 일을 수행한다.

### 7.6 A New Metric: Response Time

Early batch computing system에서는 쓸만했지만 사용자와 interactive한 환경이 되면서 reponse time도 중요해졌다.

T_response = T_firstrun − T_arrival

> Some define it slightly differently, e.g., to also include the time until the job produces some kind of “response”; our definition is the best-case version of this, essentially assuming that the job produces a response instantaneously.

STCF와 친구들은 response time이 좋지 않다.

### 7.7 Round Robin

Instead of running jobs to completion, RR runs a job for a **time slice** (sometimes called a **scheduling quantum**) and then switches to the next job in the run queue. It repeatedly does so until the jobs are finished. For this reason, RR is sometimes called **time-slicing**.

Time slice의 길이는 timer interrupt의 배수여야한다. Interrupt라고 무조건 바꾸지 않는 듯.

Deciding on the length of the time slice presents a trade-off to a system de- signer, making it long enough to **amortize** the cost of switching.

RR은 turnaround time 측면에서 최악이다. 일반적으로 fair한 policy는 turnaround time이 좋지 않다.

아직 없애지 않은 assumption 4, 5를 살펴보자.

### 7.8 Incorporating I/O

Currently-running job won’t be using the CPU during the I/O; it is **blocked** waiting for I/O completion.

[How to see how many context switches a process makes?](https://unix.stackexchange.com/questions/39342/how-to-see-how-many-context-switches-a-process-makes)

A common approach is to treat each 10-ms sub-job of A as an independent job. Doing so allows for **overlap**, with the CPU being used by one process while waiting for the I/O of another process to complete.

[Each process has a kernel stack (or more generally, each thread has its own stack)](https://www.cs.umb.edu/~eoneil/cs444_f06/class10.html#:~:text=Each%20process%20has%20a%20kernel,thread%20has%20its%20own%20stack)

### 7.9 No More Oracle

With a basic approach to I/O in place, we come to our final assump- tion: that the scheduler knows the length of each job. As we said before, this is likely the worst assumption we could make.

### 7.10 Summary

Shortly, we will see how to overcome this problem, by building a scheduler that uses the recent past to predict the future. This scheduler is known as the **multi-level feedback queue**, and it is the topic of the next chapter.

## II. Concurrency

## III. Persistence
