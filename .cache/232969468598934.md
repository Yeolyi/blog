
## PART 1: The JavsScript langauge

## An introduction

Scripts are provided and executed as plain text. They don’t need special preparation or compilation to run.

- V8 – in Chrome, Opera and Edge.
- SpiderMonkey – in Firefox.
- …There are other codenames like “Chakra” for IE, “JavaScriptCore”, “Nitro” and “SquirrelFish” for Safari, etc.

In-browser JavaScript is able to:

- Add new HTML to the page, change the existing content, modify styles.
- React to user actions, run on mouse clicks, pointer movements, key presses.
- Send requests over the network to remote servers, download and upload files (so-called AJAX and COMET technologies).
- Get and set cookies, ask questions to the visitor, show messages.
- Remember the data on the client-side (“local storage”).

JavaScript’s abilities in the browser are limited to protect the user’s safety:

- JavaScript on a webpage may not read/write arbitrary files on the hard disk, copy them or execute programs. It has no direct access to OS functions.
- There are ways to interact with the camera/microphone and other devices, but they require a user’s explicit permission.
- Different tabs/windows generally do not know about each other. This is called the **“Same Origin Policy”**.
- But its ability to receive data from other sites/domains is crippled.

There are at least three great things about JavaScript:

- Full integration with HTML/CSS.
- Simple things are done simply.
- Supported by all major browsers and enabled by default.

So, recently a plethora of new languages appeared, which are transpiled (converted) to JavaScript before they run in the browser:

- Dart is a standalone language that has its own engine that runs in non-browser environments (like mobile apps), but also can be transpiled to JavaScript. Developed by Google.
- Brython is a Python transpiler to JavaScript that enables the writing of applications in pure Python without JavaScript.

[The ECMS-262 **specification**](https://www.ecma-international.org/publications/standards/Ecma-262.htm) contains the most in-depth, detialed, and formalized information about JavaScript. It defines the language.

MDN (Mozilla) JavaScript Reference is the main **manual** with examples and other information

**Compatibility tables**: https://caniuse.com – per-feature tables of support,

## JavaScript Fundamentals

The benefit of a separate file is that the browser will download it and store it in its cache.

JavaScript interprets the line break as an “implicit” semicolon. This is called an automatic semicolon insertion.

But there are situations where JavaScript “fails” to assume a semicolon where it is really needed.

```js
// prettier-ignore
alert("Hello")

[1, 2].forEach(alert);
```

There may not be /\*...\*/ inside another /\*...\*/.

To keep the old code working, most modifications in ES5 are off by default. You need to explicitly enable them with a special directive: "use strict". When it is located at the top of a script, the whole script works the “modern” way.

Modern JavaScript supports “classes” and “modules” – advanced language structures (we’ll surely get to them), that enable use strict automatically. So we don’t need to add the "use strict" directive, if we use them.

```js
// 'use strict';

var isStrict = (function () {
  return !this;
})();
console.log(isStrict);
```

It’s interesting to note that there exist so-called pure functional programming languages, such as Haskell, that forbid changing variable values.

What’s interesting – the dollar sign '$' and the underscore '\_' can also be used in names.

```js
// 'use strict';
num = 5;
console.log(num);
```

There is a widespread practice to use constants as aliases for difficult-to-remember values that are **known prior to execution**. Such constants are named using capital letters and underscores.

Programming languages that allow such things, such as JavaScript, are called **“dynamically typed”**, meaning that there exist data types, but variables are not bound to any of them.

**NaN** represents a computational error. It is a result of an incorrect or an undefined mathematical operation, for instance:

NaN is sticky. Any furthur mathematical operation on NaN returns NaN:

```js
console.log(NaN + 1); // NaN
console.log(3 * NaN); // NaN
console.log('not a number' / 2 - 1); // NaN

// there’s only one exception to that:
console.log(NaN ** 0);
```

Doing maths is “safe” in JavaScript. The script will never stop with a fatal error.

The JavaScript Number type is a double-precision 64-bit binary format IEEE 754 value.

BigInt type was recently added to the language to represent integers of arbitrary length.

```js
// the "n" at the end means it's a BigInt
const bigInt = 1234567890123456789012345678901234567890n;
```

In JavaScript, **null** is not a “reference to a non-existing object” or a “null pointer” like in some other languages. It’s just a special value which represents “nothing”, “empty” or “value unknown”.

The meaning of **undefined** is “value is not assigned”.

**Normally, one uses null to assign an “empty” or “unknown” value to a variable, while undefined is reserved as a default initial value for unassigned things.**

The object type is special. All other types are called **“primitive”** because their values can contain only a single thing (be it a string or a number or whatever). In contrast, objects are used to store collections of data and more complex entities.

The symbol type is used to create unique identifiers for objects.

The result of typeof null is "object". That’s an officially recognized error in typeof, coming from very early days of JavaScript and kept for compatibility.

Functions belong to the object type. But typeof treats them differently, returning "function". That also comes from the early days of JavaScript. Technically, such behavior isn’t correct, but can be convenient in practice.

typeof is an operator, not a function.

```js
// The square brackets around default denote that the parameter is optional, not required.
result = prompt(title, [default]);

let age = prompt('How old are you?', 100);
alert(`You are ${age} years old!`); // You are 100 years old!

let isBoss = confirm("Are you the boss?");
alert( isBoss ); // true if OK is pressed
```

All these methods are modal: they pause script execution and don’t allow the visitor to interact with the rest of the page until the window has been dismissed.

```js
let obj = { a: 1, b: 2 };
console.log(String(obj)); // [object Object]
console.log(obj + ''); // [object Object]
console.log(obj); // { a: 1, b: 2}

console.log(+undefined); // NaN
console.log(+null); // 0
```

- Values that are intuitively “empty”, like 0, an empty string, null, undefined, and NaN, become false.
- Other values become true.

The notable exceptions where people usually make mistakes are:

- undefined is NaN as a number, not 0.
- "0" and space-only strings like " " are true as a boolean.

```js
console.log(-5 % 2); // -1
console.log(-5 % -2); // -1
```

Exponentiation operator를 square root로 활용할 수 있다.

[Precedence table](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

Let’s note that an assignment = is also an operator. It is listed in the precedence table with the very low priority of 2. The fact of = being an operator, not a “magical” language construct has an interesting implication. All operators in JavaScript return a value. That’s obvious for + and -, but also true for =.

Bitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation. 오 자바처럼 >>랑 >>>가 있음.

```js
-1 >>> 1; // 2147483627
1 << 33; // 2, rotate되는 듯
```

```js
let a = (1 + 2, 3 + 4);
alert(a); // 7 (the result of 3 + 4)
// Comma operator has very low precedence, lower than =
```

+는 문자열 덧셈일수도, 수 뺄셈일 수도 있다.

```js
"  -9  " + 5 = "  -9  5"
"  -9  " - 5 = -14
undefined + 1 = NaN
" \t \n" - 2 = -2
```

To see whether a string is greater than another, JavaScript uses the so-called “dictionary” or “lexicographical” order. Not a real dictionary, but Unicode order. For instance, "A" < "a".

When comparing values of different types, JavaScript converts the values to numbers. NaN != NaN이라서 가능한건가?

두 값이 같지만 boolean 변환값은 다를 수 있다. 0과 "0".

A strict equality operator === checks the equality without type conversion.

null and undefined are a “sweet couple”: they equal each other (in the sense of ==), but not any other value.

```js
alert(null > 0); // (1) false
alert(null == 0); // (2) false
alert(null >= 0); // (3) true

// (1), (3). Comparisons convert null to a number.
// (2). Equality check == for undefined and null is defined they equal each other and don't equal anything else.
```

The value undefined shouldn’t be compared to other values:

```js
alert(undefined > 0); // false (1)
alert(undefined < 0); // false (2)
alert(undefined == 0); // false (3)
```

Comparisons (1) and (2) return false because undefined gets converted to NaN and NaN is a special numeric value which returns false for all comparisons. The equality check (3) returns false because undefined only equals null, undefined, and no other value.

- Treat any comparison with undefined/null except the strict equality === with exceptional care.
- Don’t use comparisons >= > < <= with a variable which may be null/undefined, unless you’re really sure of what you’re doing.

Checking for null/undefined separately is a good idea.

```js
"2" > "12" → true
null == "\n0\n" → false
```

The purpose of the question mark operator ? is to return one value or another depending on its condition. Please use it for exactly that. Use if when you need to execute different branches of code:

```js
// It’s not recommended to use the question mark operator in this way.
company == 'Netscape' ? alert('Right!') : alert('Wrong.');
```

A chain of OR || returns the first truthy value or the last one if no truthy value is found.

```js
undefined || null || 0; // 0
1 && 2 && 3; // 3, the last one
```

The precedence of AND && operator is higher than OR ||.

```js
alert(alert(1) && alert(2));
// 1 then undefined

alert(null || (2 && 3) || 4);
// 3
```

```js
let firstName = null;
let lastName = null;
let nickName = 'Supercoder';

// shows the first defined value:
alert(firstName ?? lastName ?? nickName ?? 'Anonymous'); // Supercoder
```

The important difference between || and ?? is that:

- || returns the first truthy value.
- ?? returns the first defined value.

```js
let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
// In practice, the zero height is often a valid value
```

Due to safety reasons, JavaScript forbids using ?? together with && and || operators.

The operator ?? has a very low precedence, only a bit higher than ? and =, so consider adding parentheses when using it in an expression.

```js
let num = null;
console.log((num ??= 10)); // 10
console.log(num); // 10
```

Any part of `for` can be skipped. Please note that the two for semicolons ; must be present.

```js
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (i === 2 && j === 2) break outer;
    // continue outer; 도 된다.
    console.log(i, j);
  }
}
```

C 처럼 switch문에 break 열심히 써놔야함. The equality check is always strict. The values must be of the same type to match.

In function, the outer variable is only used if there’s no local one. If a same-named variable is declared inside the function then it shadows the outer one.

[Is JavaScript a pass-by-reference or pass-by-value language?](https://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language)

If a function is called, but an argument is not provided, then the corresponding value becomes undefined.

```js
function showMessage(from, text = 'no text given') {
  alert(from + ': ' + text);
}

showMessage('Ann'); // Ann: no text given

function showMessage(from, text = anotherFunction()) {
  // anotherFunction() only executed if no text given
  // its result becomes the value of text
}
```

In JavaScript, a default parameter is evaluated every time the function is called without the respective parameter.

A function with an empty return or without it returns undefined A function should do exactly what is suggested by its name, no more.

Functions that are used very often sometimes have ultrashort names. For example, the jQuery framework defines a function with $. The Lodash library has its core function named \_.

In JavaScript, a function is not a “magical language structure”, but a special kind of value.

```js
let sayHi = function () {
  alert('Hello');
};

let sayHi2 = function foo() {
  alert('Hello');
};

let fibo = function fibo(n) {
  if (n == 1 || n == 2) return 1;
  return n + fibo(n - 1);
};

// 어캐됨?? 호이스팅 그건가?
let fibo2 = function (n) {
  if (n == 1 || n == 2) return 1;
  return n + fibo2(n - 1);
};

let foo = (n) => n && (console.log(n), bar(n - 1));
let bar = (n) => n && (console.log(n), foo(n - 1));

console.log(fibo2(10));
foo(10);
```

```js
function sayHi() {
  alert('Hello');
}

alert(sayHi); // shows the function code
// node에서는 안보여주던디...
```

Function expression have a semicolon at the end;

A function is a value representing an “action” Regular values like strings or numbers represent the data. A function can be perceived as an action.

**A Function Expression is created when the execution reaches it and is usable only from that moment.**

**A Function Declaration can be called earlier than it is defined.**

```js
sayHi('John'); // Hello, John
sayHi2('John'); // ReferenceError: Cannot access 'sayHi2' before initialization

function sayHi(name) {
  console.log(`Hello, ${name}`);
}

let sayHi2 = function (name) {
  alert(`Hello, ${name}`);
};
```

**In strict mode, when a Function Declaration is within a code block, it’s visible everywhere inside that block. But not outside of it.**

## Code quality

브라우저에서 breakppoint를 설정할 수 있다. Right click on the line number allows to create a conditional breakpoint.

We can also pause the code by using the debugger command in it, like this:

```js
console.log(1);
debugger;
console.log(2);

// 노드에서는 안되나?
```

... so the easiest way to activate the debugger (after we’ve set the breakpoints) is to reload the page.

Call stack이나 scope variables도 볼 수 있다.

If we compare them, the “Step” command goes into a nested function call and pauses the execution at its first line, while “Step over” executes the nested function call invisibly to us, skipping the function internals. That’s good if we’re not interested to see what happens inside the function call.

For the future, just note that “Step” command ignores async actions, such as setTimeout (scheduled function call), that execute later. The “Step into” goes into their code, waiting for them if necessary.

“Step out”: continue the execution till the end of the current function.

enable/disable automatic pause in case of an error - 못찾겠음!!

Right click on a line of code opens the context menu with a great option called “Continue to here”.

**Don’t forget about the right click and context menus!**

스타일 관련은,,, 그냥 prettier 쓰자,,

UML 공부해보자.

JSDoc:

```js
/**
 * Returns x raised to the n-th power.
 *
 * @param {number} x The number to raise.
 * @param {number} n The power, must be a natural number.
 * @return {number} x raised to the n-th power.
 */
function pow(x, n) {
  ...
}
```

Also, there are tools like JSDoc 3 that can generate HTML-documentation from the comments.

The flow of BDD(Behavior Driven Development) usually looks like this:

1. An initial spec is written, with tests for the most basic functionality.
1. An initial implementation is created.
1. To check whether it works, we run the testing framework Mocha (more details soon) that runs the spec. While the functionality is not complete, errors are displayed. We make corrections until everything works.
1. Now we have a working initial implementation with tests.
1. We add more use cases to the spec, probably not yet supported by the implementations. Tests start to fail.
1. Go to 3, update the implementation till tests give no errors.
1. Repeat steps 3-6 till the functionality is ready.

So, the development is iterative.

A transpiler is a special piece of software that translates source code to another source code. Babel is one of the most prominent transpilers out there.

A script that updates/adds new functions is called “polyfill”. As we’re talking about new functions, not syntax changes.

[https://stackoverflow.com/questions/31205640/what-is-the-difference-between-polyfill-and-transpiler](https://stackoverflow.com/questions/31205640/what-is-the-difference-between-polyfill-and-transpiler)

## Objects: the basics

An empty object can be created using one of two syntaxes.

```js
let user = new Object(); // "object constructor" syntax
let user = {}; // "object literal" syntax
```

Computed properties.

```js
let fruit = prompt('Which fruit to buy?', 'apple');

let bag = {
  [fruit]: 5,
};
```

In short, there are no limitations on property names. They can be any strings or symbols. Other types are automatically converted to strings.

```js
const obj = {
  [[1, 2] + [3, 4]]: 1,
};

console.log(Object.keys(obj));
```

There’s a minor gotcha with a special property named **proto**. We can’t set it to a non-object value. The assignment to a primitive is ignored.

Why does the in operator exist? Isn’t it enough to compare against undefined?

```js
let obj = {
  test: undefined,
};

alert(obj.test); // it's undefined, so - no such property?

alert('test' in obj); // true, the property does exist!
```

Situations like this happen very rarely, because undefined should not be explicitly assigned. We mostly use null for “unknown” or “empty” values.

```js
for (key in object) {
  // executes the body for each key among object properties
}
```

Integer properties are sorted, others appear in creation order.

When an object variable is copied, the reference is copied, but the object itself is not duplicated.

Const objects can be modified. 상수 포인터랑 비슷한듯? If we really need to make constant object properties, it’s also possible, but using totally different methods. We’ll mention that in the chapter Property flags and descriptors.

```js
let dest = {};
let obj1 = { a: 1 };
let obj2 = { a: 2, b: 3 };

console.log(Object.assign(dest, obj1, obj2));
console.log(Object.assign(dest, obj2, obj1));
```

```js
let user = {
  name: 'John',
  sizes: {
    height: 182,
    width: 50,
  },
};

let clone1 = { ...user };
let clone2 = Object.assign(clone1);
let clone3 = structuredClone(user);

console.log(user.sizes === clone1.sizes);
console.log(user.sizes === clone2.sizes);
console.log(user.sizes === clone3.sizes);

// files when an object has a function property.
// use _.cloneDeep(obj)
```

The basic garbage collection algorithm is called “mark-and-sweep”.

설명은 길었는데 그냥 참조 화살표로 구성된 그래프 순회하고 순회 안된애들 지우는 느낌.

Some of the optimizations:

- Generational collection – objects are split into two sets: “new ones” and “old ones”. In typical code, many objects have a short life span: they appear, do their job and die fast, so it makes sense to track new objects and clear the memory from them if that’s the case. Those that survive for long enough, become “old” and are examined less often.
- Incremental collection – if there are many objects, and we try to walk and mark the whole object set at once, it may take some time and introduce visible delays in the execution. So the engine splits the whole set of existing objects into multiple parts. And then clear these parts one after another. There are many small garbage collections instead of a total one. That requires some extra bookkeeping between them to track changes, but we get many tiny delays instead of a big one.
- Idle-time collection – the garbage collector tries to run only while the CPU is idle, to reduce the possible effect on the execution.

Being referenced is not the same as being reachable.

GC 관련 글 모음 게시물 하단에 있음. 나중에 읽어보면 좋을 듯?

“Design Patterns: Elements of Reusable Object-Oriented Software” by E. Gamma, R. Helm, R. Johnson, J. Vissides or “Object-Oriented Analysis and Design with Applications” by G. Booch.

```js
user = {
  sayHi: function () {
    alert('Hello');
  },
};

user = {
  sayHi() {
    alert('Hello');
  },
};

// There are subtle differences related to object inheritance
```

It’s common that an object method needs to access the information stored in the object to do its job. To access the object, a method can use the this keyword.

'this' can be used in any function, even if it’s not a method of an object.

!@thisIsNotBound.js!@

Calling this without an object. In non-strict mode the value of this in such case will be the global object. This is a historical behavior that "use strict" fixes. Usually such call is a programming error. If there’s this inside a function, it expects to be called in an object context. 근데 브라우저에서 use strict 해도 안바뀌는 것 같기도? 귀찮아서 자세히는 안봄.

In JavaScript this is “free”, its value is evaluated at call-time and does not depend on where the method was declared, but rather on what object is “before the dot”.

The concept of run-time evaluated this has both pluses and minuses. On the one hand, a function can be reused for different objects. On the other hand, the greater flexibility creates more possibilities for mistakes.

Arrow functions are special: they don’t have their “own” this. If we reference this from such a function, it’s taken from the outer “normal” function.

```js
let user = {
  firstName: 'Ilya',
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  },
};

user.sayHi(); // Ilya
```

```js
function makeUser() {
  return {
    name: 'John',
    ref: this,
  };
}

let user = makeUser();

alert(user.ref.name); // What's the result?
```

```js
function makeUser() {
  return {
    name: 'John',
    ref() {
      return this;
    },
  };
}

let user = makeUser();

alert(user.ref().name); // John
```

The regular {...} syntax allows us to create one object. But often we need to create many similar objects, like multiple users or menu items and so on. That can be done using constructor functions and the "new" operator. A new empty object is created and assigned to `this`.

```js
// create a function and immediately call it with new
let user = new (function () {
  this.name = 'John';
  this.isAdmin = false;

  // ...other code for user creation
  // maybe complex logic and statements
  // local variables etc
})();
// This trick aims to encapsulate the code that constructs the single object, without future reuse.
```

new.target으로 constructor mode인지 알 수 있다.

The optional chaining ?. stops the evaluation if the value before ?. is undefined or null and returns undefined.

- obj?.prop – returns obj.prop if obj exists, otherwise undefined.
- obj?.[prop] – returns obj[prop] if obj exists, otherwise undefined.
- obj.method?.() – calls obj.method() if obj.method exists, otherwise returns undefined.

By specification, only two primitive types may serve as object property keys:

- string type, or
- symbol type.

To summarize, a symbol is a “primitive unique value” with an optional description. Symbols allow us to create “hidden” properties of an object, that no other part of code can accidentally access or overwrite.

## Data types

## Advanced working with functions

## Object properties configuration

## Prototypes, inheritance

## Classes

## Error handling

## Promises, async/await

## Generators, advanced iteration

## Modules

## Miscellaneous

## PART 3: Additional articles
