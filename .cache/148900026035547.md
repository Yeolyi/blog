---
title: 4190.308 Computer Architecture
---

Spring 2023

일단 reading assignment에 명시된 챕터만 읽어본다.

교재는 Computer Organization and Design RISC-V Edition: The Hardware/Software Interface” (COD) David A. Patterson, John L. Hennessy 2nd edition, Morgan Kaufmann, 2020 ISBN-13: 978-0-12-820331-6

```txt
Makefile 참고

CC=/opt/riscv/bin/riscv64-unknown-elf-gcc
ABI=lp64d
ARCH=rv64g
CFLAGS=-mabi=$(ABI) -march=$(ARCH) -O1 -S

riscv64-unknown-elf-gcc -mabi=lp64d -march=rv64g -O1 -S
```

XOR이 SUB 보다 동등성 검사를 빠르고 적은 전력으로 할 수도 있다.

Design Principle 1: Simplicity favors regularity.

Design Principle 2: Smaller is faster.

Design Principle 3: Good design demands good compromises.

## Course Organization

Computer architecture is a **specification detailing how a set of software and hardware technology standards interact to form a computer system or platform**. In short, computer architecture refers to how a computer system is designed and what technologies it is compatible with.

컴퓨터가 어떻게 control되고 build되는지를 배운다.

Computer Science is all about Abstractions.

Modern Computer Architecture is about managing and optimizing across several levels of abstraction w.r.t. dramatically changing technology and application load

## 1. Computer Abstractions and Technology

1-8, 11-12

> Civilization advances by extending the number of important operations which we can perform without thinking about them.

### 1. Introduction

> Had the transportation industry kept pace with the computer industry, for example, today we could travel from New York to London in a second for a penny.

**terabyte (TB)** Originally 1,099,511,627,776 (2^40) bytes, although communications and secondary storage systems developers started using the term to mean 1,000,000,000,000 (10^12) bytes. To reduce confusion, we now use the term tebibyte (TiB) for 2^40 bytes, defining terabyte (TB) to mean 10^12 bytes.

In consumer-oriented embedded applications, such as a digital home appliance, **dependability** is achieved primarily through simplicity— the emphasis is on doing one function as perfectly as possible. In large embedded systems, techniques of redundancy from the server world are often employed.

40년 전에 PC의 시대가 온 것처럼 최근에는 PMD(personal mobile device)로 바뀌고 있다. 마찬가지로 conventional server에서 cloud computing으로 바뀌고 있다. Today’s software developers will often have a portion of their application that runs on the PMD and a portion that runs in the Cloud. Today’s software developers will often have a portion of their application that runs on the PMD and a portion that runs in the Cloud.

Programmers interested in performance now need to understand the issues that have replaced the simple memory model of the 1960s: the parallel nature of processors and the hierarchical nature of memories. ... Moreover, as we explain in Section 1.7, today’s programmers need to worry about energy efficiency of their programs running either on the PMD or in the Cloud, which also requires understanding what is below your code.

This table summarizes how the hardware and software affect performance.

- Algorithm: Determines both the number of source-level statements and the number of I/O operations executed
- Programming language, compiler, and architecture: Determines the number of computer instructions for each source-level statement
- Processor and memory system: Determines how fast instructions can be executed
- I/O system (hardware and operating system): Determines how fast I/O operations may be executed

### 2. Seven Great Ideas in Computer Architecture

- Use Abstraction to Simplify Design
- Make the Common Case Fast
- Performance via Parallelism
- Performance via Prediction
- Hierarchy of Memories
- Dependability via Redunduncy

### 3. Below Your Program

Hardware > Systems software(**os, compiler**) > Application software

명령어와 데이터 모두를 수로 표현하는 것은 컴퓨팅의 기초이다.

> **assembler**: A program that translates a symbolic version of instructions into the binary version.

> **assembly language**: A symbolic representation of machine instructions.

> **high-level programming language**: A portable language such as C, C++, Java, or Visual Basic that is composed of words and algebric notation that can be translated by a compier into assembly language.

!@swap.c@!

!swap.s@!

프로그래밍 언어는 개발중인 컴퓨터에 독립적인 프로그램을 만들 수 있게 해준다. 컴파일러와 어셈블러가 임의의 컴퓨터를 위한 이진 명령어로 번역할 수 있기 때문이다.

### 4. Under the Covers

소프트웨어를 살펴봤고 이제 하드웨어를 살펴보자.

모든 컴퓨터의 기반 하드웨어에는 inputting data, outputting data, processing data, storing data의 기본 기능을 수행한다.

책에서 Big Picture는 중요하다!

**The BIG Picture**: The five classic components of a computer are input, output, memory, datapath, and control, with the last two sometimes combined and called the processor

The image is composed of a matrix of picture elements, or pixels, which can be presented as a matrix of bits, called a **bit map**. ... The computer hardware support for graphics consists mainly of a **raster refresh buffer**, or **frame buffer**, to store the bit map.

> **integrated circuit**: Also called a **chip**. A device combining dozens to millions of transistors.

> **central processor unit (CPU)**: Also called processor. The active part of the computer, which contains the datapath and control and which adds numbers, tests numbers, signals I/O devices to activate, and so on.

프로세서는 datapath와 control로 구성된다. 각각 근육과 뇌에 비유됨. 전자는 산술 연산을 수행하고, 후자는 명령어를 따라 datapath, memory, I/O device에 지시한다.

RAM은 메모리의 부분에 상관없이 읽는데 같은 시간이 소요된다.

> **instruction set architecture**(Also called architecture): An abstract interface between the hardware and the lowest-level software that encompasses all the information necessary to write a machine language program that will run correctly, including instructions, registers, memory access, I/O, and so on.

> **application binary interface (ABI)**: The user portion of the instruction set plus the operating system interfaces used by application programmers. It defines a standard for binary portability across computers.

**The BIG Picture**: Both hardware and software consist of hierarchical layers using abstraction, with each lower layer hiding details from the level above. One key interface between the levels of abstraction is the instruction set architecture—the interface between the hardware and low-level software. This abstract interface enables many implementations of varying cost and performance to run identical software.

휘발성 메모리 - 메인 메모리 혹은 1차 메모리. 비휘발성 메모리 - 2차 메모리. 사이즈와 form factor 때문에 PMD에서는 플래시 메모리를 사용. 근데 플래시 메모리는 점차 wear out됨. 플래시 메모리는 비휘발성.

> **local area network (LAN)**: A network designed to carry data within a geographically confined area, typically within a single building. 이더넷이 LAN의 일종인듯?

네트워크쪽 노잼,,

Check Yourself: DRAM만 volatile. 속도와 가격은 DRAM > flash memory > disk storage. DRAM memory: volatile, short access time of 50 to 70 nanoseconds, and cost per GB is $5 to $10. Disk memory: nonvolatile, access times are 100,000 to 400,000 times slower than DRAM, and cost per GB is 100 times cheaper than DRAM. Flash memory: nonvolatile, access times are 100 to 1000 times slower than DRAM, and cost per GB is 7 to 10 times cheaper than DRAM.

### 5. Technologies for Building Processors and Memory

트랜지스터는 전기적 신호에 의해 조절되는 온오프 스위치. IC(integrated circuit)에는 수백개의 트랜지스터가 있다. VLSI는 conductor + insulator + switch들을 실리콘에 배치한 것이다.

Silicon crystal ingot -> blank wafer -> patterened wafer -> tested wafer -> tested dies -> packaged dies -> tested packaged dies.

The simplest way to cope with imperfection is to place many independent components on a single wafer. The patterned wafer is then chopped up, or diced, into these components, called dies and more informally known as chips. Dicing 덕분에 wafer 전체가 아닌 결함이 있는 부분만 버릴 수 있다.

> **yield**: The percentage of good dies from the total number of dies on the wafer.

The cost of an integrated circuit rises quickly as the die size increases, due both to the lower yield and to the fewer dies that fit on a wafer. To reduce the cost, using the next generation process shrinks a large die as it uses smaller sizes for both transistors and wires. This improves the yield and the die count per wafer. A 7-nanometer (nm) process was state-of-the-art in 2020, which means essentially that the smallest feature size on the die is 7 nm.

This die uses a 10-nanometer technology, which means that the smallest features are approximately 10 nm in size, although they are typically somewhat smaller than the actual feature size, which refers to the size of the transistors as “drawn” versus the final manufactured size.

Cost per die = Cost per wafer / (Dies per wafer \* yield)

Dies per wafer = Wafer area / Die area

Yield = 1 / (1 + Defects per area \* Die area)^N

N은 number of critical processing step. defect rate, size of the die and wafer로 결정되는 cost는 die area에 linear에 하지 않다.

**Check Yourself**: 2, 4??? 1, 3, and 4 are valid reasons. Answer 5 can be generally true because high volume can make the extra investment to reduce die size by, say, 10% a good economic decision, but it doesn't have to be true. 아 volume이 생산량 느낌인건가? 규모의 경제?

### 6. Performance

> **response time(execution time)**: The total time required for the computer to complete a task, including disk accesses, memory accessed, I/O activites, operating system overhead, CPU execution time, and so on.

> **throughput(bandwidth)**: Another measure of performance, it is the number of tasks completed per unit time.

response time은 일반 PC 사용자, throughput은 데이터센터에서 신경쓸 듯한 지표이다.

대부분의 경우 response time이 줄면 throughput이 증가한다. 역은 애매하지만 만약 작업이 queue up될정도로 많으면 waiting time in queue를 줄이기에 역도 성립한다.

Performance = 1 / Execution time

> **wall clock time, response time, elapsed time**: Total time to complete a task, including disk accesses, memory accesses, I/O activities, os overhead etc.

하지만 프로세서는 여러 프로그램을 동시에 처리하고 있을수도 있다. 이 경우 시스템은 한 프로그램의 elapsed time을 줄이기보다 throughput을 최적화하려한다.

> 이러한 맥락에서 **CPU execution time** 혹은 **CPU time**은 CPU가 작업을 처리하는데 필요한 시간이며 I/O나 다른 프로그램을 기다리는 시간이 포함되어있지 않다. CPU time은 CPU가 프로그램 자체에 소요한 시간인 **user CPU time**과 OS가 프로그램을 위한 작업을 수행하는 시간인 **system CPU time**으로 나뉜다.

We will use the term system performance to refer to elapsed time on an unloaded system and CPU performance to refer to user CPU time.

> **clock cycle**(tick, clock tick, clock period, clock, cycle): The time for one clock period, usually of the processor clock, which runs at a constant rate.

> **clock rate**: Inverse of the clock period.

CPU time = CPU cycle for program \* Clock cycle time

CPU time = CPU cycle for program / Clock rate

위 식은 instruction의 개수를 포함하지 않지만 얘도 포함되는게 자연스럽다.

CPU clock cycle = Instructions for a program \* Average clock cycles per instruction

> **clock cycles per instruction(CPI)**: Average number of clock cycles per instruction for a program or program fragment.

CPI provides one way of comparing two different implementations of the identical instruction set architecture, since the number of instructions executed for a program will, of course, be the same.

**The BIG Picture**: (CPU) Time = Seconds/Program = Instructions/Program \* Clock cycles/Instruction(CPI) \* Seconds/Clock cycle(cloc cycle time) 성능에 대한 온전한 지표는 시간뿐이다. 곱셈에 있는 항 하나를 빼서 그것으로 판별할 수는 없음.

Since the instruction count depends on the architecture, but not on the exact implementation, we can measure the instruction count without knowing all the details of the implementation. The CPI, however, depends on a wide variety of design details in the computer.

> **instruction mix**: A measure of the dynamic frequency of instructions across one or many programs.

CPI는 instruction mix에 따라 달라질 수 있기에 instruction count와 CPI 모두 비교되어야한다?

- Algorithm. Instruction count와 CPI에 영향을 준다. The algorithm determines the number of source program instructions executed and hence the number of processor instructions executed. The algorithm may also affect the CPI, by favoring slower or faster instructions. For example, if the algorithm uses more divides, it will tend to have a higher CPI.
- Programming language. Instruction count와 CPI에 영향을 준다. The programming language certainly affects the instruction count, since statements in the language are translated to processor instructions, which determine instruction count. The language may also affect the CPI because of its features; for example, a language with heavy support for data abstraction (e.g., Java) will require indirect calls, which will use higher CPI instructions.
- Compiler. Instruction count와 CPI에 영향을 준다. The efficiency of the compiler affects both the instruction count and average cycles per instruction, since the compiler determines the translation of the source language instructions into computer instructions. The compiler’s role can be very complex and affect the CPI in varied ways.
- Instruction set architecture. Instruction count, clock rate, CPI에 영향을 준다. The instruction set architecture affects all three aspects of CPU performance, since it affects the instructions needed for a function, the cost in cycles of each instruction, and the overall clock rate of the processor.

**Check Yourself**: 1.a 둘 다, 1.b response time, 1.c **neither**. 2. 7.

**Check Yourself**: 15\*0.6\*1.1=9.9

### 7. The Power Wall

The reason for power and clock rate's recent slowing is that we have run into the practical power limit for cooling commodity microprocessors.

Just as measuring time in seconds is a safer evaluation of program performance than a rate like MIPS (see Section 1.10), the energy metric joules is a better measure than a power rate like watts, which is just joules/second. 실행 시간이 포함되어서 그런가?

CMOS에서 에너지 소비는 주로 dynamic energy에서 일어난다. 트랜지스터의 상태(0, 1)가 바뀔 때 소비되는 에너지. The dynamic energy depends on the capacitive loading of each transistor and the voltage applied: Energy ∝ Capacitive load \* Voltage^2. 얘는 0->1->0에서의 에너지. The energy of a single transition is then Energy ∝ 1/2 \* Capacitive load \* Voltage^2.

The power required per transistor is just the product of energy of a transition and the frequency of transitions: Power ∝ 1/2 \* Capacitive load \* Voltage^2 \* Frequency switched.

Frequency switched is a function of the clock rate. The capacitive load per transistor is a function of both the number of transistors connected to an output (called the fanout) and the technology, which determines the capacitance of both wires and transistors.

With regard to Figure 1.16, how could clock rates grow by a factor of 1000 while power increased by only a factor of 30? Energy and thus power can be reduced by lowering the voltage, which occurred with each new generation of technology, and power is a function of the voltage squared. Typically, the voltage was reduced about 15% per generation. In 20 years, voltages have gone from 5 V to 1 V, which is why the increase in power is only 30 times.

The modern problem is that further lowering of the voltage appears to make the transistors too leaky, like water faucets that cannot be completely shut off. 40% 전력 소비가 이거 때문.

Although dynamic energy is the primary source of energy consumption in CMOS, static energy consumption occurs because of leakage current that flows even when a transistor is off.

Power is a challenge for integrated circuits for two reasons. First, power must be brought in and distributed around the chip; ...Second, power is dissipated as heat and must be removed.

Power wall에 부딪히면서 다른 방법이 필요하게 되었다.

### 8. The Sea Change: The Switch from Uniprocessors to Multiprocessors

Response time을 줄이기보단 throuput을 줄이는데 좋은 microprocessors with multiple processors per chip에 집중하게 되었다. 참고로 회사들은 processor를 core로, 이러한 microsessor들을 multicore microprocessor라 부른다. 마이크로한거 안에 그냥 프로세서가 있는게 웃기네,,

이제 이러한 마이크로프로세서들의 성능을 뽑아먹으려면 프로그래머들도 멀티프로세서를 이해해야한다.

예전에 프로그래머들에게 parallel hardware를 이해하고 프로그램 다시 짜라고 했을때는 실패했는데, it’s startling that the whole IT industry bet its future that programmers will successfully switch to explicitly parallel programming.

Parallel programming에서 comminication and synchronization overhead를 줄이는 것이 중요하다.

Appendix B describes an increasingly popular hardware component that is included with desktop computers, the graphics processing unit (GPU). Invented to accelerate graphics, GPUs are becoming programming platforms in their own right. As you might expect, given these times, GPUs rely on parallelism.

### 11. Fallacies and Pitfalls

> Science must begin with myths, and the criticism of myths. _Sir Karl Popper, The Philosophy of Science, 1957_

fallacies: commonly held misconceptions, pitfalls: easily made mistakes. 뭐가 다른거지,,

**Pitfall: Expecting the improvement of one aspect of a computer to increase overall performance by an amount proportional to the size of the improvement.**

> **Amdahl's Law**: Performance enhancement possible with a given improvement is limited by the amount that the improved feature is used.

수확 체감의 법칙?의 quantatitive 버전이다.

Execution time after improvement = Execution time affected by improvement / Amount of improvement + Execution time unaffected

**Fallacy: Computers at low utilization use little power.**

구글 warehouse scale computer도 대부분의 시간을 10%-50%에서 보낸다. 로드가 10%여도 peak power의 33%나 쓴다. low utilization이라고 little power는 아닌듯?

**Fallacy: Designing for performance and designing for energy efficiency are unrelated goals.**

최적화 과정에서 에너지를 조금 더 먹더라도 실행 시간이 줄어들면 소모 에너지도 줄 수 있다.

**Pitfall: Using a subset of the performance equation as a performance metric.**

MIPS는 capabilities of the instructions을 반영하지 않는다. 또한 같은 컴퓨터더라도 프로그램에 따라 달라질 수 있다. 또한 다른 프로그램이 더 많은 명령어를 실행해도 각 명령어가 더 빠르면 MIPS는 성능과 무관하게 달라질 수 있다.

MIPS = Instruction count / Execution time / 10^6

= Clock rate / CPI / 10^6

**Check Yourself**: A - 4\*10^9 / 10^6 = 4000, B - 3636. A - 2500, B - 2200?

### 12. Concluding Remarks

Perhaps the most important example of abstraction is the interface between hardware and low-level software, called the instruction set architecture.

ISA를 유지시켜 같은 소프트웨어를 여러 곳에서 돌릴 수 있지만 유연하게 혁신을 도입하기 힘들다.

**The BIG Picture**: Execution time is the only valid and unimpeachable measure of performance. Many other metrics have been proposed and found wanting. Sometimes these metrics are flawed from the start by not reflecting execution time; other times a metric that is sound in a limited context is extended and used beyond that context or without the additional clarification needed to make it valid.

Energy efficiency has replaced die area as the most critical resource of microprocessor design.

## 2. Instructions: Language of the Computer

1-9

### 1. Introduction

> **instruction set**: The vocabulary of commands understood by a given architecture.

Instruction set은 하드웨어를 쉽게 구현할 수 있는 동시에 성능, 가격, 에너지를 최적화해야한다.

> It is easy to see by formal-logical methods that there exist certain [instruction sets] that are in abstract adequate to control and cause the execution of any sequence of operations.... The really decisive considerations from the present point of view, in selecting an [instruction set], are more of a practical nature: simplicity of the equipment demanded by the [instruction set], and the clarity of its application to the actually important problems together with the speed of its handling of those problems.
>
> Burks, Goldstine, and von Neumann, 1946

> **stored-program concept**: The idea that instruction and data of many types can be stored in memory as **numbers** and thus be **easy to change**, leading to the stored-program computer.

### 2. Operations of the Computer Hardware

> There must certainly be instructions for performing the fundamental arithmetic operations.
>
> Burks, Goldstine, and von Neumann, 1946

RISC-V의 산술 명령어는 하나의 연산만 하며 정확히 세 개의 변수를 가지고 있어야한다.

한 줄에 명령어가 최대 한개씩이고 주석은 항상 줄의 끝에서 끝난다.

RISC-V의 operand에는 32 register와 2^30 memory words가 있다. Byte addressing을 쓰기에 인접한 word는 4씩 차이난다.

load word, halfword, byte가 있다. 각각 unsigned 버전도 있다. store는 unsigned 버전 없다.

> **What is lr.d and sc.d in RISC-V?**
>
> In RISC-V, "lr.d" and "sc.d" are instructions used for performing atomic memory operations on double-precision floating-point values.
>
> "lr.d" stands for "load reserved double-precision", and it is used to load a double-precision floating-point value from memory while reserving the memory location for exclusive use by the executing processor. This instruction ensures that no other processor can access the memory location until the executing processor completes its atomic operation.
>
> "sc.d" stands for "store conditional double-precision", and it is used to store a double-precision floating-point value to memory only if the memory location has not been modified by another processor since it was reserved by the executing processor using "lr.d". If the memory location has been modified by another processor, the "sc.d" instruction fails and the value is not stored.
>
> Together, "lr.d" and "sc.d" provide a way to perform atomic read-modify-write operations on double-precision floating-point values in shared memory, which is important for synchronization between multiple processors in a multi-core system.

lui는 20비트.

Conditional branch와 jal 모두 PC-relative. **현재 PC값**에 더한다. jalr은 indirect call, PC값이 레지스터값으로 치환된다.

To increase portability, Java was originally envisioned as relying on a software interpreter. The instruction set of this interpreter is called **Java bytecodes** (see Section 2.15), which is quite different from the RISC-V instruction set. To get performance close to the equivalent C program, Java systems today typically compile Java bytecodes into the native instruction sets like RISC-V. Because this compilation is normally done much later than for C programs, such Java compilers are often called **Just In Time (JIT) compilers**. Section 2.12 shows how JITs are used later than C compilers in the start-up process, and Section 2.13 shows the performance consequences of compiling versus interpreting Java programs. 나중에 읽어보자,,,

**Check Yourself**: RISC-V > C > Java

### 3. Operands of the Computer Hardware

고급 프로그래밍 언어와 다르게 산술 연산의 피연산자는 반드시 레지스터여야한다.

RISC-V에서 레지스터의 크기는 32비트이다.

> Does RISC-V support memory bigger than 2^32?
>
> Yes, RISC-V supports memory larger than 2^32 (4 GB). The RISC-V instruction set architecture is designed to be scalable and extensible, which means it can be implemented in systems with a wide range of memory sizes.
>
> The RISC-V specification defines a 64-bit instruction set architecture (ISA), called RV64, which supports 64-bit virtual addresses and can address up to 2^64 bytes of memory (16 exabytes). The RV64 ISA is intended for use in systems with large amounts of memory, such as servers, supercomputers, and embedded systems with high-performance requirements.
>
> In addition to RV64, RISC-V also defines 32-bit and 128-bit ISAs, called RV32 and RV128, respectively. The RV32 ISA supports 32-bit virtual addresses and can address up to 2^32 bytes of memory, while the RV128 ISA supports 128-bit virtual addresses and can address up to 2^128 bytes of memory.
>
> It's worth noting that the size of physical memory that can be addressed by a RISC-V processor is determined by the implementation of the processor, rather than the RISC-V ISA itself. The maximum memory size that can be accessed by a particular RISC-V implementation depends on the number of address lines and memory controllers in the implementation.

> Then what is the register size of RV64?
>
> The register size of RV64 is 64 bits. In the RISC-V ISA, registers are the fundamental units of data storage, and they are used to hold operands, intermediate results, and addresses for memory operations.
>
> The RV64 ISA defines 32 integer registers, each of which is 64 bits wide. These registers are identified by integer numbers ranging from 0 to 31. In addition to integer registers, RV64 also defines 32 floating-point registers, each of which is also 64 bits wide. These floating-point registers are identified by names starting with "f" followed by a number from 0 to 31.
>
> The 64-bit register size of RV64 provides several advantages over 32-bit architectures, such as larger address space, improved performance for applications that require 64-bit precision, and better support for high-performance computing applications that require large amounts of memory.

32비트가 워낙 자주 나와 word라고 한다. 64비트는 doubleword라고 한다.

> **word**: A natural unit of access in a computer, usually a group of 32bits; corresponds to the size of a register in the RISC-V architecture.

> **data transfer instruction**: A command that moves data between memory and registers.

```txt
lw x9, 8(x22) // Temporary reg x9 gets A[8]

```

The register added to form the address (x22) is called the **base register**, ane the constant in a data transfer instruction (8) is called the **offset**.

RISC-V는 little endian.

> **alignment restriction**: A requirement that data be aligned in memory on natural boundaries. RISC-V/x86에는 없고 MIPS에는 있다.

As the addresses in loads and stores are binary numbers, we can see why the DRAM for main memory comes in binary sizes rather than in decimal sizes. That is, in gibibytes (2^30) or tebibytes (2^40), not in gigabytes (10^9) or terabytes (10^12).

Computers divide into those that use the address of the leftmost or “big end” byte as the word address versus those that use the rightmost or “little end” byte. 표현이 뭔가 헷갈림. 주소는 그대로인 것 같다.

> The process of putting less frequently used variables (or those needed later) into memory is called **spilling registers**.

A RISC-V data transfer instruction only reads one operand or writes one operand, without operating on it.

In fact, more than half of the RISC-V arithmetic instructions have a constant as an operand when running the SPEC CPU2006 benchmarks. Constant operands occur frequently; indeed, **addi** is the most popular instruction in most RISC-V programs.

The constant zero has another role, which is to simplify the instruction set by offering useful variations. For example, you can negate the value in a register by using the sub instruction with zero for the first operand. Hence, RISC-V dedicates register x0 to be hard-wired to the value zero. Using frequency to justify the inclusions of constants is another example of the great idea from Chapter 1 of **making the common case fast**.

Although the RISC-V registers in this book are 32 bits wide, the RISC-V architects conceived multiple variants of the ISA. In addition to this variant, known as RV32, a variant named RV64 has 64-bit registers, whose larger addresses make RV64 better suited to processors for servers and smart phones.

The register in the data transfer instructions was originally invented to hold an index of an array with the offset used for the starting address of an array. Thus, the base register is also called the **index register**. Today’s memories are much larger, and the software model of data allocation is more sophisticated, so the base address of the array is normally passed in a register since it won’t fit in the offset, as we shall see.

!@longli.c@!

!@longli.s@!

The migration from 32-bit address computers to 64-bit address computers left compiler writers a choice of the size of data types in C. Clearly, pointers should be 64 bits, but what about integers? Moreover, C has the data types int, long int, and long long int. The problems come from converting from one data type to another and having an unexpected overflow in C code that is not fully standard compliant, which unfortunately is not rare code. The table below shows the two popular options:

windows - pointer 64, int 32, long int 32, long long int 64

linux, most unix - pointer 64, int 32, long int 64, long long int 64

**Check Yourself**: 2

### 4. Signed and Unsigned Numbers

Since words are drawn vertically as well as horizontally, leftmost and rightmost may be unclear. Hence, the phrase least significant bit is used to refer to the rightmost bit and most significant bit to the leftmost bit.

> **overflow**: when the result of an operation are larger than be represented in a register.

sign and magnitude 방식은 sign bit의 위치가 애매하고, adder에서 추가적인 단계가 필요하며, +0과 -0이 모두 존재한다.

Two’s complement does have one negative number that has no corresponding positive number: -2,147,483,648ten. 모든 음수의 MSB(sign bit)가 1이라는 장점이 있다.

Overflow occurs when the leftmost retained bit of the binary bit pattern is not the same as the infinite number of digits to the left (the sign bit is incorrect).

The function of a signed load is to copy the sign repeatedly to fill the rest of the register—called sign extension—but its purpose is to place a correct representation of the number within that register. Unsigned loads simply fill with 0s to the left of the data, since the number represented by the bit pattern is unsigned. Word를 load할 때는 의미 없다. C에서는 바이트를 very short signed integer보다는 char에서나 쓰니 대부분 lb가 아닌 lbu가 사용된다.

Two’s complement gets its name from the rule that the unsigned sum of an n-bit number and its n-bit negative is 2^n; hence, the negation or complement of a number x is 2n − x, or its “two’s complement.”

one's complement는 비트 반전만 시켜서 음수를 얻는다. 0이 두개고 adder에서 1을 빼주는 추가적인 스텝이 필요하다. 부동 소수점에서 언급될 biased notation도 있다. bias를 더하면 non-negative notation이 된다.

**Check Yourself**: 2, 4

### 5. Representing Instructions in the Computer

> **instruction format**: A form of representation of an instruction composed of fields of binary numbers.

> **machine language**: Binary representation used for communication within a computer system.

RISC-V의 필드는 아래와 같이 구성된다.

R-type: funct7(7bits), rs2(5bits), rs1(5bits), funct3(3bits), rd(5bits), opcode(7bits)

> **opcode**: The field that denotes the **operation** and **format** of and instruction.

I-type: immediate(12bits), rs1(5bits), funct3(3bits), rd(5bits), opcode(7bits)

S-type: immdiate\[11:5](7bits), rs2(5bits), rs1(5bits), funct3(3bits), immediate\[4:0](5bits), opcode(7bits)

```txt
sw x9, 120(x10)
-> rs2가 9, rs1이 10
```

이런 기묘한 형태덕분에 rs1과 rs2가 항상 같은 위치에 있을 수 있다. opcode와 func3은 같은 크기 같은 위치에 있다. **포맷의 종류는 opcode field를 통해 결정된다**.

RISC-V assembly language programmers aren’t forced to use addi when working with constants. The programmer simply writes add, and the assembler generates the proper opcode and the proper instruction format depending on whether the operands are all registers (R-type) or if one is a constant (I-type).

add와 sub는 있지만 subi는 없다.

**The BIG Picture**: Instructions are represented as numbers + Programs are stored in memory to be read or written, just like data -> stored-prograrm concept. One consequence of instructions as numbers is that programs are often shipped as files of binary numbers. The commercial implication is that computers can inherit ready-made software provided they are compatible with an existing instruction set. Such “binary compatibility” often leads industry to align around a small number of instruction set architectures.

The memory technology needed for data can also be used for programs, and programs like compilers, for instance, can translate code written in a notation far more convenient for humans into code that the computer can understand.

**Check Yourself**: **3**, 0x32

### 6 Logical Operations

Logical operations were added to programming languages and instruction set architectures to simplify, among other things, the **packing and unpacking of bits into words**.

slli, srli. l이 무조건 붙네? srai.

시프트 명령어는 I-type format을 쓰지만 31을 넘어 시프트하는 것은 무의미하므로 5비트만 쓰고 나머지는 **funct7으로 재사용**된다.

func7(7bits) + immediate(4bits) + rs1(5bits) + func3(3bits) + rd(5bit) + opcode(7bits)

As you can see, AND can apply a bit pattern to a set of bits to force 0s where there is a 0 in the bit pattern. Such a bit pattern in conjunction with AND is traditionally called a **mask**, since the mask “conceals” some bits.

In keeping with the three-operand format, the designers of RISC-V decided to include the instruction XOR (exclusive OR) instead of NOT. Since exclusive OR creates a 0 when bits are the same and a 1 if they are different, the equivalent to NOT is an xor 111...111.

C allows **bit fields** or **fields** to be defined within words, both allowing objects to be packed within a word and to match an externally enforced interface such as an I/O device. All fields must fit within a single word. Fields are unsigned integers that can be as short as 1 bit. C compilers insert and extract fields using logical instructions in RISC-V: andi, ori, slli, and srli.

!@bitfield.c@!

!@bitfield.s@!

lbu와 sb가 포인트인듯.

[In case of bit fields, which one is better to use, unsigned char or unsigned int and why?](https://stackoverflow.com/questions/17670436/in-case-of-bit-fields-which-one-is-better-to-use-unsigned-char-or-unsigned-int)

**Check Yourself**: Both. Note that AND leaves the field where it was originally, and the shift pair moves the field into the rightmost part of the doubleword.

(The expression "A followed by B" is usually understood to mean that A happens first, followed by B. )

### 7. Instructions for Making Decisions

> **conditional branch**: An instruction that tests a value and that allows for a subsequent transfer of control to a new address in the program based on the outcome of the test.

In general, the code will be more efficient if we test for the opposite condition to branch over the code that branches if the values are not equal (bne)???

(See Self Study in Section 2.25 for an optimization of this sequence.) -> 나중에 살펴보기

Such sequences of instructions that end in a branch are so fundamental to compiling that they are given their own buzzword: a **basic block** is a sequence of instructions without branches, except possibly at the end, and without branch targets or branch labels, except possibly at the beginning. One of the first early phases of compilation is breaking the program into basic blocks.

beq, bne, blt, bge, bltu, bgeu.

Yet another alternative, used by ARM’s instruction sets, is to keep extra bits that record what occurred during an instruction. These additional bits, called **condition codes** or **flags**, indicate, for example, if the result of an arithmetic operation was negative, or zero, or resulted in overflow.

```txt
// Treating signed numbers as if they were unsigned gives us a low-cost way of checking if 0 ≤ x < y, which matches the index out-of-bounds check for arrays.

bgeu x20, x11, IndexOutOfBounds
// if x20 >= x11 or x20 < 0, goto IndexOutOfBounds
```

> **branch address table**: Also called branch table. A table of addresses of alternative instruction sequences.

Branch table을 통해 switch문을 효과적으로 구현할 수 있다. 이를 위해 RISC-V에서는 jalr같은 indirect jump 명령어를 지원한다. GPT한테 물어보는 중인데 slt라는 명령어도 있나?

```txt
switch:
    addi sp, sp, -4         # decrement stack pointer
    sw   ra, 0(sp)          # save return address on stack
    li   t1, 4              # load 4 into temporary register t1
    mul  s0, s0, t1         # multiply input value by 4 to get offset into table
    add  t0, s0, x10        # add offset to address of table (assuming table is at address x10)
    lw   t0, 0(t0)          # load address of target label from table into t0
    jalr ra, t0, 0          # jump to target label

    .align 2                # align table on 4-byte boundary
table:
    .word case_1            # entry 0: jump to case_1
    .word case_2            # entry 1: jump to case_2
    .word case_3            # entry 2: jump to case_3
    .word default           # entry 3: jump to default

case_1:
    # code for case 1
    j end_switch            # jump to end of switch statement

case_2:
    # code for case 2
    j end_switch            # jump to end of switch statement

case_3:
    # code for case 3
    j end_switch            # jump to end of switch statement

default:
    # code for default case
    j end_switch            # jump to end of switch statement

end_switch:
    lw ra, 0(sp)            # restore return address from stack
    addi sp, sp, 4          # increment stack pointer
    jr  ra
```

**Check Yourself**: I-1,2,3. II-3?. 뭐야 다틀림,,

!@andImpl.c@!

!@andImpl.s@!

### 8. Supporting Procedures in Computer Hardware

> **procedure**: A stored subroutine that performs a specific task based on the parameters with which it is provided.

함수 패러미터는 프로시저와 다른 프로그램 및 데이터 사이의 인터페이스 역할을 한다. 프로시저는 추상화를 구현하는 한 방법이다.

x10-x17에는 패러미터, x1에는 리턴 주소를 놓는다.

> **jump-and-link instruction**: An instruction that branches to an address and simultaneously saves the address of the following instruction in register.

> **return address**: A link to the calling site that allows a procedure to return to the proper address.

> **program counter(PC)**: The register containing the address of the instruction in the program being executed.

> **stack**: A data structure for spilling registers organized as a last-in-first-out queue.

jal, jalr 모두 unconditional branch에 사용될 수 있다. jalr은 함수 리턴에서 x1을 통해 무조건? 사용되고 jal은 얘도로 된다~ 느낌인듯.

By historical precedent, stacks “grow” from higher addresses to lower addresses. This convention means that you push values onto the stack by subtracting from the stack pointer. Adding to the stack pointer shrinks the stack, thereby popping values off the stack.

한번도 사용되지 않은 레지스터를 백업/복원하는 참사를 막기 위해 RISC-V에서는 19개의 레지스터를 두 부류로 나눈다.

- x5−x7 and x28−x31: temporary registers that are not preserved by the callee (called procedure) on a procedure call
- x8−x9 and x18−x27: saved registers that must be preserved on a procedure call (if used, the callee saves and restores them)

Procedures that do not call others are called leaf procedures.

!@address.c@!

!@address.s@!

!@deadbeef.c@!

!@deadbeef.s@!

A C variable is generally a location in storage, and its interpretation depends both on its type and storage class. Example types include integers and characters (see Section 2.9). C has two storage classes: automatic and static. Automatic variables are local to a procedure and are discarded when the procedure exits. Static variables exist across exits from and entries to procedures. C variables declared outside all procedures are considered static, as are any variables declared using the keyword static. The rest are automatic. To simplify access to static data, some RISC-V compilers reserve a register x3 for use as the global pointer, or gp.

> **global pointer**: The register that is reserve dto point to the static area.

- Preserved: Saved registers(x8-9, x18-27), Stack pointer register(x2, sp), Frame pointer(x8, fp), Return address(x1, ra), Stack above the stack pointer
- Not preserved: Temporary registers(x5-7, x28-31), Argument/result registers(x10-17), Stack below the stack pointer.

Stack above/below 의미 알기!

> **procedure frame(activation record)**: The segment of the stack containing a procedure's saved registers and local variables.

> **frame pointer**: A value denoting the location of the saved registers and local variables for a given procedure.

Frame pointer offers a stable base register within a procedure for local memory-references.

When a frame pointer is used, it is initialized using the address in sp on a call, and sp is restored using fp.

> **text segment**: The segment of a UNIX object file that contains the machine language code for routines in the source file.

낮은 주소값부터 reserved -> text(0x40_0000) -> static data(0x100_00000) -> dynamic data <- stack(~0x3f_ffff_fff0). 주소값은 software convention으로 RISC-V architecture의 일부가 아니다.

This convention is another example of making the common case fast: most procedures can be satisfied with up to eight argument registers, twelve saved registers, and seven temporary registers without ever going to memory.

What if there are more than eight parameters? The RISC-V convention is to place the extra parameters on the stack just above the frame pointer.

The RISC-V C compiler only uses a frame pointer in procedures that change the stack pointer in the body of the procedure.

```c
int sum (int n, int acc) {
    if (n > 0)
        return sum(n − 1, acc + n);
    else
        return acc;
}
```

tail call optimization이 가능하다. -O3을 줘야 잘해주네

```s
	.file	"tailcall.c"
	.text
	.align	2
	.globl	sum
sum:
	mv	a5,a0
	mv	a0,a1
	ble	a5,zero,.L2
.L3:
	mv	a4,a5
	addiw	a5,a5,-1
	addw	a0,a4,a0
	bne	a5,zero,.L3
.L2:
	ret
	.size	sum, .-sum
```

**Check Yourself**: both

### 9. Communicating with People

ASCII에서 대문자와 소문자는 32 차이난다.

Because of the popularity of text in some programs, however, RISC-V provides instructions to move bytes. Load byte unsigned (lbu) loads a byte from memory, placing it in the rightmost 8 bits of a register. Store byte (sb) takes a byte from the rightmost 8 bits of a register and writes it to memory.

!@sb.c@!

!@sb.s@!

When a compiler finds a leaf procedure, it exhausts all temporary registers before using registers it must save.

기본적으로 유니코드는 character를 표현하기 위해 16비트를 사용한다.

A 16-bit encoding, called UTF-16, is the default. A variable-length encoding, called UTF-8, keeps the ASCII subset as eight bits and uses 16 or 32 bits for the other characters. UTF-32 uses 32 bits per character.

!@emoji.c@!

!@emoji.s@!

Newcomers to computing are surprised that the type of the data is not encoded inside the data but instead in the program that operates on that data. ... This unrestricted behavior is why file systems have a naming convention of the suffix giving the type of file (e.g., .jpg, .pdf, or .txt) to enable the program to check for mismatches by file name to reduce the occurrence of such embarrassing scenarios.

**Check Yourself**: I-1,**2**. II-3

### 10. RISC-V Addressing for Wide Immediates and Addresses

범위는 아닌데 내용이 도움은 될 듯?

## 3. Arithmetic for Computers

1-5

### 1. Introduction

Representation of real numbers, arithmetic algorithms, hardware that follows these algorithms— and the implications of all this for instruction sets.

### 2. Addition and Subtraction

다른 부호간 덧셈에서는 오버플로우가 발생할 수 없다. 뺄셈에서는 부호가 같으면 발생할 수 없다.

결과가 피연산자와 부호가 다르면 오버플로우이다. Carry out occurred into the sign bit / Borrow occurred from the sign bit.

Fortunately, the compiler can easily check for unsigned overflow using a branch instruction. Addition has overflowed if the sum is less than either of the addends, whereas subtraction has overflowed if the difference is greater than the minuend.

It’s easy to detect overflow in unsigned numbers, although these are almost always ignored because programs don’t want to detect overflow for address arithmetic, the most common use of natural numbers.

> **Arithmetic Logic Unit(ALU)**: Hardware that performs addition, subtraction, and usually logical operations such as AND or OR.

Some programming languages allow two’s complement integer arithmetic on variables declared byte and half, whereas **RISC-V only has integer arithmetic operations on full words.**

One feature not generally found in general-purpose microprocessors is **saturating operations**. Saturation means that when a calculation overflows, the result is set to the largest positive number or the most negative number, rather than a modulo calculation as in two’s complement arithmetic. (e.g. media operations)

**Check Yourself**: RISC-V only has integer arithmetic operations on fuil words. 2

### 3 Multiplication

The first operand is called the **multiplicand** and the second the **multiplier**. The final result is called the product.

**n + m bits** are required to represent all possible products.

Traditional method에서는 multiplicand를 32번 shift right하니 총 64비트 multiplicand register가 필요하다. 1. Multiplier의 LSB를 확인하고 1이면 product register 업데이트, 2. multiplicand shift left, 3. multiplier shift right. 이대로면 3사이클이지만 덧셈을 하는동안 shift하면 1사이클에 가능하다. The hardware only has to ensure that it tests the right bit of the multiplier and gets the **preshifted** version of the multiplicand.

The relative importance of arithmetic operations like multiply varies with the program, but addition and subtraction may be anywhere from 5 to 100 times more popular than multiply. Accordingly, in many applications, multiply can take several clock cycles without significantly affecting performance. **However, Amdahl’s Law (see Section 1.10) reminds us that even a moderate frequency for a slow operation can limit performance.**

!@mulOptimize.c@!

!@mulOptimize.s@!

Traditional method에서 product의 오른쪽 절반이 비어있고 마침 multiplier도 한칸씩 사라지니 얘네 둘을 합쳐보자. Product를 shift right한다. 이제 product register는 32bit adder의 carry-out을 받기 위해 65비트이다. 왼쪽 고정 위치에 써서 그런듯? 근데 그림은 왜저럼.

The easiest way to understand how to deal with signed numbers is to first convert the multiplier and multiplicand to positive numbers and then remember their original signs. 이후 sign bit 빼고 31단계를 거친다.

사실 last algorithm에서 shifting step에서 sign extension만 해줘도 된다? When the algorithm completes, the lower word would have the '32-bit' product??

A straightforward approach would be to connect the outputs of adders on the right to the inputs of adders on the left, making a stack of adders 64 high. An alternative way to organize these 32 additions is in a parallel tree, as Figure 3.7 shows. Instead of waiting for 32 add times, we wait just the log2 (32) or five 32-bit add times.

In fact, multiply can go even faster than six add times because of the use of carry save adders (see Section A.6 in Appendix A), and because it is easy to pipeline such a design to be able to support many multiplies simultaneously (see Chapter 4).

mul, mulh, mulhu, mulhsu. 32bit곱이면 mul, 64곱의 위쪽은 signed면 mulh, unsigned면 mulhu, 다르면 mulhsu. 그런데 해보니까 mulw가 나오는데?

Software can use the multiply-high instructions to check for **overflow from 32-bit multiplication**. There is no overflow for 32-bit unsigned multiplication if mulhu’s result is zero. There is no overflow for 32-bit signed multiplication if all of the bits in mulh’s result are copies of the sign bit of mul’s result. 여기서 오버플로우란 32비트에 안들어가는 값을 말한다.

### 4. Division

> **dividend**: A number being divided.

> **divisor**: A number that the dividend is divided by.

!@div.c@!

!@div.s@!

첫버전에서는 64bit divisor register, 32bit quotient register, 64bit remainder register, 64bit ALU를 사용한다. Divisor의 우측 32bit에 dividor를 넣는다. Remainder - Divisor이후 부호를 보고 음수면 다시 더해 원상복구하고, 어찌됐든 quotient를 shift left하고 0또는 1을 우측에 넣는다. 이후 divisor를 shift right한다. 이걸 32번 반복.

Remainder 우측 비어있고 Quotient는 하나씩 줄어드니 최적화 가능하다. Remainder 오른쪽에 quotient를 넣고 왼쪽 시프트를 한다. 곱셈과 마찬가지로 carry out이 사라지지 않게 remainer register가 65bit이다.

So far, we have ignored signed numbers in division. The simplest solution is to remember the signs of the divisor and dividend and then negate the quotient if the signs disagree.

Dividend = Quotient \* Divisor + Remainder가 성립. -7 나누기 2의 몫이 -4고 나머지가 1이면 7 나누기 2와 몫의 절대값이 달라진다. -(x / y) != (-x) / y면 머리 깨지니 dividend와 remainder가 같은 부호이도록 한다. Thus, the correctly signed division algorithm negates the quotient if the signs of the operands are opposite and makes the sign of the nonzero remainder match the dividend.

We used many adders to speed up multiply, but we cannot do the same trick for divide. The reason is that we need to know the sign of the difference before we can perform the next step of the algorithm, whereas with multiply we could calculate the 32 partial products immediately.

There are techniques to produce more than one bit of the quotient per step. The **SRT division technique** tries to predict several quotient bits per step, using a table lookup based on the upper bits of the dividend and remainder. 오늘날에는 4비트를 쓴다.

곱셈과 나눗셈에 동일한 하드웨어가 사용될 수 있다. The only requirement is a 64-bit register that can shift left or right and a 32-bit ALU that adds or subtracts. 그래서 figure 1.1에 shift right도 있나?

div, divu, rem, remu 가 있다. immediate 버전은 없나?

RISC-V divide instructions ignore overflow, so software must determine whether the quotient is too large. 몫이 클 수도 있나?

An even faster sequential algorithm than Figure 3.9 does not immediately add the divisor back if the remainder is negative. It simply adds the dividend to the shifted remainder in the following step, since (r + d) × 2 − d = r − 2 + d × 2 − d = r × 2 + d. This **nonrestoring division algorithm**, which takes one clock cycle per step, is explored further in the exercises; the algorithm in Figure 3.9 is called **restoring division**. A third algorithm that doesn’t save the result of the subtract if it’s negative is called a **nonperforming division algorithm**. It averages one-third fewer arithmetic operations.

### 5. Floating Point

> **scientific notation**: A notation that renders numbers with a single digit to the left of the decimal point.

> **normalized**: A number in floating-point notation that has no leading 0s.

1.0 \* 10^9는 normalized number이지만 0.1 \* 10^-8은 아니다.

> **floating point**: Computer arithmetic that represents numbers in which the binary point is not fixed.

> **fraction**: The value, generally between 0 and 1, placed in the fraction field. The fraction is also called the **mantissa**.

> **exponent**: In the numerical representation system of floating-point arithmetic, the value that is placed in the exponent field.

fraction은 정밀도에, exponent는 범위와 관련되어있다.

> **overflow(floating-point)**: A situation in which a positive exponent becomes too large to fit in the exponent field.

> **underflow(floating-point)**: A situation in which a negative exponent becomes too large to fit in the exponent field.

오버플로우는 그럼 fraction의 부족이랑은 관계없는건가?

double precesion은 64비트, single precesion은 32비트. 1 + 8 + 23, 1 + 11 + 52. Double precesion의 장점은 exp보다는 큰 frac을 통한 정밀성에 있다.

The address of the instruction that overflowed is saved in a register, and the computer jumps to a predefined address to invoke the appropriate routine for that exception.

RISC-V는 오버플로우나 언더플로우에 exception을 발생시키지는 않지만 floating-point control and status register(fcsr)를 확인해볼 수 있다.

IEEE 754 floating-point standard.

fraction에 생략된 1을 더한 것을 significand라 하자. 0이면 안붙이고 0이다.

For the mathematically trained, the purpose of infinity is to form topological closure of the reals.

The purpose of NaNs is to allow programmers to postpone some tests and decisions to a later time in the program when they are convenient.

- exp가 0인데 frac이 0이면 0, 아니면 denormalized.
- exp가 최대값인데 frac이 0이면 inf, 아니면 NaN
- 나머지는 floating-point number

exponent가 significant보다 앞에 있으니 정렬에 용이하다. 음수면 불편하니 bias를 넣는다. 가장 작은 exponent를 0으로, 가장 큰 exponent를 1111...로 표현한다. **biased notation**. bias는 128이 아니라 127이다. denormalized랑 관계있는건가?

The revised standard IEEE 754-2008 includes nearly all the IEEE 754-1985 and adds a 16-bit format (“half precision”) and a 128-bit format (“quadruple precision”).

For the example below, remember that for single precision, the maximum exponent is 127, and the minimum exponent is −126.

1. Compare the exponents of the two numbers; shift the smaller number to the right until its exponent would match the larger exponent
1. Add the significands
1. Normalize the sum, either shifting right and incrementing the exponent or shifting left and decrementing the exponent.
1. If overflow, exception.
1. Round the significand to the appropriate number of bits
1. Back to normalized if not.

곱셈에서 underflow may occur if both operands are small—that is, if both have large negative exponents.

Figure 3.15 또 보기.

비트 자르는거를 곱셈 직후에도 하네?

fadd.s, fadd.b, sub, mul, div, sqrt, eq, lt, le...

flw, fld, fsw, fsd.

!@floatCmp.c@!

!@floatCmp.s@!

The RISC-V designers decided to add separate floating-point registers. They are called f0, f1, ..., f31. Hence, they included separate loads and stores for floating-point registers: fld and fsd for double-precision and flw and fsw for single-precision. The base registers for floating-point data transfers which are used for addresses remain integer registers.

!@floatLoad.c@!

!@floatLoad.s@!

f0-f31 레지스터는 float/double 모두 담을 수 있다. double은 나눠서 담나?

The benefits of separate floating-point registers are having twice as many registers without using up more bits in the instruction format, having twice the register bandwidth by having separate integer and floating-point register sets, and being able to customize registers to floating point; for example, some computers convert all sized operands in registers into a single internal format?

Compiling Floating-Point C Procedure with Two-Dimensional Matrices into RISC-V 예시 시간날 때 보기.

As mentioned in Section 3.4, accelerating division is more challenging than multiplication. In addition to SRT, another technique to leverage a fast multiplier is **Newton’s iteration**, where division is recast as finding the zero of a function to produce the reciprocal 1/c, which is then multiplied by the other operand. Iteration techniques cannot be rounded properly without calculating many extra bits. A TI chip solved this problem by calculating an extra-precise reciprocal.

부동소수점의 반올림을 정확하게 하려면 추가적인 비트를 관리하는 하드웨어가 필요하다. (전에 내가 궁금해한 것처럼 비트 자르는걸 곱셈 직후에 하면 반올림의 여지가 없다? <- 곱셈 내용 / 덧셈 내용 ->) 따라서 guard와 round 두 비트를 중간 덧셈 과정에서 유지한다.

[Here is an example of why you need a Guard bit, in addition to the Round and Sticky bits.](https://pages.cs.wisc.edu/~david/courses/cs552/S12/handouts/guardbits.pdf)

> **guard**: The first of two extra bits kept on the right during intermediate calculations of floating-point numbers; used to improve rounding accurary.

> **round**: Method to make the intermediate floating-point result fit the floating-point format; the goal is typically to find the nearest number that can be represented in the format. It is also the name of the second of two extra bits kept on the right during intermediate floating-point calculations, which improves rounding accuracy.

> **units in the last place (ulp)** The number of bits in error in the least significant bits of the significand between the actual number and the number that can be represented.

If a number were off by 2 in the least significant bits, it would be called off by 2 ulps. Provided there are no overflow, underflow, or invalid operation exceptions, IEEE 754 guarantees that the computer uses the number that is within **one-half ulp**.

곱셈은 추가 비트가 꼭 2개 필요하다. A binary product may have one leading 0 bit; hence, the normalizing step must shift the product one bit left. This shifts the guard digit into the least significant bit of the product, leaving the round bit to help accurately round the product.

> **sticky bit**: A bit used in rounding in addition to guard and round that is set whenever there are nonzero bits to the right of the round bit.

The goal of the extra rounding bits is to allow the computer to get the same results as if the intermediate results were calculated to infinite precision and then rounded. To support this goal and round to the nearest even, the standard has a third bit in addition to guard and round; it is set whenever there are nonzero bits to the right of the round bit. This sticky bit allows the computer to see the difference between 0.50 ... 00ten and 0.50 ... 01ten when rounding.

RISC-V, MIPS-64, PowerPC, AMD SSE5, and Intel AVX architectures all provide a single instruction that does a multiply and add on three registers: a = a + (b × c). Obviously, this instruction allows potentially higher floating-point performance for this common operation. Equally important is that instead of performing two roundings—after the multiply and then after the add—which would happen with separate instructions, the multiply add instruction can perform a **single rounding** after the add. A single rounding step increases the precision of multiply add. Such operations with a single rounding are called **fused multiply add**. It was added to the revised IEEE 754-2008 standard

> **fused multiply add**: A floating-point instruction that performs both a multiply and an add, but rounds only once after the add.

반올림은 나중에 손으로도 해보기,,

**The BIG Picture**: Bit patterns have no inherent meaning. They may represent signed integers, unsigned integers, floating-point numbers, instructions, character strings, and so on. What is represented depends on the instruction that operates on the bits in the word. The major difference between computer numbers and numbers in the real world is that computer numbers have limited size and hence limited precision; it’s possible to calculate a number too big or too small to be represented in a computer word. Programmers must remember these limits and write programs accordingly.

To accommodate comparisons that may include NaNs, the standard **includes ordered and unordered as options for compares**. RISC-V does not provide instructions for unordered comparisons, but a careful sequence of ordered comparisons has the same effect. (Java does not support unordered compares.)

[What does ordered / unordered comparison mean?](https://stackoverflow.com/questions/8627331/what-does-ordered-unordered-comparison-mean)

In an attempt to squeeze every bit of precision from a floating-point operation, the standard allows some numbers to be represented in unnormalized form. Rather than having a gap between 0 and the smallest normalized number, IEEE allows **denormalized numbers** (also known as denorms or subnormals). They have the same exponent as zero but a nonzero fraction. They allow a number to degrade in significance until it becomes 0, called gradual underflow. For example, the smallest positive single precision normalized number is

1.0000 0000 0000 0000 0000 0000 \* 2^-126

but the smallest single precision denormalized number is

0.0000 0000 0000 0000 0000 001 \* 2^-126 or 1.0 \* 2^-129

For double precision, the denorm gap goes from 1.0 × 2−1022 to 1.0 × 2−1074.

The possibility of an occasional unnormalized operand has given headaches to floating-point designers who are trying to build fast floating-point units. Hence, many computers cause an exception if an operand is denormalized, letting software complete the operation. Although software implementations are perfectly valid, their lower performance has lessened the popularity of denorms in portable floating-point software. Moreover, if programmers do not expect denorms, their programs may surprise them.

**Check Yourself**: 3. 더 정확히 풀어보기.

## 4. The Processor

1-4

### 1. Introduction

lw는 레지스터 1개 읽지만 나머지 대부분은 2개 읽는다.

모든 instruction class들이 레지스터를 읽은 후 ALU를 사용한다.

A **control unit**, which has the instruction as an input, is used to determine how to set the control lines for the functional units and two of the multiplexors.

Figure 4.2 그려보기.

**Check Yourself**: datapath, control, memory. (input output 없음.)

**Check Yourself**: false. **false. Edge-triggered state elements make simultaneous reading and writing both possible and unambiguous.**

### 2. Logic Design Conventions

Furthermore, if we saved and restored the state elements, it would be as if the computer had never lost power. Thus, these state elements completely characterize the computer.

...our RISC-V implementation uses two other types of state elements: memories and registers

Logic components that contain state are also called sequential. 순차 회로가 조합 회로를 포함할 수 있는 느낌인듯?

순차 회로의 출력은 입력과 내부 상태에 연관되어있다. Mealy machine으로 생각하는건가? 레지스터를 생각해보면 입력한 레지스터 번호와 이전에 레지스터에 쓰인 값과 관련되어있다.

> **control signal**: A signal used for multiplexor selectio or for directing the operation of a functional unit; contrasts with a data signal, which contains information that is operated on by a functional unit.

**asserted**는 logically high or true, **deasserted**는 logically low or false.

### 3. Building a Datapath

> **datapath element**: A unit used to operate on or hold data within a processor.

Two state elements are needed to store and access instructions. Instruction memory + PC. **Instruction memory는 read access만 제공된다면 combinational logic으로 간주한다.** 프로그램을 load할 떄는 쓰기 작업이 필요하지만 여기서는 생략. PC는 매번 write되기에 write control signal이 필요하지 않다.

The register file always outputs the contents of whatever register numbers are on the Read register inputs. Writes, however, are controlled by the write control signal, which must be asserted for a write to occur at the clock edge.

Since writes to the register file are edge-triggered, our design can legally read and write the same register within a clock cycle: the read will get the value written in an earlier clock cycle, while the value written will be available to a read in a subsequent clock cycle.

> **branch target address**: The address specified in a branch, which becomes the new PC if the branch is taken. In the RISC-V architecture, the branch target is given by the sum of the offset field of the instruction and the **address of the branch**.

Offset field는 half word offset으로 실제 값을 얻으려면 shift right 1 해야한다.

Data memory unit에 MemWrite 있는건 알았는데 MemRead도 있다. CLK은 안먹나? The memory unit needs a read signal, since, unlike the register file, reading the value of an invalid address can cause problems. 언젠가 살펴본 것처럼 MemRead 없으면 segmentation fault등이 일어날 수 있다.

The immediate generation unit (ImmGen) has a 32-bit instruction as input that selects a 12-bit field for load, store, and branch if equal that is sign-extended into a 32-bit result appearing on the output.

This simplest datapath will attempt to execute all instructions in one clock cycle. Thus, that no datapath resource can be used more than once per instruction, so any element needed more than once must be **duplicated**. We therefore need a memory for instructions separate from one for data?

The immediate generation logic must choose between sign-extending a 12-bit field in instruction bits 31:20 for load instructions, bits 31:25 and 11:7 for store instructions, or bits 31, 7, 30:25, and 11:8 for the conditional branch. Since the input is all 32 bits of the instruction, it can use the opcode bits of the instruction to select the proper field. **RISC-V opcode bit 6 happens to be 0 for data transfer instructions and 1 for conditional branches, and RISC-V opcode bit 5 happens to be 0 for load instructions and 1 for store instructions. Thus, bits 5 and 6 can control a 3:1 multiplexor inside the immediate generation logic that selects the appropriate 12-bit field for load, store, and conditional branch instructions**.

**Check Yourself**: I-a, II-c. the processor operates in one clock cycle and cannot use a (single- ported) memory for two different accesses within that clock cycle.

### 4. A Simple Implementation Scheme

여기서 ALU는 opcode과 2-bit signal을 control input으로 받는다??

We can generate the 4-bit ALU control input using a small control unit that has as inputs the **funct7** and **funct3** fields of the instruction and a 2-bit control field, which we call **ALUOp**??

This style of using multiple levels of decoding—that is, the main control unit generates the ALUOp bits, which then are used as input to the ALU control that generates the actual signals to control the ALU unit—is a common implementation technique. Using multiple levels of control can reduce the size of the main control unit. Using several smaller control units may also potentially reduce the latency of the control unit. Such optimizations are important, since the latency of the control unit is often a critical factor in determining the clock cycle time.

Funct fields are used only when the ALUOp bits equal 10.

note that the only bits with different values for the four R-format instructions are bits 30, 14, 13, and 12. Thus, we only need these four funct field bits as input for ALU control instead of all 10.

SB에서는 immediate가 shift된다는 특징이 있다.

RISC-V has two formats where all the fields are the same size and are immediates as in two other formats—SB versus S and UJ versus U.

Once again, RISC-V architects designed odd-looking but efficient formats, simplifying **18** 1-bit multiplexors.

The ALU control block has also been added, which depends on the funct3 field and part of the funct7 field.

The control unit can set all but one of the control signals based solely on the opcode and funct fields of the instruction. The PCSrc control line is the exception.

ALU control에 inst[30, 14-12]와 ALUOp가 들어가서 ALU 입력인 4비트 값이 나온다. ALUOp는 어디서 난거야?? Figure 4.21 보니까 control에서 ALUOp가 나오고 얘를 다시 ALU control에 넣는다. Control에서는 inst[6-0]만 담당하는 식으로 역할 분담을 한 듯.

Read register 1은 무조건 19-15, read register 2는 무조건 24-20, write register는 11-7이라서 행복하다. Immgen은 다먹음. 굳이? opcode 빼고 줘도 되긴 되는거 아닌가.

RegWrite, ALUSrc, PCSrc, MemRead, MemWrite, MemtoReg.

The input to the control unit is the 7-bit opcode field from the instruction. The outputs of the control unit consist of two 1-bit signals that are used to control multiplexors (ALUSrc and MemtoReg), three signals for controlling reads and writes in the register file and data memory (RegWrite, MemRead, and MemWrite), a 1-bit signal used in determining whether to possibly branch (Branch), and a 2-bit control signal for the ALU (ALUOp).

Mem-Write와 Mem-Read 중 하나만 1이다.

가장 긴 경로를 가진 명령어는 most likely a load instruction, which uses five functional units in series: the instruction memory, the register file, the ALU, the data memory, and the register file.

**Check Yourself**: Can any control signal output in the figure be replaced by the inverse of another? (Hint: take into account the don’t cares.) If so, can you use one signal for the other without adding an inverter? -> MemtoReg와 ALUOp1. MemtoReg MUX의 1과 0을 반대로 한다. + Branch and ALUOp0, ALUSrc and MemtoReg.

여기까지 중간고사 - - - - - - - - - - -

6-10

## 5. Large and Fast: Exploiting Memory Hierarchy

1-4, 7-8

## Appendix A

중간고사 reading assignment 일부

생각보다 길어서 pass.

## 퀴즈

ARM is one of the least RISCy, having a load-multiple instruction and complex addressing modes. [ARM vs RISC and x86 vs CISC](https://stackoverflow.com/questions/72962725/arm-vs-risc-and-x86-vs-cisc)

[Why does Intel hide internal RISC core in their processors?](https://stackoverflow.com/questions/5806589/why-does-intel-hide-internal-risc-core-in-their-processors)

## 중간고사 practice.questions

1. What does computer architecture specify?

Computer architecture is a specification detailing how a set of software and hardware technology standards interact to form a computer system or platform. In short, computer architecture refers to how a computer system is designed and what technologies it is compatible with.

2. What are the "Seven Great Ideas in Computer Architecture"?

- Use Abstraction to Simplify Design
- Make the Common Case Fast
- Performance via Parallelism
- Performance via Prediction
- Hierarchy of Memories
- Dependability via Redunduncy

3. What are the basic components of (almost) every computer?

Datapath, control, input, output, memory

4. The compiler performs what job?

A program that translates high-level language statements into assembly language statements.

5. The assembler performs what job?

A program that translates a symbolic version of instructions into the binary version.

6. What is the yield of a chip manufacturing process?

The percentage of good dies from the total number of dies on the wafer.

7. Explain the difference between little- and big- endian memory systems.

A big-endian system stores the most significant byte of a word at the smallest memory address and the least significant byte at the largest. A little-endian system, in contrast, stores the least-significant byte at the smallest address.

8. pass

9. pass

10. ~x + x = 111...111 = -1

11.

value = value >> 31; return !value | !~value

12. overflow

13. 232B

14. ???

15. a0-a7, use stack if more than 8.

16. 함수로 jump할 때 다음 명령어의 주소를 return address register에 저장한다. 여기 값으로 되돌아간다.

17. 전부 저장 안해도 되게

18. local variable, array, struct, spilled register...

19. a + sizeof(int) _ x _ y + sizeof(int) \* y

20. count number of ld operation

21. https://stackoverflow.com/questions/56761591/how-do-i-organize-members-in-a-struct-to-waste-the-least-space-on-alignment

22. What is a combinational circuit?

A logic system whose blocks do not contain memory and hence compute the same output given the same input.

23. What is a sequential circuit?

A group of logic elements that contain memory and hence whose value depends on the inputs as well as the current contents of the memory.

24. Why can we not clock processors as fast as we want?

The longest possible path in the processor determines the clock cycle. 한 사이클 내에 memory에 저장될 값이 준비되어야한다.

25. 그림 그림

26. 부동소수점은 표현할 수 있는 자릿수(fraction)에 한계가 있다. 따라서 소수점 위와 아래 모두 너무 많으면 소수점쪽이 잘림??

27. What does the Instructino Set Architecture of a processor architecture define?

Memory addressing, Type and size of operands, Operations, Instruction encoding

28. Explain the differences between Intel and RISC-V processors.

https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/

## 기타

https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/

https://www.forrestthewoods.com/blog/perfect_prevention_of_int_overflows/

https://stackoverflow.com/questions/59693334/why-ra-is-caller-saved-in-risc-v

https://stackoverflow.com/questions/9772348/get-absolute-value-without-using-abs-function-nor-if-statement