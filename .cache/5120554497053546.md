
[web.dev/learn/css](https://web.dev/learn/css/)

## Learn CSS

## Box Model

> Everything displayed by CSS is a box. Understanding how the CSS Box Model works is therefore a core foundation of CSS.

```html
<body>
  <p>I am a paragraph of text that has a few words in it.</p>
</body>
<style>
  p {
    width: 100px;
    height: 50px;
    padding: 20px;
    border: 1px solid;
  }
</style>
```

이러면 컨텐츠가 튀어나오고 width는 100이 아니라 142이다. Box model은 CSS의 core foundation이다.

CSS에서 표시되는 모든 것은 박스이다. border-radius가 있든, 텍스트든간에.

### Content and sizing

Boxes have different behavior based on their...

- display value
- their set dimensions,
- and the content that lives within them.

크기가 명시되면 **extrinsically sized**, 없거나 width: min-content등으로 되면 **intrinsic sized**. 명시되면 content overflow가 일어날 수 있다. Though extrinsic sizing gives more control on the surface, intrinsic sizing provides the most flexibility, most of the time.

When content is too big for the box it is in, we call this **overflow**.

### The areas of the box model

Content box > Padding box > Border box > Margin box

padding은 박스 안에 있어서 background of the box가 거기서 보인다. overflow 룰이 있다면 스크롤바도 여기에 있다. inline-scrollbars하면 스크롤바 유무 상관없이 공간 잡아먹는듯.

outline, box-shadow는 margin box도 먹는다. Because they are painted on top, so they don't affect the size of our box. outline이 50px 있어도 border-box까지의 크기는 같다.

### Controlling the box model

브라우저는 User agent stylesheet를 HTML 문서에 적용. CSS 없을 때 어떻게 보여야할지 묘사. 보통 div-block, li-list-item??, span-inline.

An **inline** element has block margin, but other elements won't respect it.

Use **inline-block**, and those elements will respect the block margin, while the element maintains most of the same behaviors it had as an inline element.

A **block** item will, by default, fill the available inline space, whereas a inline and inline-block elements will only be as large as their content.

You also need to understand **box-sizing**, which tells our box how to calculate its box size. By default, all elements have box-sizing: content-box;.

When you set dimensions on **content-box**, such as a width and height, they will be applied to the content box. If you then set padding and border, these values will be added to the content box's size.

반대로 border-box도 있다. Border와 padding이 get pushed in되어 크기 계산에 포함됨. Because the alternative box model can be more predictable, developers often add this rule to resets and normalizers.

```html
<body>
  <div class="Square A"></div>
  <br />
  <div class="Square A B"></div>
</body>

<style>
  .Square {
    width: 200px;
    height: 200px;
  }
  .A {
    background-color: red;
    padding: 10px;
    border: 20px solid blue;
  }
  .B {
    box-sizing: border-box;
  }
</style>
```

## Selectors

> To apply CSS to an element you need to select it. CSS provides you with a number of different ways to do this, and you can explore them in this module.

### Simple selectors

```css
/* Selector  */
.my-css-rule {
  background: red;
  /* Declaration */
  /* color는 Property, beige는 Value */
  color: beige;
  font-size: 1.2rem;
}

/* Universal selector */
* {
  color: hotpink;
}

/* type selector */
section {
  padding: 2em;
}

/* Class selector */
/* HTML 요소는 여러 클래스를 가질 수 있고 selector를 포함하면 스타일이 적용된다. */
.my-class {
  color: red;
}

/* ID selector */
#rad {
  border: 1px solid blue;
}

/* Attribute selector */
[data-type='primary'] {
  color: red;
}
/* s는 case-sensitive */
/* i는 case insensitivity */
/* 기본값이 뭔데?? */
[data-type='primary' s] {
  color: red;
}

/* A href that contains "example.com" */
[href*='example.com'] {
  color: red;
}

/* A href that starts with https */
[href^='https'] {
  color: green;
}

/* A href that ends with .com */
[href$='.com'] {
  color: blue;
}

/* Grouping selectors */
strong,
em,
.my-class,
[lang] {
  color: red;
}
```

If the browser encounters more than one instance of an id it will still apply any CSS rules that match its selector. However, any element that has an id attribute is supposed to have a unique value for it, so unless you're writing very specific CSS for a single element, avoid applying styles with the id selector as it means you can't re-use those styles elsewhere.

```html
<body>
  <div class="Square B A"></div>
  <br />
  <div class="Square A B"></div>
</body>

<style>
  .Square {
    width: 200px;
    height: 200px;
  }
  .A {
    background-color: red;
  }
  .B {
    background-color: blue;
  }
</style>
```

```html
<body>
  <div
    class="Square"
    hello="hello"
    exist
  ></div>
</body>

<style>
  .Square {
    width: 200px;
    height: 200px;
    background-color: royalblue;
  }
  [hello='hello'] {
    background-color: rosybrown;
  }
  [exist] {
    border: solid 10px blue;
  }
</style>
```

```html
<body>
  <a href="my-image.jpg">An example image</a>
  <a href="my-document.pdf">An example document</a>
</body>

<style>
  a[href$='.pdf']::before {
    background-image: url(https://web-dev.imgix.net/image/VbAJIREinuYvovrBzzvEyZOpw5w1/fc7bLiJYf5US6QxTOKsF.png);
  }
  a[href$='.jpg']::before {
    background-image: url(https://web-dev.imgix.net/image/VbAJIREinuYvovrBzzvEyZOpw5w1/N79qCc0c06217YT4ofYM.png);
  }
  a::before {
    content: '';
    display: inline-block;
    width: 1.2em;
    height: 1.2em;
    background-size: 100%;
  }
  body {
    display: flex;
    flex-direction: column;
  }
</style>
```

### Pseudo-classes and pseudo-elements

Pseudo-class: HTML elements find themselves in various states, either because they are interacted with, or one of their child elements is in a certain state.

Pseudo-elements: Pseudo-elements differ from pseudo-classes because instead of responding to the platform state, they act as if they are inserting a new element with CSS.

Class는 :, element는 ::를 사용한다.

::after, ::before, ::marker(style bullet point in the list), ::selection(content that has been highlilghted by a user)

둘은 다른 모듈에서 더 자세하게.

### Complext selectors

We are **not able to target upwards and select a parent element**. We cover what the cascade is and how it works in a later lesson.

A **combinator** is what sits between two selectors. **Combinators** help you select items based on their position in the document.

공백도 combinator로 descendant combinator이다.

```css
/* Descendant combinator */
/* 재귀적으로 적용된다. */
p strong {
  color: blue;
}

/* Next sibling combinator */
/* Universal selector와 함께 쓰면 어떤 요소가 들어있든 적용된다. */
.top * + * {
  margin-top: 1.5em;
}

/* Subsequent-sibling combinator */
/* 부모만 같으면 되는 듯? */
:checked ~ .toggle__decor {
  background: rebeccapurple;
}

/* Child combinator */
/* limit combinator selector to apply only to direct children */
.top > * + * {
  margin-top: 1.5em;
}
```

```html
<body>
  <div class="top box">
    <div>
      <p>1 level deep</p>
      <div>
        <p>2 levels deep</p>
        <div>
          <p>3 levels deep</p>
        </div>
      </div>
    </div>
  </div>
</body>

<style>
  .top div {
    padding-left: 2em;
  }
</style>
```

Because the combinator is recursive, all <div> elements that are in .top will have that same padding applied to them. .top element has several <div> child elements which themselves, have <div> child elements.

```css
/* Compound selectors */
a.my-class {
  color: red;
}
```

## The cascade

> Sometimes two or more competing CSS rules could apply to an element. In this module find out how the browser chooses which to use, and how to control this selection.

네가지 distinct stages로 나뉜다. 따로 순서가 있는건 아닌건가?? 느낌상 specificity를 가장 먼저 보는 것 같음. [링크](https://2019.wattenberger.com/blog/css-cascade)보니 Importance보고, 여기서 같으면 origin 봄. 여기서 같으면? specificity보고, Position 봄.

### Position and order of appearance

마지막에 선언된 것이 우선. <link>와 <style\>로 불러와도 마지막에 있는게 우선.

inline이 가장 우선.

Being able to specify two values for the same property can be a simple way to create fallbacks for browsers that do not support a particular value. CSS가 파싱 못하는 줄을 만났을 때 일반적인 프로그래밍 언어와 달리 그냥 무시하기 때문에 가능.

```css
.my-element {
  font-size: 1.5rem;
  font-size: clamp(1.5rem, 1rem + 3vw, 2rem);
}
```

### Specificity

다음 챕터에서 더. id, class, element 순으로 specific하다고 여긴다. This is one reason why it is generally not a good idea to attach styles to an id. It can make it difficult to overwrite that style with something else.

Specific의 정도에 따라 점수를 부여한다. CSS를 reusable하게 하려면 selector가 간단할 수록 좋다. Specificity를 원하는 element로 도달하기 위한 도구로 쓰지만 긴 selector list는 가능한 리팩터링하자.

### Origin

from least specific to most specific.

1. User agent base styles
1. Local user styles(OS level - base font size etc..., browser extensions)
1. Authored CSS
1. Authored !important
1. Local user styles !important(OS leve, browser extension...)
1. User agent !important(defined in the default CSS provided by the browser)

### Importance

from least important to most important

1. normal rule type(font-size, background, color)
1. animation
1. !important
1. transition

Rules that apply to an active transition take the utmost importance.

## Specificity

> This module takes a deeper look at specificity, a key part of the cascade.

### Specificity scoring

The score should only be as high as we need it to be, rather than aiming for the highest score possible. In the future, some genuinely more important CSS might need to be applied. If you go for the highest score, you'll make that job hard.

### Scoring each selector type

\* 0

element, pseudo-element 1

class, pseudo-class, attribute selector 10

```css
/* not은 점수가 없지만 그 안에 있는건 점수가 있다 */
/* 아래는 11점 */
div:not(.my-class) {
  color: red;
}
```

ID selector 100

inline style attribute 1000

!important 10000. 이게 최댓값

100, 10, 1로 모아 x-x-x 형식으로 표현하기도 한다.

```css
/* 0-4-1 */
a.my-class.another-class[href]:hover {
  color: lightgrey;
}
```

### Pragmatically increasing specificity

```css
/* 이런 짓으로 specificity를 높일 수도 있다. */
.my-button.my-button {
  background: blue;
}

button[onclick] {
  background: grey;
}
```

CAUTION: If you find that you are needing to boost specificity like this frequently, it may indicate that you are writing overly specific selectors. Consider whether you can refactor your CSS to reduce the specificity of other selectors to avoid this problem.

### A matching specificity score sees the newest instance win

```css
.my-button {
  background: blue;
}

[onclick] {
  background: grey;
}
/* 결과: blue */
```

## Inheritance

> Some CSS properties inherit if you don't specify a value for them. Find out how this works, and how to use it to your advantage in this module.

### Inheritance flow

Inheritance only cascades downwards.

### Which properties are inheritable?

생각보다 몇 개 없음.

azimuth border-collapse border-spacing caption-side color cursor direction empty-cells font-family font-size font-style font-variant font-weight font letter-spacing line-height list-style-image list-style-position list-style-type list-style orphans quotes text-align text-indent text-transform visibility white-space widows word-spacing

### How inheritance works

Every HTML element has every CSS property defined by default with an initial value(이건 user agent stylesheet과는 다른 것 같음). An initial value is a property that's not inherited and shows up as a default if the cascade fails to calculate a value for that element.

Properties that can be inherited cascade downwards, and child elements will get a computed value which represents its parent's value. This means that if a parent has font-weight set to bold all child elements will be bold, unless their font-weight is set to a different value, or the user agent stylesheet has a value for font-weight for that element.

### How to explicitly inherit and control inheritance

You can make any property inherit its parent's computed value with the inherit keyword. A useful way to use this keyword is to create **exceptions**.

```css
strong {
  font-weight: 900;
}

.my-component {
  font-weight: 500;
}

/* 이후 .my-component의 내용물이 바뀌어도 그것에 따라갈 것을 알 수 있다. */
.my-component strong {
  font-weight: inherit;
}
```

You learned earlier that every property has a default value in CSS. The **initial** keyword sets a property back to that initial, default value.

The **unset** property behaves differently if a property is inheritable or not. If a property is inheritable, the unset keyword will be the same as inherit. If the property is not inheritable, the unset keyword is equal to initial. 뭐가 inheritable한지 외우기 힘드니 그럴 때 유용하다. all: unset은 모든 프로퍼티에 적용한다.

## Color

There are several different ways to specify color in CSS. In this module we take a look at the most commonly used color values.

```css
h1 {
  /* Numeric colors */
  color: #b71540;

  /* An alpha value is a percentage of transparency. */
  /* 투명도가 높을수록 alpha값도 커져야되는거 아닌가??? 단어가 헷갈리네 */

  /* black with 75% alpha */
  color: #000000bf;
  /* 0% alpha - fully transparent */
  color: #00000000;

  /* three digit shorthand */
  color: #a4e8;
  color: #aa44ee88;

  /* RGB */
  /* 0-255 */
  /* 0-100% */
  color: rgb(183, 21, 64);
  color: rgb(0 0 0 / 50%);
  color: rgb(0 0 0 / 0.5);
  /* for wider suport */
  color: rgba(0, 0, 0, 50%);
  color: rgba(0, 0, 0, 0.5);

  /* HSL */
  color: hsl(344, 79%, 40%);
  color: hsla(0, 0%, 0%, 50%);
}
```

Commas were removed from the rgb() and hsl() notation because newer color functions, such as lab() and lch() use spaces instead of commas as a delimiter.

HSL stands for hue, saturation and lightness.

Hue describes the value on the color wheel, from 0 to 360 degrees, starting with red (being both 0 and 360).

Saturation is how vibrant the selected hue is. A fully desaturated color (with a saturation of 0%) will appear grayscale.

Lightness is the parameter which describes the scale from white to black of added light. A lightness of 100% will always give you white.

The angle type in CSS is great for defining hue because it represents the angle of the color wheel really well. This type accepts degrees, turns, radians and gradians.

### Color Keywords

148개의 named colors가 있다. 이외에도 transparent, currentColor와 같은 특별 키워드가 있다.

currentColor is the contextual computed dynamic value of the color property. If you have a text color of red and then set the border-color to be currentColor, it will also be red.

운영체제에서 정의하는 System keywords도 있다.

### Where to use color in CSS rules

color, text-shadow, text-decoration-color

background, background-color

linear-gradient

border-color, outline-color, box-shadow

## Sizing Units

In this module find out how to size elements using CSS, working with the flexible medium of the web.

```html
<body>
  <h1>Using a ch unit to size text</h1>
  <p>
    The ch unit allows you to control the size of text based on its actual contextual size—the width
    of a 0 character. This means that if you set the max width of some text as 70ch: regardless of
    the size of that text, you can always be sure that it will be at most, 70 characters wide.
  </p>
</body>

<style>
  body {
    max-width: 50ch;
    font-size: 1rem;
  }
</style>
```

### Numbers

opacity, line-height, rgb의 color channel value에서 사용. 문맥에 따른 의미를 지닌다.

line-height는 텍스트 크기의 배수.

It's a good idea to use a unitless value for line-height, rather than specifying a unit. As you learned in the inheritance module, **font-size can be inherited**. Defining a unitless line-height keeps the line-height relative to the font size. This provides a better experience than, say, line-height: 15px, which will not change and might look strange with certain font sizes.

### Percentages

width에서는 parent element의 가용 width의 percentage이다.

```css
div {
  width: 300px;
  height: 100px;
}

div p {
  width: 50%;
}
/* box-sizing: content-box이면 p의 width는 150px */
```

margin과 padding은 방향에 관계없이 width로 계산.

The **transform property** allows you alter an element's appearance and position by rotating, skewing, scaling and translating it. This can be done in a 2D and 3D space.

### Dimensions and lengths

If you attach a unit to a number, it becomes a **dimension**.

The unit that is attached to a number is referred to in specifications as a **dimension token**.

**Lengths** are dimensions that refer to distance and they can either be absolute or relative.

Absolute lengths에는 cm, mm, Q, in, pc, pt, px가 있다. 프린트하면 실제 값과 같을 것이다. Keep in mind, CSS is used not only for digital content, but also to style print content. Absolute lengths can really come in handy when designing for print.

A relative length is calculated against a base value, much like a percentage. Relative lengths are particularly useful on the web due to its responsive nature.

Font-size-relative lengths에는 em, ex, cap, ch, ic, rem, lh, rlh가 있다.

Viewport-relative units에는 vw, vh, vi, vb, vmin, vmax가 있다.

By sizing text with relative units like em or rem, rather than an absolute unit, like px, the size of your text **can respond to user preferences**. This can include the system font size or parent element's font size, such as the <body>. The base size of the em is the element's parent and the base size of the rem is the base font size of the document. If you don't define a font-size on your html element, this user-preferred system font size will be honoured if you use relative lengths, such as em and rem. If you use px units for sizing text, this preference will be ignored.

이외에도 color에서 살펴본 것 같은 angle units도 있다. deg, rad(radians), grad(gradians), turn. 1turn = 360deg.

Resolution unit으로 dpi가 있다. dots per inch. A useful context for this is detecting very high resolution screens, such as Retina displays in a media query and serving up a higher resolution image.

```css
div {
  background-image: url('a-low-resolution-image.jpg');
}

@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
  div {
    background-image: url('a-high-resolution-image.jpg');
  }
}
```

Viewport units are relative to the document window they were created in, which may or may not be the same as a device screen.

## Layout

> An overview of the various layout methods you have to choose from when building a component or page layout.

### Layout: a brief history

You can read how CSS layout and our approach to layout has evolved over time in [this article by Rachel Andrew](https://24ways.org/2019/a-history-of-css-through-15-years-of-24-ways/).

Intrinsic Web Design과 Container Queries는 뭘까,,

### Understanding the display property

display는 우선 box가 inline인지 block인지 결정한다.

Inline 요소들은 inline 방향으로 나란히 배치되고 surrounding whitespace를 보존한다? width와 height 설정이 불가능하다. 모든 block level margin/padding은 주변 요소들에게 무시된다.

Block 요소는 스스로의 line을 가진다. inline dimension으로 최대한 확장한다. 모든 방향의 margin이 보존된다.

display는 또한 children이 어떻게 행동할지 결정한다.

flex로 설정하면 box는 block-level box가 되고 children은 flex item이 된다. flex properies를 사용할 수 있게 된다.

### Flexbox and Grid

일단 high-level overview를 하자. They share similarities, but are designed to solve different layout problems.

Flexbox is a layout mechanism for one-dimensional layouts. Horizontally / vertically.

Grid is similar in a lot of ways to flexbox, but it is designed to control multi-axis layouts instead of single-axis layouts (vertical or horizontal space). Where flexbox mostly treats items as a group, grid gives you precise control over their placement in two dimensions.

### Flow layout

There are a number of layout methods that you can use to adjust the behavior and position of items when in normal flow.

Remember how surrounding elements don't respect block margin and padding on an inline element? With **inline-block** you can cause that to happen.

```html
<body>
  <div>
    <span>These two elements</span>
    <span>are normal spans, that are <code>display: inline</code> by default</span>.
    <p>
      This <span>span element</span>, inside a paragraph element is
      <code>display: inline-block</code>, so its top margin will no longer be ignored.
    </p>
  </div>
</body>

<style>
  p span {
    display: inline-block;
  }

  span {
    margin-top: 0.5rem;
    /* var는 뭐고 --color-stroke는 뭐지 */
    outline: 1px solid var(--color-stroke);
  }
</style>
```

When you use **float**, keep in mind that any elements following the floated element may have their layout adjusted. To prevent this, you can clear the float, either by using clear: both on an element that follows your floated element or with **display: flow-root** on the parent of your floated elements. Find out more in the article [The end of the clearfix hack](https://rachelandrew.co.uk/archives/2017/01/24/the-end-of-the-clearfix-hack/).

```css
/* multicolumn layout */
.countries {
  column-count: 2;
  column-gap: 1em;
}

.countries {
  width: 100%;
  column-width: 260px;
  column-gap: 1em;
}
```

The position property changes how an element behaves in the normal flow of the document, and how it relates to other elements.

relative, absolute, fixed, sticky, static(기본값).

relative는 본래 위치에 상대적으로 옮긴다. absolute인 자식 요소들이 얘를 기반으로 위치된다.

absolute로 설정하면 top, right, bottom, left도 가장 가까운 relative 부모를 기준으로 위치시킬 수 있다. absolute 요소 근처의 컨텐츠들이 얘의 공간을 채운다.

What does it mean if a block is out of flow? It's no longer positioned based on its siblings positions.

## Flexbox

> Flexbox is a layout mechanism designed for laying out groups of items in one dimension. Learn how to use it in this module.

Instead of setting rigid dimensions for the browser to follow, with flexbox, you can instead provide flexible boundaries to hint how the content could display.

Main axis and a cross axis. The main axis is the one set by your flex-direction property.

[CSS: display:inline-block and positioning:absolute](https://stackoverflow.com/questions/5042467/css-displayinline-block-and-positioningabsolute)

display: flex는 block-level box와 flex item children을 준다. 기본값은 row, no wrap, no grow, line up at start이다.

### Controlling the direction of items

flex-direction: row, row-reverse, column, column-reverse.

You should be cautious when using any properties that reorder the visual display away from how things are ordered in the HTML document, as it can negatively impact accessibility. Logical order는 그대로인에 visual order가 바뀌어서 스크린 리더등이 맞춰가지 못한다. 따라서 어떤 reordering이든 테스트가 필요하다.

The way flex items behave by default is linked to the writing mode of the document. 따라서 top, left, right, bottom보다 main-start, main-end, cross-start, cross-end로 칭하자.

### Wrapping flex items

flex-wrap: wrap

여러 줄로 됐을 때 각각의 줄은 새로운 flex container처럼 행동한다. Therefore it is not possible to get something in row 2 to line up with something above it in row 1. This is what is meant by flexbox being one-dimensional.

```css
.container {
  display: flex;
  /* flex-direction + flex-wrap */
  flex-flow: column wrap;
}
```

### Controlling space inside flex items

flex-initial. 0 1 auto.

- flex-grow: 0: items do not grow.
- flex-shrink: 1: items can shrink smaller than their flex-basis.
- flex-basis: auto: items have a base size of auto.

flex는 위 세 개의 약자.

flex:auto는 1 1 auto. Using flex: auto will mean that items end up different sizes, as the space that is shared between the items is shared out after each item is laid out as max-content size.

모든 아이템이 content 상관 없이 같은 크기이게 하려면 flex: 1. 1 1 0. 모든 아이템의 크기가 0이니 남은 공간이 공평하게 분배.

There is also a value of flex: none, which will give you inflexible flex items that do not grow or shrink. This might be useful if you are purely using flexbox to access the alignment properties but don't want any flexible behavior.

You could give your flex items different flex-grow factors. flex: 1, flex: 2, flex: 3. 일부만 쓰면 순서대로 적용되는건가? 두 개 쓰면 flex-shrink까지 되는건가.

### Reordering flex items

order property를 사용하지만 row-reverse와 마찬가지로 disconnected experience for some users가 될 수 있다.

A flex child item appears squished, which flex property helps mitigate this? Not flex-basis. This provides the starting point of sizing, but not how to handle sizing scenarios where width goes below basis, like in a squished scenario.

### Flexbox alignment overview

유용해서 Grid에서도 쓰인다.

Properties which distribute space.

- justify-content: space distribution on the main axis.
- align-content: space distribution on the cross axis.
- place-content: a shorthand for setting both of the above properties.

Properties for alignment in flexbox.

- align-self: aligns a single item on the cross axis.
- align-items: aligns all of the items as a group on the cross axis.

main axis면 justify-, cross axis면 align-.

```css
.container {
  place-content: space-between;
  /* sets both to space-between */
}

.container {
  place-content: center flex-end;
  /* wrapped lines on the cross axis are centered,
  on the main axis items are aligned to the end of the flex container */
}
```

With a **wrapped flex container** you might have space to distribute on the cross axis. In this case you can use the **align-content** property with the same values as justify-content.

The align-self property is applied to individual items. The align-items property can be applied to the flex container to set all of the individual align-self properties as a group.

The initial value of align-self is stretch, which is why flex items in a row stretch to the height of the tallest item by default.

[What's the difference between align-content and align-items?](https://stackoverflow.com/questions/27539262/whats-the-difference-between-align-content-and-align-items)

### Why is there no justify-self in flexbox?

Flex items act as a group on the main axis. So there is no concept of splitting an individual item out of that group. Setting an auto margin on one side of a flex item will push it away from the group.

### How to center an item vertically and horizontally

The alignment properties can be used to center an item inside another box. The justify-content property aligns the item on the main axis, which is row. The align-items property on the cross axis.

```html
<body>
  <div class="one">
    <div class="two" />
  </div>
</body>

<style>
  .one {
    width: 200px;
    height: 200px;
    background-color: royalblue;

    display: flex;
    justify-content: center;
    align-items: center;
  }

  .two {
    width: 100px;
    height: 100px;
    background-color: gray;
  }
</style>
```

align-content는 안되네?? ...But align-content is for multi line flexible boxes. It has no effect when items are in a single line. It aligns the whole structure according to its value.

## Grid

> CSS Grid Layout provides a two dimensional layout system, controlling layout in rows and columns. In this module discover everything grid has to offer.

A really common layout in web design is a header, sidebar, body and footer layout. Grid is exceptionally useful at combining the control that extrinsic sizing provides with the flexibility of intrinsic sizing, which makes it ideal for this sort of layout.

### Grid terminology

**Lines** are numbered starting from 1, with the numbering following the writing mode and script direction of the component.

A **track** is the space between two grid lines.

A **grid cell** is the smallest space on a grid defined by the intersection of row and column tracks.

**Grid areas** are created by causing an item to span over multiple tracks.

**Gaps**: A gutter or alley between tracks. For sizing purposes these act like a regular track???

**Grid container**: The HTML element which has display: grid applied.

A **grid item** is an item which is a direct child of the grid container.

### Rows and columns

When used as a track sizing auto can be thought of as being as big as the content. Tracks are auto sized by default.

```html
<body>
  <div
    class="container"
    id="container"
  >
    <div class="box">Item one</div>
    <div class="box">Item two</div>
    <div class="box">a ab abc abcd abcdefg</div>
    <div class="box">Item four</div>
    <div class="box">Item five</div>
  </div>
</body>

<style>
  .container {
    display: grid;
    /* parent width의 50%였지? */
    grid-template-columns: 5em 50% min-content;
    grid-template-rows: 200px auto;
    gap: 10px;
  }
  .box {
    border: 2px solid gray;
  }
</style>
```

오 크롬 inspector mode에서 grid의 display line numeber도 있네.

In addition to the length and percentage dimensions as described in the section on sizing units, grid tracks can use intrinsic sizing keywords. 그리드 아닌 곳에서도 활용할 수 있다.

The **min-content** keyword will make a track as small as it can be without the track content overflowing.

**max-content** - The track will become as wide enough for all of the content to display in one long unbroken string. This might cause overflows as the string will not wrap. Grid item이 자기 맘대로 커져버리니까.

The **fit-content() function** acts like max-content at first. However, once the track reaches the size that you pass into the function, the content starts to wrap.

**Auto** sized tracks will stretch by default if there is additional space in the grid container.

There is also a special sizing method which only works in grid layout. This is the **fr unit**, a flexible length which describes a share of the available space in the grid container. To have a component with a fixed size element and the second track taking up whatever space is left, you can use as a tracklisting of grid-template-columns: 200px 1fr.

The **minmax() function** means that you can set a minimum and a maximum size for a track.

This function means that you can set a minimum and a maximum size for a track. This can be quite useful. If we take the example of the fr unit above which distributes remaining space, it could be written out using minmax() as minmax(auto, 1fr). Grid looks at the intrinsic size of the content, then distributes available space after giving the content enough room. This means that you might not get tracks that each have an equal share of all space available in the grid container???

To force a track to take an equal share of the space in the grid container minus gaps use minmax. Replace 1fr as a track size with minmax(0, 1fr). This makes the minimum size of the track 0 and not the min-content size. Grid will then take all of the available size in the container, deduct the size needed for any gaps, and share the rest out according to your fr units???

The **repeat() function** can be used to repeat any section of your track listing.

...want to create as many as will fit in your container. You can achieve this with repeat() and the **auto-fill** or **auto-fit** keywords.

```css
.grid {
  grid-template-columns: repeat(auto-fill, 200px);
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  grid-template-columns: 200px repeat(2, 1fr 2fr) 200px; /*creates 6 tracks*/
}
```

Using the auto-fill keyword you can see that empty tracks(DOM 요소가 있다는게 아니라 빈 track이 있다는 뜻) have been created. Change the keyword to auto-fit and the tracks collapse down to 0 size.

### Auto-placement

grid-auto-flow: column

```html
<body>
  <div class="container1">
    <div class="box one">Item one</div>
    <div class="box two">Item two</div>
    <div class="box one">Item three</div>
    <div class="box one">Item four</div>
  </div>
  <br />
</body>

<style>
  .container1 {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: 1fr 1fr;
    gap: 10px;
  }
  .box {
    border: 2px solid gray;
  }
  .two {
    /* 이러면 three랑 four는 dense 없이도 two보다 먼저 나오네? */
    /* span 관련으로만 되는건가 */
    grid-row-start: 2;
    grid-column-start: 1;
    grid-column-end: span 2;
  }
</style>
```

As you have not specified a grid-column-start, this uses the initial value of auto and is placed according to the auto-placement rules??? You can also specify the same thing using the shorthand grid-column.

grid-auto-flow: dense면 남는 자리게 채운다.

### Placing items

The first thing to remember is that CSS Grid Layout is based on a grid of numbered lines. You always have access to those numbered lines.

line number로 place할 때 사용하는 프로퍼티

- grid-column-start
- grid-column-end
- grid-row-start
- grid-row-end

단축

- grid-column
- grid-row

Using line-based positioning you can place items into the same cell of the grid.

When you create a grid using grid-template-rows and grid-template-columns you create what is known as the **explicit grid**. This is a grid that you have defined and given size to the tracks. In some cases, grid will create tracks to make the layout work, and these tracks are referred to as the **implicit grid**. With line-based placement you may run into the main difference between the two.

Most of the time it will make no difference if you are working with an implicit or explicit grid. However, with line-based placement you may run into the main difference between the two.⬇️

Using **negative line numbers** you can place items from the end line of the explicit grid. This can be useful if you want an item to span from the first to the last column line. But if tracks are created in the implicit grid, there is no way to reach the end of the grid using -1.

The tracks created in the implicit grid will be auto-sized by default. However if you want to control the sizing of the rows, use the **grid-auto-rows** property, and for columns **grid-auto-columns**.

### Named grid lines

You can name any line on your grid by adding a name of your choosing between square brackets.

```css
.container {
  display: grid;
  grid-template-columns:
    [main-start aside-start] 1fr
    [aside-end content-start] 2fr
    [content-end main-end]; /* a two column layout */
}

.sidebar {
  grid-column: aside-start / aside-end;
  /* placed between line 1 and 2*/
}

footer {
  grid-column: main-start / main-end;
  /* right across the layout from line 1 to line 3*/
}
```

### Grid Template Areas

You can also name areas of the grid and place items onto those named areas. This is a lovely technique as it allows you to see what your component looks like right there in the CSS.

```css
header {
  grid-area: header;
}
.sidebar {
  grid-area: sidebar;
}
.content {
  grid-area: content;
}
footer {
  grid-area: footer;
}

.container {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-areas:
    'header header header header'
    'sidebar content content content'
    'sidebar footer footer footer';
}
```

To leave white space on the grid use a . or multiples with no white space between them.

grid-template-areas property relates to writing-mode and direction.

### Shorthand properties

The grid-template property is a shorthand for grid-template-rows, grid-template-columns and grid-template-areas. The rows are defined first, along with the value of grid-template-areas. Column sizing is added after a /.

```css
.container {
  display: grid;
  grid-template:
    'head head head' minmax(150px, auto)
    'sidebar content content' auto
    'sidebar footer footer' auto / 1fr 1fr 1fr;
}
```

The grid shorthand can be used in exactly the same way as the grid-template shorthand. The full set being grid-template + grid-auto-rows, grid-auto-columns, grid-auto-flow.

### Alignment

If your item is an image, or something else with an intrinsic aspect ratio, the initial value of justify-self and align-self will be start rather than stretch to avoid stretching things out of shape.

auto-fill places as many items into the template as possible, without stretching. Fit makes them fit. fill이 아니라 fit이 채우는거라는게 헷갈리네.

## Logical Properties

> Logical, flow relative properties and values are linked to the flow of text, rather than the physical shape of the screen. Learn how to take advantage of this newer approach to CSS.

Among many other benefits, they provide free, automatic support for internationalization.

Block flow is the direction in which content blocks are placed.

The inline flow is how text flows in a sentence.

block-start, block-end, inline-start, inline-end

max-inline-size, max-block-size

text direction 관련해서는 start와 end가 있다.

```css
.my-element {
  padding-block-start: 2em;
  padding-block-end: 2em;
  margin-inline-start: 2em;
  position: relative;
  inset-block-start: 0.2em;
}

/* shorthand */
.my-element {
  padding-block: 2em;
  margin-inline: 2em 0;
  position: relative;
  inset-block: 0.2em 0;
}
```

The inset CSS property is a shorthand that corresponds to the top, right, bottom, and/or left properties. - MDN

border도 마찬가지로 가능. border-block-end...

Logical properties bring two new units: **vi** and **vb**. A vi unit is 1% of the viewport size in the inline direction. The non-logical property equivalent is vw. The vb unit is 1% of the viewport in the block direction. The non-logical property equivalent is vh.

### Using logical properties pragmatically

Internationalization과 다른 목적으로도 사용할 수 있다. 예를 들어, 방향이 달라도 같은 margin-block-start를 사용할 수 있다.

## Spacing

> Find out how to select the best method of spacing elements, taking into consideration the layout method you are using and component that you need to build.

There are many ways to adjust spacing within a UI, each with its own strengths and caveats.

### HTML spacing

If you use a <br> element, it will create a line-break.

The <hr> creates a horizontal line with space either-side, known as margin.

Use HTML elements to add space only when the element helps with the understanding of the document. For example, an <hr> doesn't just add space, it creates a logical separation of two chunks of content. If you just want a line with space around it, adding a border with CSS might be more appropriate.

### Margin

Margin is like adding a cushion around your element.

top-right-bottom-left 순서. You can remember these with trouble: TRouBLe.

Three values: the first value is top, the second value is left and right, and the third value is bottom. (margin: 20px 40px 30px).

For block level elements with a restricted size, an **auto margin** will take up available space in the direction that it is applied to.

```css
/* horizontally centered wrapper */
.wrapper {
  max-width: 400px;
  margin: 0 auto;
}
```

Negative values will reduce space between them.

```html
<body>
  <div class="wrapper">
    <article class="flow">
      <div class="demo flow">
        <h1>My heading with teal margin</h1>
        <p>A paragraph of text that has margin on it. The margin is blue so you can see it.</p>
      </div>
      <label>
        Set heading’s bottom margin
        <input
          type="range"
          value="2"
          min="0"
          max="10"
        />
      </label>
    </article>
  </div>

  <script>
    const slider = document.querySelector('[type="range"]');
    const demo = document.querySelector('.demo');

    slider.addEventListener('input', ({ target }) =>
      demo.style.setProperty('--heading-margin', `${target.value}rem`)
    );
  </script>
</body>

<style>
  h1 {
    margin-bottom: 2rem;
    position: relative;
  }

  p {
    margin-top: 3rem;
    position: relative;
    padding: 0.5rem;
  }

  /* Presentational styles */

  h1::before,
  p::before {
    content: '';
    display: block;
    width: 100%;
    position: absolute;
    left: 0;
  }

  h1::before {
    height: 2rem;
    top: 100%;
    background: #00c9db;
  }

  p::before {
    bottom: 100%;
    height: 3rem;
    background: #3740ff;
  }
</style>
```

**Margin collapse** works by selecting the largest value of two adjoining elements with vertical margin set on the adjoining sides.

This behavior is rooted back to when the web was mostly just documents. Collapsing margins help to set consistent spacing between elements without accidentally creating huge gaps between elements that also have margin defined.

Margin collapse also helps with empty elements. If you have a paragraph that has a top and bottom margin of 20px, it will only create 20px of space: not 40px.

If you make an element **absolutely positioned**, using position: absolute, the margin will no longer collapse. Also float property.

[Everything You Need To Know About CSS Margins](https://www.smashingmagazine.com/2019/07/margins-in-css/) The margin on the child collapses with any margin on the parent thus ending up on the outside of the parent. If we add a border to the parent, the margins on the children stay inside. It is worth remembering that margins only collapse in the block direction, such as between paragraphs. Margins never collapse if an item has absolute positioning, or is floated. Give the wrapper display: flow-root, thus creating a new BFC, the margins stay inside. Flex and Grid containers establish Flex and Grid formatting contexts for their children, so they have different behavior to block layout. One of those differences is that margins do not collapse. The simplest way to dealing with margin collapsing is to... [only define margins on the top or bottom of elements](https://csswizardry.com/2012/06/single-direction-margin-declarations/).

[Understanding CSS Layout And The Block Formatting Context](https://www.smashingmagazine.com//2017/12/understanding-css-layout-block-formatting-context/)

```html
<body>
  <div class="outer">
    <div class="float">I am a floated element.</div>
    I am text inside the outer box.
  </div>
</body>

<style>
  .outer {
    border: 5px dotted rgb(214, 129, 137);
    border-radius: 5px;
    width: 450px;
    padding: 10px;
    margin-bottom: 40px;
  }

  .float {
    padding: 10px;
    border: 5px solid rgba(214, 129, 137, 0.4);
    border-radius: 5px;
    background-color: rgba(233, 78, 119, 0.4);
    color: #fff;
    float: left;
    width: 200px;
    margin: 0 20px 0 0;
  }
</style>
```

This happens because when we float an element, the box that the text is in remains the same width, what is shortened to make space for the floated element are the line boxes of the text. This is why backgrounds and borders will appear to run behind our float??

```css
/* 해결책 */
.outer {
  overflow: auto;
}
```

The reason overflow works in this way is that using any value other than the initial value of _visible_ creates a Block Formatting Context, and one of the features of a BFC is that it contains floats.

You can think of a BFC as like a mini layout inside your page. Once an element creates a BFC, everything is contained inside it.

The BFC prevents margins collapsing.

A BFC stops content wrapping floats.

What would be useful would be a method of creating a BFC that is otherwise inert, causing no other behavior but to create that mini layout, and the ability for things to happen inside it safely. That method would not cause any unexpected issues and also allow clarity in terms of what the developer intended. The CSS Working Group thought that might be pretty handy too, and so we have a new value of the display property - **display: flow-root**.

[mdn - Block formatting context](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context). It's the region in which the layout of block boxes occurs and in which floats interact with other elements.

### Padding

The padding property creates space on the inside of your box instead: like insulation.

### Grid and flexbox

Lastly, in both grid and flexbox you can use the gap property to create space between child elements. The gap property is shorthand for row-gap and column-gap, it accepts one or two values, which can be lengths or percentages.

### Creating consistent spacing

```css
/* Tokenize values */
:root {
  --gutter: 20px;
  --spacing: 1em;
}

h1 {
  margin-left: var(--gutter);
  margin-top: var(--spacing);
}
```

## Pseudo-elements

> A pseudo-element is like adding or targeting an extra element without having to add more HTML. They have a variety of roles and you can learn about them in this module.

```html
<body>
  <p>
    Drop caps are a great way to introduce an article of content and they look great. Integer
    posuere erat a ante venenatis dapibus posuere velit aliquet. Donec sed odio dui. Curabitur
    blandit tempus porttitor.
  </p>
</body>

<style>
  p {
    width: 50ch;
  }
  p::first-letter {
    color: #0c55ff;
    float: left;
    font-size: 2em;
    font-weight: bold;
    line-height: 1;
    margin-inline-end: 0.2rem;
  }
</style>
```

::before과 ::after는 content 프로퍼티가 있을 때만 작동한다. 빈 문자열도 가능.

[counter](https://developer.mozilla.org/en-US/docs/Web/CSS/counter)란 것도 있고 이걸 넣을 수 있다고 함.

You can only insert a ::before or ::after element to an element that will accept child elements (elements with a document tree), so elements such as <img />, <video> and <input> won't work. input[type="checkbox"] is an exception.

::first-line

If you have an element that is presented in full screen mode, such as a <dialog> or a <video>, you can style the backdrop—the space between the element and the rest of the page—with the **::backdrop** pseudo-element:

::marker, ::selection, ::placeholder

::cue pseudo-element allows you to style the WebVTT cues, which are the captions of a <video> element.

Pseudo-elements can be targeted by CSS but won't be found in the HTML.

## Pseudo-classes

> Pseudo-classes let you apply CSS based on state changes. This means that your design can react to user input such as an invalid email address.

### Interactive states

:hover

:active - This state is triggered when an element is actively being interacted with— such as a click—before click is released.

:focus, :focus-within, :focus-visible

You can also react if a child element of your element receives focus with :focus-within.

With :focus-visible you can present a focus style when an element receives focus via the keyboard, while also using the outline: none rule to prevent it when a pointer device interacts with it.

```html
<body>
  <button class="button">Use your tab key to focus this button</button>
  <div class="helper">Click this button for a surprise</div>
  <p>사파리에서는 안되는듯?</p>
</body>

<style>
  .helper {
    display: none;
  }

  /* body가 생략된건가?? 뭐지 */
  :focus-within .helper {
    display: block;
  }

  .button:focus {
    outline-offset: 2px;
    background-color: black;
  }

  .button:focus-visible {
    outline: 2px dashed blue;
  }

  .helper {
    font-weight: bold;
    padding: 0.5rem 0;
  }
</style>
```

```html
<body>
  <p>
    <a
      href="#recipe"
      class="button"
      >Skip to the recipe</a
    >
  </p>
  <p>
    Here are several paragraphs of back-story: Fusce dapibus, tellus ac cursus commodo, tortor
    mauris condimentum nibh, ut fermentum massa justo sit amet risus.
  </p>
  <h2 id="recipe">Here is the actual recipe</h2>
  <p>
    Morbi leo risus, porta ac consectetur ac, vestibulum at eros. Donec sed odio dui. Donec id elit
  </p>
  <p>
    Morbi leo risus, porta ac consectetur ac, vestibulum at eros. Donec sed odio dui. Donec id elit
  </p>
</body>

<style>
  /* This highlights the <h2> for the recipe and every element that follows it */
  #recipe:target,
  #recipe:target ~ * {
    background: lightgoldenrodyellow;
  }

  h2 {
    display: inline-block;
  }

  h2,
  p {
    padding: 0.25em;
  }

  body {
    width: 30ch;
  }
</style>
```

### Historic states

:link는 아직 방문 안한 a 태그, :visited는 방문한거. [Privacy and the :visited selector](https://developer.mozilla.org/en-US/docs/Web/CSS/Privacy_and_the_:visited_selector)

If you define a :visited style, it can be overridden by a link pseudo-class with at least equal specificity. Because of this, it's recommended that you use the **LVHA** rule for styling links with pseudo-classes in a particular order: :link, :visited, :hover, :active.

### Form states

:disabled, :enabled

:checked, :indeterminate. Checkboxes do have an in-between state when they are neither checked or unchecked. This is known as the :indeterminate state. 모두 선택 버튼이 예시. 모두 선택했다가 하나 선택 해제하면 모두 선택 버튼은 indeterminate 상태가 된다.

:placeholder-shown

:valid, :invalid, :in-range

The :in-range pseudo-class is available if an input has a min and max, such as a numeric input and the value is within those bounds.

:required, :optional. 반대.

```html
<!-- required 없으면 항상 valid인듯 -->
<body>
  <form>
    <label for="email">Email address</label>
    <input
      type="email"
      id="email"
      required
      placeholder="A valid email, like name@domain.com"
      aria-describedby="emailinfo"
    />
  </form>
</body>

<style>
  input:invalid {
    border-color: red;
  }

  input:valid {
    border-color: green;
  }

  input {
    min-width: 320px;
    padding: 0.5rem 1rem;
    line-height: 1;
    font: inherit;
    border: 2px solid gray;
    border-radius: 0.25rem;
  }

  input:focus {
    outline: none;
  }
</style>
```

### Selecting elements by their index, order and occurrence

:first-child, :last-child, :only-child

:first-of-type, :last-of-type

:nth-child, :nth-of-type

:nth-child(even)도 된다! An+B 형식도 된다! 3n+3은 3에서 시작한다. n이 0부터 시작.

:only-of-type. This is useful if you want to select lists with only one item, or if you want to find the only bold element in a paragraph.

### Finding empty elements

:empty. If an element has no children.

The :empty pseudo-class can be useful if you have little control over the HTML and want to hide empty elements, such as a WYSIWYG content editor.

### Finding and excluding multiple elements

:is()

```css
.post h2,
.post li,
.post img {
	…
}

.post :is(h2, li, img) {
	…
}
```

The :is pseudo-class is not only more compact than a selector list but it is also more forgiving. In most cases, if there's an error or unsupported selector in a selector list, the entire selector list will no longer work. If there's an error in the passed selectors in an :is pseudo-class, it will ignore the invalid selector, but use those which are valid.

:not(). Exclude items.

## Borders

> A border provides a frame for your boxes. In this module find out how to change the size, style and color of borders using CSS.

### Border properties

border-style: dotted, dashed, solid, double, groove, ridge, inset, outset.

border-top-style, border-right-style...

border: border-width border-style border-color

border-width: thin, medium, thick, length unit

border-top-width, border-right-width...

### Logical properties

border-inline-end etc...

Browser support is varied for logical properties in borders, so make sure you check support before using.

### Border radius

border-radius, border-top-left-radius, border-top-right-radius, border-bottom-right-radius and border-bottom-left-radius.

Shorthand. border-radius topleft topright bottomright bottomLeft

By defining a single value for a corner, you are using another shorthand because a border radius is split into two parts: the vertical and horizontal sides. This means that when you set border-top-left-radius: 1em, you are setting the top-left-top radius and the top-left-left radius.

This converts the border radius into an elliptical radius, rather than the default circle radius.

```html
<body>
  <div class="my-element"></div>
</body>

<style>
  .my-element {
    border: 2px solid;
    /* border-top-left-radius: 1em 2em; */
    border-radius: 95px 155px 148px 103px / 48px 95px 130px 203px;
  }

  /* Presentational styles */
  .my-element {
    width: 250px;
    height: 250px;
  }
</style>
```

You can define these values in the border-radius shorthand, using a / to define the elliptical values, after the standard values.

### Border image

```html
<body>
  <div class="my-element"></div>
</body>

<style>
  .my-element {
    border: 1px solid;
    border-image-slice: 61 58 51 48;
    border-image-width: 20px 20px 20px 20px;
    border-image-outset: 0px 0px 0px 0px;
    border-image-repeat: stretch stretch;
    border-image-source: linear-gradient(to bottom, #000, #fff);
  }

  /* Presentational styles */
  .my-element {
    width: 300px;
    height: 150px;
  }
</style>
```

어려운데 필요하면 다시보자.

## Shadows

> There are a number of ways to add shadows to text and elements in CSS. In this module you'll learn how to use each option, and the tasks they were designed for.

### Box shadow

The box-shadow property is for adding shadows to the box of an HTML element.

```css
.my-element {
  box-shadow: 5px 5px 20px 5px #000;
}
```

Horizontal offset, Vertical offset, Blur radius, Spread radius(optional), Color

A larger spread radius increases the size of the shadow and a smaller number decreases it.

To make a box shadow an inner shadow, rather than the default outer shadow, add an **inset** keyword before the other properties.

You can add as many shadows as you like with box-shadow.

Adding a border-radius to your box will also affect the shape of the box shadow. This is because CSS is creating a shadow **based on the shape of the box** as if light is pointing at it.

If your box with box-shadow is in a container that has overflow: hidden, the shadow won't break out of that overflow either.

### Text shadow

The text-shadow property is very similar to the box-shadow property. It only works on text nodes. The only difference is that text-shadow has no spread value and no inset keyword.

If your text is fully or semi transparent, the shadow is visible through it.

You can add as many shadows as you like with text-shadow, just as with box-shadow.

### Drop shadow

To achieve a drop shadow that follows any potential curves of an image, use the CSS drop-shadow filter. This shadow is applied to an alpha mask which makes it very useful for adding a shadow to a cutout image.

The drop-shadow filter has the same values as box-shadow but the inset keyword and spread value are not allowed.

You can add as many shadows as you like. Each shadow will use the last shadow as a positioning reference point??

```html
<body>
  <figure>
    <img
      src="https://assets.codepen.io/174183/isolated-tshirt.png?width=1200&format=auto&quality=60"
      alt="A white t-shirt, isolated, on a hanger"
    />
    <figcaption>A cool, white t-shirt</figcaption>
  </figure>
</body>

<style>
  figure {
    max-width: 50%;
    background: #718093;
    border-radius: 0.5em;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1rem;
  }

  figcaption {
    color: white;
    font-style: italic;
    text-align: center;
  }

  figure img {
    max-width: 100%;
    filter: drop-shadow(0px 0px 20px hotpink) drop-shadow(10px 10px 20px blue);
  }
</style>
```

## Focus

Understand the importance of focus in your web applications. You'll find out how to manage focus, and how to make sure the path through your page works for people using a mouse, and those using the keyboard to navigate.

### Why is focus important?

As a web developer, it's your job to make a website accessible and inclusive to all. Creating accessible focus states with CSS is a part of this responsibility.

### How elements get focus

All form elements, buttons and links. You can typically navigate a website's focusable elements using the tab key to move forward on the page, and shift + tab to move backward.

There is also a HTML attribute called **tabindex** which allows you to change the tabbing index—which is order in which elements are focused—every time someone presses their tab key, or focus is shifted with a hash change in the URL or by a JavaScript event.

If you set tabindex to **-1**, it can only receive focus programmatically, which means only when a JavaScript event happens or a hash change (matching the element's id in the URL) occurs

If you set tabindex to be anything higher than 0, it will be removed from the global tab index, defined by document source order. Tabbing order will now be defined by the value of tabindex.

Focus order should only be changed if you **absolutely have to change it**.

### Styling focus

Default browser behavior can be changed with CSS, using the :focus, :focus-within and :focus-visible pseudo-classes that you learned about in the pseudo-classes lesson

### In summary

- Avoid using outline: none on an element that can receive keyboard focus.
- Avoid replacing outline styles with box-shadow. as they don't show up in Windows High Contrast Mode.
- Only set a positive value for tabindex on an HTML element if you absolutely have to.
- Make sure the focus state is very clear vs the default state.

## Z-index and stacking contexts

> In this module find out how to control the order in which things layer on top of each other, by using z-index and the stacking context.

### Z-index

This is the axis which shows which layers are closer to and further from you.

The z-index property accepts a numerical value which can be a positive or negative number. Elements will appear above another element if they have a higher z-index value. If no z-index is set on your elements then the default behaviour is that document source order dictates the Z axis.

If you set a specific value for z-index and it isn't working, you need to set the element's position value to anything other than static.

### Negative z-index

To set an element behind another element, add a negative value for z-index.

```html
<body>
  <div class="my-element">
    <div class="child">I am behind my parent</div>
  </div>
</body>

<style>
  .my-element {
    background: rgb(232 240 254 / 0.5);
    border: 1px solid lightblue;

    /* Decorative styles */
    /* flex면 overflow가 안되는듯. 새로운 context 어쩌구. */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    width: 250px;
    height: 250px;

    /* Because .my-element now has a position value that's not static 
    and a z-index value that's not auto, 
    it has created a new stacking context.  */
    position: relative;
    z-index: 0;
  }

  .child {
    position: relative;
    z-index: -999;

    background: pink;
    border: 1px solid hotpink;
    padding: 1rem;
    width: 275px;
  }
</style>
```

### Stacking context

A stacking context is a group of elements that have a common parent and move up and down the z axis together.

### Creating a stacking context

You can create a new stacking context by adding a value for properties which create a new composite layer such as opacity, will-change and transform.

To explain what a composite layer is, imagine a web page is a canvas. A browser takes your HTML and CSS and uses these to work out how big to make the canvas. It then paints the page on this canvas. If an element was to change—say, it changes position—the browser then has to go back and re-work out what to paint.

To help with performance, the browser creates new composite layers which are layered on top of the canvas. These are a bit like post-it notes: moving one around and changing it doesn't have a huge impact on the overall canvas.

Using z-index inside a flexbox or grid layout will work without position: relative.

## Functions

> CSS has a range of inbuilt functions. In this module you will find out about some of the key functions, and how to use them.

## Gradients

> In this module you will find out how to use the various types of gradients available in CSS. Gradients can be used to create a whole host of useful effects, without needing to create an image using a graphics application.

## Animations

> Animation is a great way to highlight interactive elements, and add interest and fun to your designs. In this module find out how to add and control animation effects with CSS.

In animation software, CSS, and most other tools that enable you to animate something, **keyframes** are the mechanism that you use to assign animation states to timestamps, along a timeline.

```html
<body>
  <div class="pulser"></div>
</body>
<style>
  /* custom ident(identifier) */
  /* lets you reference the keyframes rule elsewhere in your CSS code. */
  @keyframes pulse {
    0% {
      opacity: 0;
    }
    50% {
      transform: scale(1.4);
      opacity: 0.4;
    }
  }

  .pulser {
    width: 30px;
    height: 30px;
    background: rebeccapurple;
    border-radius: 50%;
    position: relative;
  }

  .pulser::after {
    animation: pulse 1000ms cubic-bezier(0.9, 0.7, 0.5, 0.9) infinite;

    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    background: blueviolet;
    border-radius: 50%;
    z-index: -1;
  }
</style>
```

To use your @keyframes in a CSS rule, define various animation properties or, use the `animation` shorthand property.

animation-duration / animation-timing-function(linear, ease, ease-in, ease-out, ease-in-out) /

Values appear to curve with easing functions because easing is calculated using a **bézier curve**, which is used to model velocity.

```css
.my-element {
  animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1);
}
```

The steps() easing function lets you break the timeline into defined, equal intervals.

The animation-iteration-count property defines how many times the @keyframes timeline should run.

You can set which direction the timeline runs over your keyframes with animation-direction.

The animation-delay property defines how long to wait before starting the animation.

The animation-play-state property allows you to play and pause the animation.

The animation-fill-mode property defines which values in your @keyframes timeline persist before the animation starts or after it ends.

## Filters

> Filters in CSS mean that you can apply effects you might only think possible in a graphics application. In this module, you can discover what is available.

## Blend Modes

> Create compositional effects by mixing two or more layers, and learn how to isolate an image with a white background in this module on blend modes.

## Lists

> A list, structurally, is composed of a list container element filled with list items. In this module, you'll learn how to style all the parts of a list.

## Transitions

> In this module, learn how to define transitions between states of an element. Use transitions to improve user experience by providing visual feedback to user interaction.

## Overflow

> Overflow is how you deal with content that doesn’t fit in a set parent size. In this module, you’ll think outside the box, and learn how to style overflowing content.

There are two different clipping options in CSS; text-overflow will help with individual lines of text, and the overflow properties will help control overflow in the box model.

The overflow-y property controls physical overflow along the vertical axis of the device viewport, therefore scrolling up and down.

The overflow-x property similar.

overflow-inline and overflow-block is logical properties for scroll direction.

The overflow shorthand sets both overflow-x and overflow-y styles in one linㄷ.

visible / hidden / scroll / clip / auto

In scroll, scrollbars will be present even if content isn't currently overflowing.

The difference between clip and hidden is that the clip keyword also forbids all scrolling, including programmatic scrolling.

auto respects the user's preferences and shows scrollbars if needed, but hides them by defualt, and gives responsibility for scrolling to the user and browser.

It's important to make sure that the scrollable area can accept focus so that a keyboard user can tab to the box, then use the arrow keys to scroll. To allow a scrolling box to accept focus add tabindex="0", a name with the aria-labelledby attribute, and an appropriate role attribute. For example:

```html
<div
  tabindex="0"
  role="region"
  aria-labelledby="id-of-descriptive-text"
>
  content
</div>
```

[Using CSS to Enforce Accessibility](https://adrianroselli.com/2021/06/using-css-to-enforce-accessibility.html)

Scroll bars take up space within the padding box and 'can compete for space if inline and not overlayed'??

You may notice that some scrollers have a pull-to-refresh behavior and other special behaviors, especially when developing for mobile and hybrid applications. This scroll behavior happens on the root scroller. There is only ever one root scroller on a page.

However, by changing which element is the root scroller, the special behaviors can be applied to scrollers other than the documentElement, we call this new scroller the **implicit root scroller**.

To create a root scroller, you can use something called **scroller promotion** by positioning a container as fixed, ensuring it covers the entire viewport and is z-index on top with a scroller. 예시 링크는 사파리에서는 안됨. 크롬에서는 되는 듯.

scroll-behavior allows you to opt into browser-controlled scrolling to elements.

```css
@media (prefers-reduced-motion: no-preference) {
  .scroll-view {
    scroll-behavior: auto;
  }
}
```

The overscroll-behavior property allows you to prevent overflow scrolling leaking into a parent container (called scroll chaining).

Text overflow is generally about inline overflow, where element overflow is about block overflow.

Almost always, when passing two shorthand values, the first is horizontal.

Scrollbars in overlay mode will overlap the padding, and when in inline mode will add to the padding.

## Backgrounds

> In this module learn the ways you can style backgrounds of boxes using CSS.

Behind every CSS box is a specialized layer called the background layer.

Background layers are furthest from the user, rendered behind the contents of a box starting from its padding-box region. This enables the background layer to not overlap with borders at all.

background-color.

On top of the background-color layer, you can add a background image, using the background-image property.

Several gradient CSS functions exist to allow you to generate a background-image.

```html
<body>
  <div class="demo-box linear-gradient"></div>
  <span class="demo-label">Linear gradient</span>

  <div class="demo-box radial-gradient"></div>
  <span class="demo-label">Radial gradient</span>

  <div class="demo-box conic-gradient"></div>
  <span class="demo-label">Conic gradient</span>
</body>

<style>
  .demo-box {
    border: 0.5px solid hsla(0deg, 0%, 60%, 0.5);
    aspect-ratio: 1/1;
    width: 10%;
  }

  .linear-gradient {
    background-image: linear-gradient(rebeccapurple, teal);
  }

  .radial-gradient {
    background-image: radial-gradient(teal, rebeccapurple);
  }

  .conic-gradient {
    background-image: conic-gradient(rebeccapurple, teal, green, blue, purple);
  }
</style>
```

Change how background images repeat to fill the entire space of the background layer. repeat / round / space. 나중에 필요하면 찾아보자.

The background-position property allows you to offsetting the image position. The background-position property also has a convenient one value shorthand; the omitted value resolves to 50%.

```css
img {
  background-position: top;
  background-position: top left;
}
```

The background-size property sets the size of background images. auto/cover/contain. When auto is used alongside another CSS value for the width or height, the dimension set to auto is sized as needed to maintain the natural aspect ratio of the image.

The background-attachment property enables you to modify the fixed position behavior of background images (images part of a background layer) once the layer is visible on a screen. scroll/fixed/local. 오 fixed로 이런 효과를 얻을 수 있구나.

```html
<body class="wrapper">
  <div id="demoBox"></div>
  <p>
    Croissant cotton candy apple pie cheesecake cake. Chocolate cake carrot cake cupcake tart
    jelly-o croissant tiramisu biscuit pie. Tart danish danish danish tart icing chocolate chupa
    chups. Chupa chups caramels gummi bears jujubes biscuit cheesecake cheesecake. Chocolate
    marzipan danish shortbread fruitcake jelly beans macaroon tootsie roll candy. Candy canes
    jelly-o topping jujubes lollipop gummies apple pie lollipop fruitcake.
  </p>
</body>

<style>
  #demoBox {
    aspect-ratio: 16/9;
    /* have background-size be within reason within the bounds of box but still allow regular tiling to occur on applicable images */
    background-image: url('https://images.unsplash.com/photo-1529673203658-56306382b724?auto=format&fit=crop&w=1000&q=80&ar=16:9');
    background-size: cover;
    background-attachment: fixed;
  }

  body {
    width: 50ch;
  }

  p {
    font-size: 50px;
  }
</style>
```

The local keyword enables the position of background images to be fixed relative to the element's contents.

The background-origin property enables you to modify the area of backgrounds associated with a particular box. border-box, content-box, padding-box.

The background-clip property controls what is visually seen from a background layer regardless of the bounds created by the background-origin property. border-box, content-box, padding-box, text.

```html
<body>
  <div id="demoBox">CSS</div>
</body>

<style>
  #demoBox {
    aspect-ratio: 1/1;
    border: 0.5px solid hsla(0deg, 0%, 60%, 0.5);
    padding: 1rem;

    font-size: 10rem;
    font-weight: bold;

    background-image: url('https://images.unsplash.com/photo-1567095761054-7a02e69e5c43?auto=format&fit=crop&w=690&q=80');
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }
</style>
```

It should be also noted this property is not compatible with background-clip: text being simultaneously set on a CSS box??

The background layer allows multiple sublayers to be defined from top to bottom. Setting a background-color on the final layer ensures good contrast for text and so on if important background layers fail to load.

Background images are repeated by default.

## Text and typography

The font-familty property accepts specific or generic(serif, sans-serif...) font families.

When using font-family, you should specify at least one generic font family in case the user’s browser doesn’t have your preferred fonts.

font-style. normal/italic/oblique. Oblique displays a slanted version of regular typeface.

Use font-weight to set the “boldness” of text. This property accepts keyword values (normal, bold), relative keyword values (lighter, bolder), and numeric values (100 to 900). Relative values are relative to the parent elements' property.

Most fonts, especially the "web-safe" ones, only support the weights 400 (normal) and 700 (bold). Non-variable fonts only support numeric values for font-weight in the 100s, e.g. 100, 200, 300, etc. If you want to use font-weight: 321 (for example), you’ll have to use a Variable Font.

Use font-size to control the size of your text elements. Accepts some absolute keyword values like xx-small, x-small.

Use line-height to specify the height of each line in an element. Generally, it's recommended to use a number instead of a length or percentage.

Use letter-spacing to control the amount of horizontal space between characters in your text.

Use word-spacing to increase or decrease the length of space between each word in your text. word-spacing: 0 is equivalent to word-spacing: normal.

Check out [MDN’s font article](https://developer.mozilla.org/docs/Web/CSS/font#syntax) for the specifics of how to order properties in font shorthand.

Use text-transform to modify the capitalization of your text without needing to change the underlying HTML. This property accepts uppercase, lowercase, and capitalize keywords.

Use text-decoration to add lines to your text. The text-decoration property is shorthand for the more specific properties detailed below(왜 안되나 했는데 safari에서는 thickness가 포함 안되어있는듯). text-decoration-line property accepts underline, overline, and lint-through. You can also specifiy multiple keywords

```html
<body>
  <p>text-decoration-line</p>
</body>

<style>
  p {
    text-decoration-line: underline overline line-through;
    text-decoration-color: aqua;
  }
</style>
```

The text-decoration-color property sets the color of all decorations from text-decoration-line. Accepts solid, double, dottes, dashed, wavy.

The text-decoration-thickness property accepts any length values and sets the stroke width of all decorations from text-decoration-line.

Use text-underline-position to offset the underline of a text-decoration: underline by the specified amount. This property doesn’t work for overline or line-through.

Use text-indent to add an indent to your blocks of text.

Use text-overflow to specify how hidden content is represented. clip and ellipsis allowed.

The white-space property is used to specify how whitespace in an element should be handled. For more details, check out MDN article.

Use word-break to change how words should be “broken” when they would overflow the line.

Use text-align to specify the horizontal alignment of text in a block or table-cell element.

Use direction to set the direction of your text, either ltr (left to right, the default) or rtl (right to left). Generally, you should favor using the HTML attribute dir instead of direction.

Use writing-mode to change the way text flows and is arranged.

```html
<body>
  <div>
    <p class="A">가나다라마바사아</p>
  </div>
  <div>
    <p class="B">가나다라마바사아</p>
  </div>
  <div>
    <p class="C">가나다라마바사아</p>
  </div>
  <div>
    <p class="D">가나다라마바사아</p>
  </div>
  <div>
    <p class="E">가나다라마바사아</p>
  </div>
  <div>
    <p class="F">가나다라마바사아</p>
  </div>
</body>

<style>
  div {
    width: 10ch;
    height: 10ch;
    border: 1px solid gray;
    margin: 1ch;
  }
  p {
    margin: 0;
  }
  .A {
    direction: ltr;
  }
  .B {
    direction: rtl;
  }

  .C {
    writing-mode: vertical-rl;
  }
  .D {
    writing-mode: vertical-lr;
  }

  .E {
    direction: rtl;
    writing-mode: vertical-rl;
  }
  .F {
    direction: rtl;
    writing-mode: vertical-lr;
  }
</style>
```

Use text-orientation to specify the orientation of characters in your text. The valid values are mixed and upright. This property is only relevant when writing-mode is set to something other than horizontal-tb.

Use text-shadow to add a shadow to your text. This property expects three lengths (x-offset, y-offset, and blur-radius) and a color. Check out the module on Shadows.

Variable fonts are fonts that can contain many different variants of a typeface in one file. [Introduction to variable fonts on the web](https://web.dev/variable-fonts/)

The font-variant property is a shorthand for a number of CSS properties that let you choose font variants like small-caps and slashed-zero. The CSS properties this shorthand includes are font-variant-alternates, font-variant-caps, font-variant-east-asian, font-variant-ligatures, and font-variant-numeric.

[Best practices for fonts](https://web.dev/font-best-practices/)

## Conclusion and next steps

pass
