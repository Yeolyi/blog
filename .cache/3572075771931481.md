
> React is a JavaScript library for rendering user interfaces (UI).

### Your First Component

You can even jumpstart your project with the thousands of components shared by the React open source community like [Chakra UI](https://chakra-ui.com/) and [Material UI](https://material-ui.com/).

> a React component is a JavaScript function that you can sprinkle with markup.

React components are regular JavaScript functions, but their names must start with a capital letter or they won’t work!

소문자로 시작하면 HTML 태그로 간주되는 듯?

<img /> is written like HTML, but it is actually JavaScript under the hood!

return과 다른 줄에 있으면 괄호를 반드시 붙여야 한다.

[What are the rules for JavaScript's automatic semicolon insertion (ASI)?](https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi)

... React-based frameworks take this a step further. Instead of using an empty HTML file and letting React “take over” managing the page with JavaScript, they also generate the HTML automatically from your React components. This allows your app to show some content before the JavaScript code loads.

```
export default function Gallery() {
    // 🔴 Never define a component inside another component!
    function Profile() {

    }
    // The snippet above is very slow and causes bugs. Instead, define every component at the top level:
}
```

### Importing and Exporting Components

If you use a framework with file-based routing, such as Next.js, your root component will be different for every page.

Either './Gallery.js' or './Gallery' will work with React, though the former is closer to how native ES Modules work.

A file can have no more than one default export, but it can have as many named exports as you like. ... People often use default exports if the file exports only one component, and use named exports if it exports multiple components and values.

### Writing Markup with JSX

But as the Web became more interactive, logic increasingly determined content. JavaScript was in charge of the HTML! This is why in React, **rendering logic and markup live together** in the same place—components.

JSX and React are two separate things. They’re often used together, but you [can use them independently](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html#whats-a-jsx-transform) of each other. JSX is a syntax extension, while React is a JavaScript library.

React Fragment - JSX looks like HTML, but under the hood it is transformed into plain JavaScript objects. You can’t return two objects from a function without wrapping them into an array. This explains why you also can’t return two JSX tags without wrapping them into another tag or a fragment.

JSX turns into JavaScript and attributes written in JSX become keys of JavaScript objects.

### Javascript in JSX with Curly Braces

The [Intl](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl) namespace object contains several constructors as well as functionality common to the internationalization constructors and other language sensitive functions.

Inline style properties are written in camelCase.

### Passing Props to a Component

ReactDOM conforms to [the HTML standard](https://html.spec.whatwg.org/multipage/embedded-content.html#the-img-element).

React components use props to communicate with each other.

> Props are the information that you pass to a JSX tag.

... in fact, props are the only argument to your component! React component functions accept a single argument, a props object:

```jsx
function Avatar(props) {
  let person = props.person;
  let size = props.size;
  // ...
}
```

Usually you don’t need the whole props object itself, so you **destructure** it into individual props.

기본값은 null이나 0을 전달하면 사용되지 않는다.

```jsx
// 다른 방법으로 전달하는건 없나?
// 단순 궁금한건데, 꼭 spread를 써야되나싶어서
// props를 복붙하는게 아니라 props 객체 그대로 전달은 안되나
// 참조로 전달한다음에 바뀌면 좀 그래서 그런가
function Profile(props) {
  return (
    <div className="card">
      <Avatar {...props} />
    </div>
  );
}
```

Use spread syntax with restraint. If you’re using it in every other component, something is wrong. Often, it indicates that you should split your components and pass children as JSX.

When you nest content inside a JSX tag, the parent component will receive that content in a prop called children

Props are immutable. When a component needs to change its props, it will have to “ask” its parent component to pass it different props - a new object. **Don’t try to “change props”.**

-> 그래서 위에 코드에서도 spread로 전달한건가?? 근데 굳이 강제를 해야되나

Props are read-only snapshots in time: every render receives a new version of props.

### Conditional Rendering

In practice, returning null from a component isn’t common because it might surprise a developer trying to render it. More often, you would conditionally include or exclude the component in the parent component’s JSX.

... But JSX elements aren’t “instances” because they don’t hold any internal state and aren’t real DOM nodes. They’re lightweight descriptions, like blueprints. 따라서 if...else에서 각각 반환하는 객체는 최종적으로 완전히 동일하다.

<del>Component</del>에서 del을 없앴다 넣어도 Component의 state가 보존되나?

React considers false as a “hole” in the JSX tree, just like null or undefined, and doesn’t render anything in its place.

Don’t put numbers on the left side of &&. For example, a common mistake is to write code like messageCount && <p>New messages</p>.

### Rendering Lists

JSX elements directly inside a map() call always need keys. A well-chosen key helps React infer what exactly has happened, and make the correct updates to the DOM tree.

```jsx
import { Fragment } from 'react';

// 각 리스트의 아이템이 여러 DOM 노드들을 렌더해야할 떄.
// <></>에는 키 값을 넣을 수 없다.
const listItems = people.map((person) => (
  <Fragment key={person.id}>
    <h1>{person.name}</h1>
    <p>{person.bio}</p>
  </Fragment>
));
```

If your data is generated and persisted locally (e.g. notes in a note-taking app), use an incrementing counter, crypto.randomUUID() or a package like uuid when creating items.

Index as a key often leads to subtle and confusing bugs. Not only is this slow, but it will also lose any user input inside the list items.

Note that your components won’t receive key as a prop. It’s only used as a hint by React itself.

### Keeping Components Pure

React assumes that every component you write is a pure function. This means that React components you write must always return the same JSX given the same inputs.

```jsx
let guest = 0;

function Cup() {
  // Bad: changing a preexisting variable!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

In general, you should not expect your components to be rendered in any particular order.

In React there are three kinds of inputs that you can read while rendering: props, state, and context. You should always treat these inputs as read-only.

It’s completely fine to change variables and objects that you’ve just created while rendering. 컴포넌트 내부에서 생성한걸 바꾸는 것은 괜찮다. Local mutation이라 함.

Side effect는 보통 렌더링 중이 아니라 on the side(비밀스럽게?) 발생한다.

리액트에서 side effect는 보통 이벤트 핸들러 내부에서 발생한다. 이벤트는 핸들러가 컴포넌트 내부에서 정의되었다해도 렌더링중에 발생하지 않기 때문에 순수할 필요가없다.

적합한 이벤트 핸들러를 찾지 못했으면 useEffect를 사용할 수 있지만 마지막 수단이되어야 한다. **가능한한 렌더링만으로 로직을 표현하라.**

이 챕터는 다시 읽어보면 좋을 듯.

**왜 리액트는 purity를 신경쓸까?**

- 다양한 환경에서 동일하게 동작한다(서버 등등).
- 입력이 같으면 렌더링을 건너뛰어 성능을 최적화할 수 있다.
- 렌더링 중 데이터가 바뀌면 기존 렌더링을 즉시 중단해도 상관 없다.

You should not mutate any of the inputs that your components use for rendering. That includes props, state, and context. To update the screen, “set” state instead of mutating preexisting objects.

Strive to express your component’s logic in the JSX you return. When you need to “change things”, you’ll usually want to do it in an event handler. As a last resort, you can useEffect.

sort는 원본 배열을 mutate시킨다.
