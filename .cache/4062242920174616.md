
> In React, data that changes over time is called state.

### Responding to Events

By convention, it is common to name event handlers as **handle** followed by the event name.

By convention, event handler props should start with on, followed by a capital letter.

[Everything you need to know about Design Systems](https://uxdesign.cc/everything-you-need-to-know-about-design-systems-54b109851969)

Using a real browser <button> enables built-in browser behaviors like keyboard navigation. [Learn more about writing accessible markup](https://developer.mozilla.org/en-US/docs/Learn/Accessibility/HTML).

All events propagate in React except onScroll, which only works on the JSX tag you attach it to.

```jsx
e.stopPropagation();
```

```jsx
// In rare cases, you might need to catch all events on child elements, even if they stopped propagation.
<div
  onClickCapture={() => {
    /* this runs first */
  }}
>
  <button onClick={(e) => e.stopPropagation()} />
  <button onClick={(e) => e.stopPropagation()} />
</div>
```

1. 아래로 내려가며 모든 onClickCapture 호출
2. 눌린 요소의 onClick 실행
3. 위로 올라가며 모든 onClick 실행

Capture events are useful for code like routers or analytics, but you probably won’t use them in app code.

Explicitly calling an event handler prop from a child handler is a good alternative to propagation.

```jsx
// Some browser events have default behavior associated with them.
e.preventDefault();
```

**Event handlers are the best place for side effects.** However, in order to change some information, you first need some way to store it. In React, this is done by using state, a component’s memory. You will learn all about it on the next page.

### State: A Component's Memory

> React, this kind of component-specific memory is called **state**.

1. Local variables don’t persist between renders.
1. Changes to local variables won’t trigger renders.

To update a component with new data, two things need to happen:

1. Retain the data between renders.
1. Trigger React to render the component with new data (re-rendering).

> Hooks are special functions that are only available while React is rendering.

Hooks are functions, but it’s helpful to think of them as unconditional declarations about your component’s needs. 모듈 상단에 import 하는 것과 비슷하게생각하자.

How does useState know which of the state variables to return?

- Hooks rely on a stable call order on every render of the same component.
- Internally, React holds an array of state pairs for every component.

[React Hooks: Not Magic, Just Arrays](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)

```html
<!--https://stackoverflow.com/questions/43895390/imgur-images-returning-403  -->
<meta
  name="referrer"
  content="no-referrer"
/>

<body>
  <button id="nextButton">Next</button>
  <h3 id="header"></h3>
  <button id="moreButton"></button>
  <p id="description"></p>
  <img id="image" />
  <script
    type="module"
    src="./hookMentalModel.js"
  />
</body>

<style>
  * {
    box-sizing: border-box;
  }

  body {
    font-family: sans-serif;
    margin: 20px;
    padding: 0;
  }

  button {
    display: block;
    margin-bottom: 10px;
  }
</style>
```

```js
import sculptureList from './sculptureList.js';

let componentHooks = [];
let currentHookIndex = 0;

// How useState works inside React (simplified).
function useState(initialState) {
  let pair = componentHooks[currentHookIndex];
  if (pair) {
    // This is not the first render,
    // so the state pair already exists.
    // Return it and prepare for next Hook call.
    currentHookIndex++;
    return pair;
  }

  // This is the first time we're rendering,
  // so create a state pair and store it.
  pair = [initialState, setState];

  function setState(nextState) {
    // When the user requests a state change,
    // put the new value into the pair.
    pair[0] = nextState;
    updateDOM();
  }

  // Store the pair for future renders
  // and prepare for the next Hook call.
  componentHooks[currentHookIndex] = pair;
  currentHookIndex++;
  return pair;
}

function Gallery() {
  // Each useState() call will get the next pair.
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  // This example doesn't use React, so
  // return an output object instead of JSX.
  return {
    onNextClick: handleNextClick,
    onMoreClick: handleMoreClick,
    header: `${sculpture.name} by ${sculpture.artist}`,
    counter: `${index + 1} of ${sculptureList.length}`,
    more: `${showMore ? 'Hide' : 'Show'} details`,
    description: showMore ? sculpture.description : null,
    imageSrc: sculpture.url,
    imageAlt: sculpture.alt,
  };
}

function updateDOM() {
  // Reset the current Hook index
  // before rendering the component.
  currentHookIndex = 0;
  let output = Gallery();

  // Update the DOM to match the output.
  // This is the part React does for you.
  nextButton.onclick = output.onNextClick;
  header.textContent = output.header;
  moreButton.onclick = output.onMoreClick;
  moreButton.textContent = output.more;
  image.src = output.imageSrc;
  image.alt = output.imageAlt;
  if (output.description !== null) {
    description.textContent = output.description;
    description.style.display = '';
  } else {
    description.style.display = 'none';
  }
}

let nextButton = document.getElementById('nextButton');
let header = document.getElementById('header');
let moreButton = document.getElementById('moreButton');
let description = document.getElementById('description');
let image = document.getElementById('image');

// Make UI match the initial state.
updateDOM();
```

State is local to a component instance on the screen.

Unlike props, state is fully private to the component declaring it. The parent component can’t change it.

What if you wanted both galleries to keep their states in sync? The right way to do it in React is to remove state from child components and add it to their closest shared parent.

hook into = to become connected to

배열 역방향 순회에서 -1 % arr.length 하면 몇이 나오지?

### Render and Commit

**Trigger a render**

initial render와 state update가 렌더의 두 이유이다.

```jsx
import Image from './Image.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<Image />);
```

컴포넌트의 state가 바뀌면 queues a render.

**React renders your components**

렌더가 트리거된 이후 리액트는 컴포넌트를 호출해 화면에 무엇을 보여줄지 알아본다.

> “Rendering” is React calling your components.

초기 렌더에서는 root 컴포넌트를 호출하고, 이후에는 state 업데이트로 렌더가 트리거된 컴포넌트를 호출한다.

초기 렌더에서는 DOM node들을 만들고, re-render에서는 이전 렌더와 비교 작업을 해어떤 프로퍼티가 바뀌었는지 계산한다. commit phrase 전까지는 이 정보로 아무 작업도 하지 않는다.

**React commits changes to the DOM**

초기 렌더에서는 appendChild로 모든 DOM 노드들을 넣고, 이후에는 렌더링 단계에서 계산된 minimum neccessary operation을 수행한다.

```jsx
// input은 그대로이다.
// id로 time를 줘도 그대로인데 key로 주면 초기화된다.
export default function Clock({ time }) {
  return (
    <>
      <h1>{time}</h1>
      <input />
    </>
  );
}
```

렌더링이 끝나고 DOM을 업데이트하면 브라우저가 painting을 한다. Browser rendering이라고도 하는데 헷갈리니까 painting이라고 하자.

Trigger -> Render -> Commit !!

### State as a Snapshot

Setting state variable does not change the state variable you already have, but instead triggers a re-render.

When React re-renders a component:

1. React calls your function again.
2. Your function returns a new JSX snapshot.
3. React then updates the screen to match the snapshot you’ve returned.

State actually lives outside of your function.

When React calls your component, it gives you a snapshot of the state for that particular render. Your component returns a snapshot of the UI with a fresh set of props and event handlers in its JSX, all calculated using the state values from that render!

근데 버튼 onClick 실행 도중에 끊고 rendering을 하지는 않겠지?? onClick을 마친걸 리액트는 어떻게 아는거지. 다음 섹션에서 다루는 듯.

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      // Scheduled using a snapshot of the state at the time the user interacted with it
      <button
        onClick={() => {
          setNumber(number + 5);
          setTimeout(() => {
            alert(number);
          }, 3000);
        }}
      >
        +5
      </button>
    </>
  );
}
```

**A state variable’s value never changes within a render.**

**React keeps the state values “fixed” within one render’s event handlers.**

Variables and event handlers don’t “survive” re-renders. Every render has its own event handlers.

- Event handlers created in the past have the state values from the render in which they were created.

You can mentally substitute state in event handlers, similarly to how you think about the rendered JSX???

### Queueing a Series of State Updates

**React waits until all code in the event handlers has run before processing your state updates.**

It(Batching) also avoids dealing with confusing “half-finished” renders where only some of the variables have been updated.

React does not batch across multiple intentional events like clicks—each click is handled separately. Rest assured that React only does batching when it’s generally safe to do. This ensures that, for example, if the first button click disables a form, the second click would not submit it again.

setState에 전달된 함수를 updater function이라 한다.

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);
  console.log('asdasd');
  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setTimeout(() => {
            setNumber(100);
          }, 2000);
        }}
      >
        +3
      </button>
    </>
  );
}
// 콜백까지 기다리는건 아니니까,,,?
// 암튼 setNumer는 계속 유효하구나
```

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          // pass updater function
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
// It is a way to tell React to “do something with the state value” instead of just replacing it.
```

It’s common to name the updater function argument by the first letters of the corresponding state variable:

```jsx
setEnabled((e) => !e);
setLastName((ln) => ln.reverse());
setFriendCount((fc) => fc * 2);
```

After the event handler completes, React will trigger a re-render. During the re-render, React will process the queue. Updater functions run during rendering, so updater functions must be pure and only return the result. Don’t try to set state from inside of them or run other side effects. In Strict Mode, React will run each updater function twice (but discard the second result) to help you find mistakes.

```jsx
import { useState } from 'react';

export default function RequestTracker() {
  const [pending, setPending] = useState(0);
  const [completed, setCompleted] = useState(0);

  async function handleClick() {
    setPending((p) => p + 1);
    // 여기 delay는 안기다리고 batch에서 빠져나오는? 듯.
    // event handler가 종료했다는게 정확히 뭘까
    await delay(3000);
    setPending((p) => p - 1);
    // 그 순간의 값으로 설정하려면 함수로 건네줘야한다.
    // c+1을 전달하면 이벤트 헨들러 호출될 당시의 c값으로 하는 듯.
    setCompleted((c) => c + 1);
  }

  return (
    <>
      <h3>Pending: {pending}</h3>
      <h3>Completed: {completed}</h3>
      <button onClick={handleClick}>Buy</button>
    </>
  );
}

function delay(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
```

### Updating Objects in State

It’s not possible to make any changes to the built-in primitive values like numbers, strings, and booleans in JavaScript.

Although objects in React state are technically mutable, you should treat them as if they were immutable

Mutating an object you’ve just created is okay because no other code references it yet.

Note that the ... spread syntax is “shallow”—it only copies things one level deep.

```jsx
setPerson({
  ...person,
  [e.target.name]: e.target.value,
  // 여러 필드에 동일한 이벤트 핸들러 사용하기.
  // Dynamic name의 활용
});

// e.target.name은 <input>의 name 프로퍼티
<input
  name="firstName"
  value={person.firstName}
  onChange={handleChange}
/>;
```

Nested object를 할 때는 잘 분리해서 하기. Objects are not really nested. ... This is difficult to see when you think of objects as “nested”. Instead, they are separate objects “pointing” at each other with properties.

**Immer** is a popular library that lets you write using the convenient but mutating syntax and takes care of producing the copies for you. The draft provided by Immer is a special type of object, called a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy), that “records” what you do with it. 프록시 공부해보자.

```cpp
import { useState } from 'react';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition
  });

  function handleMove(dx, dy) {
    shape.position.x += dx;
    shape.position.y += dy;
  }

  function handleColorChange(e) {
    setShape({
      ...shape,
      color: e.target.value
    });
  }

  return (
    <>
      <select
        value={shape.color}
        onChange={handleColorChange}
      >
        <option value="orange">orange</option>
        <option value="lightpink">lightpink</option>
        <option value="aliceblue">aliceblue</option>
      </select>
      <Background
        position={initialPosition}
      />
      <Box
        color={shape.color}
        position={shape.position}
        onMove={handleMove}
      >
        Drag me!
      </Box>
    </>
  );
}
// It mutated shape.position, but that’s the same object that initialPosition points at.
```

### Updating Arrays in State

splice 대신에 slice 사용.
