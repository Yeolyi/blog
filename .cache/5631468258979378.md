
격주에 한번씩 돌아가면서 발표

https://cs193p.sites.stanford.edu/

## 스터디 1

1번 과제까지

강의 내용 요약 + 공식 문서에서 필요한 부분 발췌 + 과제 코드 설명 + 추가적으로 조사하여 알아두면 좋을 것 등

[The Swift Programming Langauge 5.7](https://books.apple.com/kr/book/the-swift-programming-language-swift-5-7/id881256329)

### Lecture 1: Getting started with SwiftUI

https://www.youtube.com/watch?v=bqu6BquVi2M

reverse DNS notation. unique thing that identifies the group that's working on this app.

coredarta object oriented database.

tests: testing framework in SwiftUI? 백엔드코드뿐만 아니라 UI도 테스트 가능.

왼쪽 창은 navigator. default는 navigate by file. 이거 말고도 디버깅, searching 등등이 있다.

오른쪽은 inspector.

가운데에 previewer가 있음. Launching simulator in place.

Memorize.xcodeproj 의 변경사항은 Info.plist에 반영된다. Info.plist를 직접 바꿀 일은 거의 없다? xcodeproj도 99% 기본값을 쓴다?

C의 main.c -> @main

ContentView_Preiews glues previerer to ContentView.

로직 부분에는 import SwiftUI가 필요하지 않고 이러한 분리가 SwiftUI의 장점이다.

We will use OOP especially to connect out logic to our UI. Struct is not OOP thing. No inheritance, functional programming.

Clean code에 기차 어쩌구 언급하면 좋을듯.

```java

final String outputDir =
    ctxt.getOptions().getScratchDir().getAbsolutePath();

```

```swift

Text(theme.name)
    .font(.headline)
    .foregroundColor(.primary)

```

:view this struct we are creating behaves like view. In functional programming the behavior of things, hoe thins behave is crusial. 구현에 대해서는 묻지 않는다.

프로토콜 기반 프로그래밍, Collection 구현 같은 것들 찾아보면 좋을 듯. View가 되려면 body만 구현하면 된다. Everything in screen, every rectangular area is a View. 예를 들어, view can be padded.

다중 상속? 같은게 자유롭게 됨도 언급하자.

The type of the body is something behaves like a view. If you think of Views as being kind of like Lego. 레고 집을 생각하면 레고로 만들어진 다양한 방도 있고 가구도 있다. ??? Lego dining room chair is itself a Lego.

Combiners. Take other views and combine them. var body most of the time combiner view.

Functions are first class citizen.

Functional programming language.

var body is not variable stored in memory, it's a variable that's calculated.

some View if more like some advice to the compiler saying, "Hey, this variable's type if going to be some View. Please go configure out what it actually is and replace it with that when you compile it."

냅다 Text로 타입 선언하지 않는 이유. Part of is just the declaration just declaring that that's going on. 또한 안에 뷰가 겁나 복잡해진다. 컴파일러한테 시키는 것.

https://www.hackingwithswift.com/books/ios-swiftui/why-does-swiftui-use-some-view-for-its-view-type

padding은 ModifiedContent 어쩌구를 반환한다. 위에 링크에서도 언급됨!

trailing closure.

Swift knows that you're going to want to make these bags of Lego alot and so it makes it really easy for you to do. It's really enhanced the concept of a function to be able to create a bag of Lego. This kind of function that you pass to a Lego combiner view is called a View builder.

This view builder mechanism knows how to take list of Views and actually combine them into another View which is a beg of Lego view. TupleView. Conditional variable과 define variable도 가능하다.

https://www.avanderlee.com/swiftui/viewbuilder/

```swift
// option+click
let a: ZStack<TupleView<(RoundedRectangle, VStack<Text>)>>
```

Combiner의 foreground색을 바꾸면? combiner 자체는 아무것도 그리지 않음. Combiner의 modifier는 내부 뷰들에 전달된다. 이 전달되는 색은 container로부터 inherit되는 기본 색이고 이미 색이 적용되어있으면 무시된다. CSS 생각나네.

### Lecture 2: Learning more about SwiftUI

https://www.youtube.com/watch?v=3lahkdHEhW8

stroke 이후 fill을하면 we're actually talking about filling the racetrack. 안을 채우려면 single rectangle로는 안된다.

type infer.

https://www.swiftbysundell.com/articles/swiftui-state-management-guide/ 갑자기 생각나서,,

All view in swiftui is immutable.

https://www.hackingwithswift.com/articles/190/the-best-wwdc-videos-of-all-time

Mutablity와 관련하여, UI가 바뀌면 모든 view가 갈아치워진다.

But, there is a small way that you can kind of create your own, can think of it as like, mini-logic but it's really just creating a tiny little outside of the View storage space, and have the View just look at that. And when that changes, the View will get rebuilt but still pointing to that little piece of memory. @state. 얘를 쓴다고 view가 immutable해지는건 아니고 얘가 포인터의 역할을 해준다. 근데 얘를 자주는 안쓸거고 temporaryb state로서 사용한다. 뷰가 보여지는 방식을 할때나 쓰고 로직에는 잘 안쓰는듯.

viewbuidler에서 for문을 쓸 수는 없고, 이를 위한 Bag가 있다. ForEach는 다른 view combiner로 감싸야하는데 이는 ForEach 자체는 View combiner가 아니고 bag of Lego maker이기 때문이다.

Identifiable. ForEach에서는 reorder등 떄문에 필요함. \.self. All structures have this var on themselved called self. Sort에서 쓰는 예시 보여주면 될 듯. ID가 겹치면 둘에 대해 같은 뷰를 사용한다? 이런 경우는 원하지 않음.

그나저나 declarative vs imperative하면 좋을 듯.

https://medium.com/@rmeji1/declarative-and-imperative-programming-using-swiftui-and-uikit-c91f1f104252

Button의 label은 viewbuilder라서 function이다.

SFSymbols.

```swift
// 여러개도 된다.
Button {
    //
} label: {

}
```

This blue is kind of standard control blue in the UI.

HStack uses all the space it can. LazyVGrid근 가로는 다 쓰지만 세로는 최소한 쓴다. Spacer 쓸 떄도 hstack이 다 먹었지만 LazyVGrid는 spacer가 다 먹는다. Spacer는 take any open spaces available that no one else wants.

lazy - There is strategy to only access a View's body var when absolutely necessary.

stroke draws around right on top of the border. 그래서 좀 잘린다. Shape의 안쪽이면 좋겠다. stokeBorder. 이거 시뮬레이션하면 좋을 듯.

### reading_1

https://swift.org/documentation/api-design-guidelines/

### assignment_1

Looking things up in the documentation (Array and possibly Font)

Note that there are some seemingly identical functions in Array, one of which is a verb and other is an adjective that is the past- tense of that verb. Try to figure out the difference (though you can use either one). Sort도 비슷했던거같음.

## 스터디 2

### Lecture 3: MVVM and the Swift type system

MVVM - A "code organizing" architectural design paradigm. Must be adhered to for SwiftUI to work. UIKit 시절 MVC와 다르다.

Model은 UI independant. Data + Logic. What your application does. View는 how it is presented to user.

The view always be a reflection of the current state of the model. 데이터는 model -> view 방향으로 간다.

Views are immutable other than to rebuild the entire body. Declarative. Imperative approach 에서는 we're calling functions one after another that are pieceing the UI together over time.

body var 외에는 어떻게 그릴지 알려주지 않는다.

We also say that SwiftUI is reactive. Model에서 바뀐 부분에 연결된 View만 업데이트된다. 이게 MVVM. 이를 VM이 도와준다. The ViewModel's job is to bind the view to the model so the changes in the Model cause the View to react and get rebuilt. Interpreter between model and view. Gatekeepeer to the model. The view must get its data from the Model by asking for it from the VM. Viewmodel never stores the data.

VM은 model의 changes를 감지한다. 이후 VM은 publishes something changed to the whole world. **The ViewModel does not wanna have any connections to any of the Views that are using it to access the Model.**

Views automatically observes publications, pulls data and rebuilds.

터치 등으로 인한 model change는 view가 VM의 intent function을 호출해서 이루어진다.

struct - functional programming, class - OOP.

VM은 뷰 간에 공유해야되기때문에 class이다.

class는 free init이 어떤 변수도 초기화시키지않는다. 변수마다 기본값이 있으면 써먹을 수 있긴 함.

struct에서 mutability는 항상 명시되어야한다. let이면 못바꿈. View가 immutable하다는건 어딘가에 let으로 저장되어있다는 뜻.

Struct. Your go to data structure. Class. Used in specific circumstances.

Swift는 generic과 protocol을 합쳐 강력한 기능을 만들었다.

Passing function to function is the heart of functional programming.

Note that we don't use argument labels (e.g. operand:) when executing function types.

Foundation -> Array, Dictionary ...

VM -> Either take a really large complicated one(model?) and create small windows on it, or to take a buncha small little models and combine them together to have a unified window on them. 

UIIndependant한 model을 위해 제너릭을 사용하네. 

VM is part of the UI. UI랑 View랑 다른 의미인듯. 

VM이 model을 포함하고 있을 수도 있다. 

CardContent가 스스로를 만드는 법을 아는건 이상하긴 한가?

static 멤버를 암묵적으로 사용하는건 static 함수 내부에서 혹은 초기화할때나 가능하다. 

Special type of enum called optional. 

If we think of a view as just an agent for showing what in the Model through the view model, then more likely, we're gonna pass view model through an argument. 

View에서 var는 @State에서만 쓰고 We're gonna use @State very rare in View. 