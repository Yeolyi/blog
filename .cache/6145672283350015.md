
[docs](https://tailwindcss.com/docs/)

## Getting Started

### Installation

Tailwind CSS works by scanning all of your HTML files, JavaScript components, and any other templates for class names, generating the corresponding styles and then writing them to a static CSS file.

```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ['./src/**/*.{html,js}'],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

### Editor Setup

VSCode에서는 Tailwind CSS IntelliSense.

Prettier plugin도 따로 있다. 순서를 잘 정렬해줌.

### Using with Preprocessors

.

### Optimizing for Production

.

### Browser Support

If you’re using the Tailwind CLI tool, vendor prefixes like this will be added automatically.

If not, we recommend that you use Autoprefixer, which is a PostCSS plugin that automatically adds any necessary vendor prefixes based on the browsers you tell it you need to support.

### Upgrade Guide

.

## Core Concepts

### Utility-First Fundamentals

Building complex components from a constrained set of primitive utilities.

- You aren’t wasting energy inventing class names.
- Your CSS stops growing.
- Making changes feels safer(global하지 않음)

Inline style과는 다르게

- Designing with constraints.
- Responsive design.
- Hover, focus, and other states.

Managing commonly repeated utility combinations.

- Extracting components and partials
- Editor and language feature??

### Handling Hover, Focus, and Other States

Traditionally the same class name applies different styles on hover. In Tailwind, separate classes are used for the default state and the hover state

```css
.bg-sky-500 {
  background-color: #0ea5e9;
}
.hover\:bg-sky-700:hover {
  background-color: #0369a1;
}
```

By using modifiers you can control exactly how your design behaves in different states, without ever leaving your HTML.

In this guide you’ll learn about every modifier available in the framework, how to use them with your own custom classes, and even how to create your own.

:hover, :focus, :active 등등

- :focus represents the state when the element is currently selected to receive input(탭으로 선택됐을 때)
- :active represents the state when the element is currently being activated by the user.

[참고](https://stackoverflow.com/questions/1677990/what-is-the-difference-between-focus-and-active)

first: last: odd: even: 등등

required: disabled: invalid:

When you need to style an element based on the state of some parent element, mark the parent with the group class, and use group-\* modifiers like group-hover to style the target element:

group/item처럼 이름도 지정 가능

Arbitrary groups??

When you need to style an element based on the state of a sibling element, mark the sibling with the peer class, and use peer-\* modifiers like peer-invalid to style the target element. 이전 sibling에 대해서만 된다.

before: after:. When using these modifiers, Tailwind will automatically add content: '' by default.

It’s worth noting that you don’t really need ::before and ::after pseudo-elements for most things in Tailwind projects — it’s usually simpler to just use a real HTML element.

Save before and after for situations where it’s important that the content of the pseudo-element is not actually in the DOM and can’t be selected by the user.

placeholder:

Style the button in file inputs using the file modifier. Note that Tailwind’s border reset is not applied to file input buttons.

marker: 는 상속 가능해서 li 대신 ul/ol에 넣어도 된다.

selection: 도 상속 가능.

first-line:, first-letter:

Style the backdrop of a native <dialog> element using the backdrop modifier. dialog란 태그도 있네.

To style an element at a specific breakpoint, use responsive modifiers like md and lg.

```html
<!-- 3-column grid on mobile, a 4-column grid on medium-width screens, and a 6-column grid on large-width screens: -->
<div class="grid grid-cols-3 md:grid-cols-4 lg:grid-cols-6">
  <!-- ... -->
</div>
```

Use the dark modifier to provide overrides for dark mode. prefers-color-scheme라는 media query는 OS단에서 제공된다.

prefers-motion-reduce media query는 motion-reduce modifier를 사용한다.

```html
<!-- Using `motion-reduce` can mean lots of "undoing" styles -->
<button
  class="hover:-translate-y-0.5 transition motion-reduce:hover:translate-y-0 motion-reduce:transition-none ..."
>
  Save changes
</button>

<!-- Using `motion-safe` is less code in these situations -->
<button class="motion-safe:hover:-translate-x-0.5 motion-safe:transition ...">Save changes</button>
```

prefers-contrast -> contrast-more

portrait: landscape:

print:

supports-[...]

Use the aria-\* modifier to conditionally style things based on ARIA attributes.

Use the data-\* modifier to conditionally apply styles based on data attributes.

ltr:, rtl:

Use the open modifier to conditionally add styles when a <details> or <dialog> element is in an open state.

```html
<!-- arbitrary variants -->
<li class="[&:nth-child(3)]:underline">{item}</li>
```

### Responsive Design

sm, md, lg, xl, 2xl

min-width: 640px, 768px, 1024px, 1280px, 1536px

By default, Tailwind uses a mobile-first breakpoint system, similar to what you might be used to in other frameworks like Bootstrap.

Don’t think of sm: as meaning “on small screens”, think of it as “at the small breakpoint“. 모바일 타겟할 때 sm을 쓰는게 아니라 unprefixed이다.

```html
<!-- apply a utility only when a specific breakpoint range is active -->
<div class="md:max-xl:flex">
  <!-- ... -->
</div>
```

### Dark Mode

If you want to support toggling dark mode manually instead of relying on the operating system preference, use the class strategy instead of the media strategy.

```js
module.exports = {
  darkMode: 'class',
  // ...
};
```

```html
<!-- Dark mode not enabled -->
<html>
  <body>
    <!-- Will be white -->
    <div class="bg-white dark:bg-black">
      <!-- ... -->
    </div>
  </body>
</html>

<!-- Dark mode enabled -->
<html class="dark">
  <body>
    <!-- Will be black -->
    <div class="bg-white dark:bg-black">
      <!-- ... -->
    </div>
  </body>
</html>
```

### Reusing Styles

### Adding Custom Styles

### Functions & Directives

## Customization

## Base Styles

### Preflight
