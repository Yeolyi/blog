
## Preface

많은 개발자들이 파이썬을 이전에 쓰던 언어처럼 사용해버린다.

알지 못하는 기능에 대해서는 아쉬워할 수 없다. 파이썬을 강력하게 사용하자.

> Its emphasis is on the language features that are either unique to Python or not found in many other popular languages.

> Premature abstraction is as bad as premature optimization.

[doctest](https://docs.python.org/3/library/doctest.html)

[GitHub](https://github.com/fluentpython/example-code-2e)

[fluentpython.com](https://www.fluentpython.com)

## 1. Data Structures

### 1. The Python Data Model

파이썬의 강점 중 하나는 일관성이다.

> You can think of the data model as a description of Python as a framework.

파이썬 인터프리터는 기본적인 객체 연산을 위해 특별 메서드(special method)를 호출한다. obj[key]는 \_\_getitem\_\_ 특별 메서드에 의해 지원된다.

```py
import collections
from random import choice

Card = collections.namedtuple('Card', ['rank', 'suit'])


class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spafed diamonds clubs hearts'.split()

    def __init__(self):
        self._cards = [Card(rank, suit)
                       for rank in self.ranks for suit in self.suits]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]


beer_card = Card('7', 'diamonds')
print(beer_card)
# Card(rank='7', suit='diamonds')
# namedTuple이라서 예쁘게 프린트된다.

deck = FrenchDeck()
print(len(deck))  # 52
print(deck[-1])  # Card(rank='A', suit='hearts')

choice(deck)

# 이외에도 slicing, sorting, containing 기능을 사용할 수 있다.
# Although FrenchDeck implicitly inherits from the object class, most of its functionality is not inherited, but comes from leveraging the data model and composition.
```

파이썬 데이터 모델을 leverage하기 위한 특별 메서드는 클래스의 사용자가 임의의 메서드 이름을 외울 필요가 없게 하고 풍부한 파이썬 표준 라이브러리로부터 이득을 취하기 쉽게 한다.

특별 메서드는 내가 아닌 파이썬 인터프리터에 의해 호출되어야한다. 유일하게 자주 직접 불러야하는 특별 메서드는 \_\_init\_\_이다. 빌트인 함수들이 부르는게 다른 작업도 해주고 빌트인 타입에서는 빠르니까 좋다.

```py
import math


class Vector:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __repr__(self):
        return f'Vector({self.x!r}, {self.y!r})'

    def __abs__(self):
        return math.hypot(self.x, self.y)

    def __bool__(self):
        # The builtins True and False are the only two instances of the class bool.
        # The class bool is a subclass of the class int, and cannot be subclassed.
        return bool(abs(self))

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y*scalar)


v1 = Vector(3, 4)
v2 = Vector(2, 1)

print(v1 + v2)
print(abs(v1))
print(v1 * 3)
print(abs(v1*3))
```

[what does r do in str and repr](https://stackoverflow.com/questions/38418070/what-does-r-do-in-str-and-repr)

\_\_repr\_\_은 match the source code to re-create the represented object, \_\_str\_\_는 엔드 유저가 보기 적합하게. 둘 중 하나만 한다면 \_\_str\_\_

불리언이 사용될 맥락에서 객체를 사용하는 것이 허용된다. \_\_bool\_\_을 호출해보고, 없으면 len을 호출해 0인지 아닌지 확인한다. 이것도 없으면 true.

ABC: abstract base classes

- Iterable - unpacking, iteration
- Sized - len
- Container - in operator

중요한 Collection의 분화에는 Sequence, Mapping, Set이 있다.

> len is not called as a method because it gets special treatment as part of the Python Data Model, just like abs.But thanks to the special method \_\_len\_\_, you can also make len work with your own custom objects.

### 2. An Array of Sequences

표준 라이브러리는 C로 구현된 풍부한 시퀀스 타입을 제공한다.

list, tuple, deque같은 container sequence는 다른 타입의 요소를 가질 수 있고 str, byte, array같은 flat sequence는 한 타입만 가질 수 있다. 전자는 참조, 후자는 값을 가진다. 전자는 숫자를 넣어도 참조로 가지는 듯?(Figure 2-1)

이렇게 말고 mutability로 나눌 수도 있다. tuple, str, byte는 변경 불가능하다. mutable sequence들은 immutable sequence의 것들을 상속받는다.

모든 파이썬 객체는 메타데이터가 든 헤더를 가진다.

생성된 list로 뭘 할게 아니라면 list comprehension은 사용하면 안된다.

```py
symbols = '가나다라'
print([ord(symbol) for symbol in symbols])

# for에 대입된 변수를 담을 별도의 지역 스코프가 있다
x = 'ABC'
codes = [ord(x) for x in x]
print(x)  # ABC
print(codes)  # [65, 66, 67]
# Walrus operator는 예외. 얘는 enclosing function이 스코프이다.
codes = [last := ord(c) for c in x]
print(last)  # 67

# Cartesian product
colors = ['black', 'white']
sizes = ['S', 'M', 'L']
tshirts = [(color, size) for color in colors for size in sizes]
print(tshirts)
```

Listcomp는 map과 filter가 하는거 다 할 수 있다. 더 예쁨.

다른 시퀀스 다루려면 generator expression을 사용한다.

```py
import array

symbols = 'abcde'
# 대괄호 대신 소괄호
print(tuple(ord(symbol) for symbol in symbols))

# I는 storage type
print(array.array('I', (ord(symbol) for symbol in symbols)))

# 메모리를 아낄 수 있다.
colors = ['black', 'white']
sizes = ['S', 'M', 'L']
for tshirt in (f'{c} {s}' for c in colors for s in sizes):
    print(tshirt)
```

튜플은 변경 불가능한 리스트 외에도 records with no field names로 사용할 수 있다.

```py
lax_coordinates = (33.9425, -118.408056)
city, year, pop, chg, area = ('Tokyo', 2003, 32_450, 0.66, 8014)
traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'), ('ESP', 'XDA205856')]
for passport in sorted(traveler_ids):
    print('%s/%s' % passport)

# unpacking
# _도 유효한 변수 이름. 다만 switch에서는 와일드카드로 사용.
# 파이썬 콘솔에서는 이전 명령의 반환값이 None이 아닌한 _에 대입된다.
for country, _ in traveler_ids:
    print(country)
```

Mutable한 객체를 담은 튜플은 버그의 원인이 될 수 있다.

튜플은 리스트보다 성능이 좋다.

> Unpacking is important because it avoids unnecessary and error-prone use of indexes to extract elements from sequences.

```py
t = (20, 8)
_, remainder = divmod(*t)
print(remainder)  # 4

a, b, *rest = range(5)
print(rest)  # [2, 3, 4]

a, *body, c, d = range(5)
print(body)  # [1, 2]

print([*range(4), 4, *(5, 6, 7)])

metro_areas = [
    ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),
    ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),
    ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),
    ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),
    ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)),
]

print(f'{"":15} | {"latitude":>9} | {"longitude":>9}')
for name, _, _, (lat, lon) in metro_areas:
    if lon <= 0:
        print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')
```

single-item 튜플은 trailing comma와 함께 써야한다. (a, )

```py
# One key improvement of match over switch is destructuring
def handle_command(self, message):
  match message:
    case ['BEEPER', frequency, times]:
      self.beep(times, frequency)
    case ['NECK', angle]:
      self.rotate_neck(angle)
    case ['LED', ident, intensity]:
      self.leds[ident].set_brightness(ident, intensity)
    case ['LED', ident, red, green, blue]:
      self.leds[ident].set_color(ident, red, green, blue)
    case _:
      raise InvalidCommand(message)
# Sequence pattern은 튜플이든 리스트든 상관이 없다. collection.abs.Sequence의 서브클래스면 되지만 str, bytes, bytearray는 예외.
# patterns don't destructure iterables that are not sequences. like iterator
# 여기서 사용된 _에는 값이 바인딩되지 않는다.
```

시퀀스 패턴에서 \*는 시퀀스당 한번만 등장할 수 있다.

> Pattern matching is an example of declarative programming: the code describes “what” you want to match, instead of “how” to match it.

slice/range에서 명시한? 마지막 원소를 포함하지 않는 것은 길이를 알기 쉽고 계산하기도 쉽고(stop - start) 시퀀스를 두 개로 나누기(list[:x], list[x:]도 쉽다.

```py
s = 'bicycle'
print(s[::3])  # bye
print(s[::-1])  # elcycib
print(s[::-2])  # eccb

# a:b:c notation은 slice(a, b, c) 객체를 만든다.
invoice = """
0.....6.................................40........52...55........
1909  Pimoroni PiBrella                     $17.50    3    $52.50
1489  6mm Tactile Switch x20                 $4.95    2     $9.90
1510  Panavise Jr. - PV-201                 $28.00    1    $28.00
1601  PiTFT Mini Kit 320x240                $34.95    1    $34.95
"""
SKU = slice(0, 6)
DESCRIPTION = slice(6, 40)
UNIT_PRICE = slice(40, 52)
QUANTITY = slice(52, 55)
ITEM_TOTAL = slice(55, None)
# 시작이 \n임. 2부터 시작
line_items = invoice.split('\n')[2:]
for item in line_items:
    print(item[UNIT_PRICE], item[DESCRIPTION])

l = list(range(10))
l[2:5] = [20, 30]
print(l)
del l[5:7]
print(l)
# l[2:5] = 10 -> can only assign an iterable
```

Augmented assignment operator. +=의 경우 \_\_iadd\_\_를 통해 작동하고 구현되어있지 않으면 \_\_add\_\_를 사용한다. 따라서 후자의 경우 a = a + b처럼 작동하고 a + b를 평가할 때 새로운 객체를 만들게 된다. 객체의 identity가 바뀔 수도 안바뀔 수도 있다.

따라서 mutable 객체는 iadd가 구현되어 inplace로 작동한다 생각해도 좋다.

```py
l = [[]] * 3
l[0].append(1)
print(l)  # [[1], [1], [1]]

l = [1, 2, 3]
print(id(l))
l *= 2
print(id(l))

t = (1, 2, 3)
print(id(t))
t *= 2
print(id(t))

# This exmaple is quite a corner case.
# t = (1, 2, [30, 40])
# t[2] += [50, 60]
# print(t)

# 뭐지 얘는
# dis.dis('s[1] += b')
```

- 튜플에 mutable 넣는 것 지양
- Augmented assignement는 원자적 작업이 아니다.
- Python bytecode를 보는건 그리 어렵지 않다.

> Receiver is the target of a method call, the object bound to self in the method body.

list.sort는 inplace.

[Fluent interface](https://en.wikipedia.org/wiki/Fluent_interface#Swift)

이진 검색 모듈인 bisect가 있다.

리스트도 좋지만 다른걸 사용하는게 좋은 경우도 있다. array, dequeue 등,,,

```py
from array import array
from random import random

# 빠르다
# array of double-precision floats
floats = array('d', (random() for i in range(10**7)))
print(floats[-1])
fp = open('floats.bin', 'wb')
floats.tofile(fp)
fp.close()
floats2 = array('d')
fp = open('floats.bin', 'rb')
floats2.fromfile(fp, 10**7)
fp.close()
print(floats2[-1])
print(floats2 == floats)
```

> A memoryview is essentially a generalized NumPy array structure in Python itself (without the math). It allows you to share memory between data-structures (things like PIL images, SQLite databases, NumPy arrays, etc.) without first copying. This is very important for large data sets.

> NumPy implements multi-dimensional, homogeneous arrays and matrix types that hold not only numbers but also user-defined records, and provides efficient element-wise operations.

> SciPy is a library, written on top of NumPy, offering many scientific computing algorithms from linear algebra, numerical calculus, and statistics.

> NumPy and SciPy are formidable libraries, and are the foundation of other awesome tools such as the Pandas—which implements efficient array types that can hold nonnumeric data and provides import/export functions for many different formats’

```py
import numpy as np
a = np.arange(12)
print(a)  # [ 0  1  2  3  4  5  6  7  8  9 10 11]
print(a.shape)
a.shape = 3, 4
print(a)
print(a[:, 1])
print(a.transpose())
```

> The class collections.deque is a thread-safe double-ended queue designed for fast inserting and removing from both ends

```py
from collections import deque

dq = deque(range(10), maxlen=10)
print(dq)  # deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
dq.rotate(3)
print(dq)  # deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)
dq.appendleft(-1)
print(dq)  # deque([-1, 7, 8, 9, 0, 1, 2, 3, 4, 5], maxlen=10)
```

덱은 양 끝에서는 빠른 대신에 중간에서 하는건 느림에 유의. append와 popleft는 원자적이라서 멀티쓰레드에서 락 없이 사용해도 좋다.

이외에도 queue, multiprocessing, asyncio, heapq가 있다.

### 3. Dictionaries and Sets

> Python is basically dicts wrapped in loads of syntactic sugar.

파이썬과 딕셔너리는 떼놓을 수 없다. 중요한 역할을 맡기에 매우 최적화되어있다.

```py
dial_codes = [
    (880, 'Bangladesh'),
    (55,  'Brazil'),
    (86,  'China'),
    (91,  'India'),
    (62,  'Indonesia'),
    (81,  'Japan'),
    (234, 'Nigeria'),
    (92,  'Pakistan'),
    (7,   'Russia'),
    (1,   'United States'),
]
country_dial = {country: code for code, country in dial_codes}

print(country_dial)
print({code: country.upper()
      for country, code in sorted(country_dial.items()) if code < 70})


def dump(**kwargs):
    return kwargs


# 여기서는 중복이 안되고
print(dump(**{'x': 1}, y=2, **{'z': 3}))
# 여기서는 된다
print({'x': 0, **{'x': 1}})

d1 = {'a': 1, 'b': 3}
d2 = {'a': 2, 'b': 4, 'c': 6}
print(d1 | d2)
```

```py
from collections import OrderedDict


def get_creators(record: dict) -> list:
    match record:
        case {'type': 'book', 'api': 2, 'authors': [*names]}:
            return names
        case {'type': 'book', 'api': 1, 'author': name}:
            return [name]
        case {'type': 'book'}:
            raise ValueError(f"Invalid 'book' record: {record!r}")
        case {'type': 'movie', 'director': name}:
            return [name]
        case _:
            raise ValueError(f'Invalid record: {record!r}')


# Sequence pattern과 다르게 부분적인 매치도 좋다.
b1 = dict(api=1, author='Douglas Hofstadter',
          type='book', title='Godel, Escher, Bach')
print(get_creators(b1))

# 순서있어도 상관없다.
b2 = OrderedDict(api=2, type='book', title='Python in a Nutshell',
                 authors='Martelli Ravenscroft Holden'.split())
print(get_creators(b2))
get_creators({'type': 'book', 'pages': 770})
```

> An object is hashable if it has a hash code which never changes during its lifetime (it needs a \_\_hash\_\_() method), and can be compared to other objects (it needs an \_\_eq\_\_() method). Hashable objects which compare equal must have the same hash code.

Container 타입은 immutable하고 contained object가 hashable할 때 hashable하다.

보안상의 이유로 파이썬 버전별로, 컴퓨터 아키텍처에 따라 해시 값은 다를 수 있다. 해시 값은 한 파이썬 프로세스내에서만 같을 것이 보장된다.

```py
# setdefault example
if key not in my_dict:
  my_dict[key] = []
my_dict[key].append(new_value)

my_dict.setdefault(key, []).append(new_value)
```

defaultdict은 \_\_missing\_\_을 통해 작동한다.

k in my_dict.keys()보다 k in my_dict가 더 빠르다.

3.6부터 기본 dict도 순서를 보존해서 OrderedDict는 보통 하위호환을 위해 사용한다. 어느정도 차이는 있는데, dict는 mapping 연산에 특화되었고 OrderedDict는 reorder에 특화되어있다. LRU 캐시에서 최근 접근을 관리하는데 용이하다.

```py
# A ChainMap instance holds a list of mappings that can be searched as one.
import builtins
pylookup = ChainMap(locals(), globals(), vars(builtins)
```

```py
import collections

ct = collections.Counter('abracadabra')
print(ct)  # Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
ct.update = 'aaaaazzz'
print(ct)
print(ct.most_common(3))  # [('a', 5), ('b', 2), ('r', 2)]
```

> The shelve module in the standard library provides persistent storage for a mapping of string keys to Python objects serialized in the pickle binary format.

dict보다 UserDict를 서브클래싱하는 것이 좋다.

```py
# Immutable해야하는 것을 API 외부로 공개할 때 활용할 수 있다.
from types import MappingProxyType
d = {1: 'A'}
d_proxy = MappingProxyType(d)
print(d_proxy)  # {1: 'A'}
# TypeError: 'mappingproxy' object does not support item assignment
# d_proxy[2] = 'x'
```

dict의 .keys(), .values(), .items()는 특정 클래스의 인스턴스를 반환하는데, 이 **dictionary view**들은 read-only projections of the internal data structures used in the dict implementation으로 메모리를 절약할 수 있게 해준다. 이 view object는 dynamic proxy이다.

```py
d = dict(a=10, b=20, c=30)
values = d.values()
d['d'] = 40
print(values)  # dict_values([10, 20, 30, 40])
```

> To save memory, avoid creating instance attributes outside of the \_\_init\_\_ method...??

**Set**

```py
# 중복 요소 제거해야되는데 순서도 보장해야할 때
dict.fromkeys(l).keys()
list(dict.fromkeys(l).keys())
```

빈 집합은 {}로는 안되고 set()을 사용해야한다.

```py
from unicodedata import name

result = {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')}
{'§', '=', '¢', '#', '¤', '<', '¥', 'µ', '×', '$', '¶', '£', '©',
 '°', '+', '÷', '±', '>', '¬', '®', '%'}
print(result)  # salted hash때문에 순서는 매번 바뀐다.
```

```py
a = {1, 2, 3}
print(a.union([4], [5], [1, 2, 3]))
print({*[1, 2, 3], *{4, 5, 6}})

b = {2, 3, 4}
print(a ^ b)

c = {1, 2}
print(1 in a)  # True
print(c <= a)  # True
print(c < {1, 2})  # False

c.add(4)
c.clear()
c.discard(1) # 없어도 됨
c.pop()
c.remove(1) # 없으면 KeyError
```

dict_keys와 dict_items는 frozenset과 아주 유사하다.

### 4. Unicode Text Versus Bytes

> Python 3 introduced a sharp distinction between strings of human text and sequences of raw bytes. Implicit conversion of byte sequences to Unicode text is a thing of the past.

string이란 character의 시퀀스고 character는 일반적으로 Unicode character이다.

character의 identity는 code point이며 0에서 1114111까지의 수이다.

특정 character를 표현하기 위한 바이트는 인코딩에 따라 달라진다. 인코딩이란 code point에서 바이트 시퀀스로의 변환을 하는 알고리즘이다.

```py
s = "café"
print(len(s))  # 4
b = s.encode("utf8")
print(b)  # b'caf\xc3\xa9'
print(len(b))  # 5
print(b.decode("utf8"))

for codec in ["latin_1", "utf_8", "utf_16"]:
    print(codec, "El Niño".encode(codec))
```

bytes, bytearray의 요소는 0-255의 수이다.

```py
s = "café"
cafe = bytes(s, encoding="utf_8")
print(cafe)  # b'caf\xc3\xa9'
print(cafe[0])  # 99
print(cafe[:1])  # b'c'. binary sequence의 slice는 언제나 같은 타입을 반환한다.
print(bytearray(cafe))  # bytearray(b'caf\xc3\xa9')
# 32-126은 숫자로, \t, \n, \r, \\, ''있으면 안에 뭐가 붙고 나머지 16진수값은 \x로 표시

print(bytes.fromhex("31 4B CE A9").decode("utf8"))
```

```py
# 레거시 인코딩 방법은 에러 리포트 없이 디코딩할 수도 있다.
octets = b"Montr\xe9al"
print(octets.decode("cp1252"))
print(octets.decode("iso8859_7"))
print(octets.decode("koi8_r"))
print(octets.decode("utf_8"))
```

utf 인코딩은 모든 유니코드 코드 포인트를 표현할 수 있도록 디자인되었다. utf-8은 97%의 웹사이트가 사용한다.

```py
u16 = "El Niño".encode("utf_16")
print(u16)
# b'\xff\xfeE\x00l\x00 \x00N\x00i\x00\xf1\x00o\x00'
# b'`xff`xfe
# The bytes are b'\xff\xfe'. That is a BOM—byte-order mark—denoting the “little-endian” byte ordering of the Intel CPU where the encoding was performed.
# 혼란을 막기 위해 UTF-16은 prepends the text with ZERO WIDTH NO_BREAK SPACE(U+FEFF)
# BOM은 UTF-16 codec에 의해 필터링된다.
```

> **Unicode sandwich**. byte는 input, output얻어올 때 바로 처리하고 비즈니스 코드에서는 text만 처리하는 것인듯.

In the Unicode standard, sequences like 'é' and 'e\u0301' are called **canonical equivalents**, and applications are supposed to treat them as the same. But Python sees two different sequences of code points, and considers them not equal.

이때 normalize 함수를 활용한다.

```py
from unicodedata import normalize

s1 = "café"
s2 = "cafe\N{COMBINING ACUTE ACCENT}"
print(s1, s2)
print(len(s1), len(s2))
print(s1 == s2)

print(normalize("NFC", s1) == normalize("NFC", s2))
```

Case Folding이란 모든 텍스트를 소문자로 바꾸는 것이다.

유니코드 표준은 code point에서 character 이름, 각 character의 메타 데이터등을 포함하는 데이터베이스를 제공한다.

```py
from unicodedata import name

for char in "🥳🎧💊⌥":
    print(name(char))
    
# FACE WITH PARTY HORN AND PARTY HAT
# HEADPHONE
# PILL
# OPTION KEY
```

```py
import unicodedata
import re

re_digit = re.compile(r"\d")

sample = "1\xbc\xb2\u0969\u136b\u216b\u2466\u2480\u3285"

for char in sample:
    print(
        f"U+{ord(char):04x}",
        char.center(6),
        "re_dig" if re_digit.match(char) else "-",
        "isdig" if char.isdigit() else "-",
        "isnum" if char.isnumeric() else "-",
        f"{unicodedata.numeric(char):5.2f}",
        unicodedata.name(char),
        sep="\t",
    )
```

파이썬의 표준 라이브러리 중에는 str과 bytes를 모두 인자로 받는 것들이 있으며 입력받은 타입에 따라 다르게 작동한다.

### 5. Data Class Builders

> ‘Python offers a few ways to build a simple class that is just a collection of fields, with little or no extra functionality. That pattern is known as a **data class**

## 2. Functions as Objects

## 3. Classes and Protocols

## 4. Control Flow

## 5. Metaprogramming

```py
def factorial(x):
    if x == 1: # This is the base case
        return 1

    else: # This is the recursive case
        return(x * factorial(x-1))

print(factorial(4))
```
