
## Tutorial: Tic-Tac-Toe

```jsx
return React.createElement(
  'div',
  { className: 'shopping-list' },
  React.createElement('h1' /* ... h1 children ... */),
  React.createElement('ul' /* ... ul children ... */)
);
```

[Understanding JavaScript Functinon Invocation and "this"](https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/)

React components can have state by setting this.state in their constructors.

All React component classes that have a constructor should start with a super(props) call.

After installing React DevTools, you can right-click on any element on the page, click “Inspect” to open the developer tools, and the React tabs (“⚛️ Components” and “⚛️ Profiler”) will appear as the last tabs to the right. Use “⚛️ Components” to inspect the component tree.

We may think that Board should just ask each Square for the Square’s state. Although this approach is possible in React, we discourage it because the code becomes difficult to understand, susceptible to bugs, and hard to refactor.

To collect data from multiple children, or to have two child components communicate with each other, declare the shared state in their parent component instead. The parent component can pass that state back down to the children via props. This keeps the child components in sync with each other and with their parent.

```jsx
// We split the returned element into multiple lines for readability, and added parentheses so that JavaScript doesn’t insert a semicolon after return and break our code.
renderSquare(i) {
  return (
    <Square
      value={this.state.squares[i]}
      onClick={() => this.handleClick(i)}
    />
  );
}
```

In React, it’s conventional to use onSomething names for props which represent events and handleSomething for the function definitions which handle those events.

Since the Square components no longer maintain state, the Square components receive values from the Board component and inform the Board component when they’re clicked. In React terms, the Square components are now **controlled components**. The Board has full control over them.

The main benefit of immutability is that it helps you build pure components in React. Immutable data can easily determine if changes have been made, which helps to determine when a component requires re-rendering.

Although re-rendering is not by itself noticeable to the user (you shouldn’t actively try to avoid it!), you might want to skip re-rendering a part of the tree that clearly wasn’t affected by it for performance reasons.

Unlike the array push() method you might be more familiar with, the concat() method doesn’t mutate the original array, so we prefer it.

React elements are first-class JavaScript objects.

Because React cannot know our intentions, we need to specify a key property for each list item to differentiate each list item from its siblings.

Even though key may look like it is passed as props, React automatically uses key to decide which components to update. There’s no way for a component to ask what key its parent specified.

It’s strongly recommended that you assign proper keys whenever you build dynamic lists. If you don’t have an appropriate key, you may want to consider restructuring your data so that you do.

## Thinking in React

### Step 1: Break the UI into a component hierarchy

### Step 2: Build a static version in React

Building a static version requires a lot of typing and no thinking, but adding interactivity requires a lot of thinking and not a lot of typing.

In simpler examples, it’s usually easier to go top-down, and on larger projects, it’s easier to go bottom-up.

Because this is a static app, the components will only return JSX??

### Step 3: Find the minimal but complete representation of UI state

Which of these are state? Identify the ones that are not:

- Does it remain unchanged over time? If so, it isn’t state.
- Is it passed in from a parent via props? If so, it isn’t state.
- Can you compute it based on existing state or props in your component? If so, it definitely isn’t state!

### Step 4: Identify where your state should live

1. Often, you can put the state directly into their common parent.
1. You can also put the state into some component above their common parent.
1. If you can’t find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common parent component.

Warning: You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.

### Step 5: Add inverse data flow

React makes this data flow explicit, but it requires a little more typing than two-way data binding.
