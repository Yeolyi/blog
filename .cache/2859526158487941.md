
> Next.js is a framework for building web applications.

The sections and pages of the docs are organized sequentially, from basic to advanced, so you can follow them step-by-step when building your Next.js application.

## Getting Started

### Installation

Next.js uses **file-system routing**, which means how you structure your files determines the routes in your application.

### Project Structure

next.config.js(Next.js 설정), middleware.ts?, instrumentation.ts?, .env

app, public 폴더

app routing convention - layout(UI that is shared between routes), page(UI that is unique to a route.), loading, not-found, error, global-error, route, template, default

[folder], [...folder], \[[...folder]]

(folder), \_folder

등등...

### React Essentials

> This page will go through the differences between Server and Client Components, when to use them, and recommended patterns.

서버와 클라이언트 컴포넌트를 통해 서버와 클라이언트에 걸치는 application을 만들 수 있고 클라단의 풍부한 interactivity와 전통적인 서버 렌더링의 성능을 모두 누릴 수 있다.

기존에는 리액트가 모든 앱을 클라이언트단(SPA처럼)에서 렌더링했지만 이제 어디서 렌더링할지 선택지를 준다.

App Router의 모든 컴포넌트는 기본적으로 서버 컴포넌트이다.

클라이언트 컴포넌트는 클라단 interactivity를 가능하게해준다. 서버에서 pre-rendered되고 클라에서 hydrated된다.

"use client" sits between server-only and client code. 이게 있는 파일에서 쓰는 것은 다 클라이언트 번들의 일부로 간주된다.

layout과 page는 기본값이 서버 컴포넌트이다.

서버 컴포넌트 모듈 그래프에 있는 애들은 다 서버에서 렌더되는 것이 보장된다. 클라 컴포넌트 모듈 그래프에 있는 애들은 서버에서 프리렌더 될 수도 있다.

Data fetch, 백엔드 리소스 접근, 민감한 정보 등등은 서버 컴포넌트에서만 가능.

Event listener, useState, lifecycle effect(useEffect?), 브라우저 api는 클라 컴포넌트에서만 가능.

가능한 클라 컴포넌트를 잎 쪽으로.

1. 모든 서버 컴포넌트를 미리 렌더(클라 컴포 안에 서버 컴포 포함)
2. 클라단에서는 리액트가 클라 컴포넌트를 렌더링하고 아까 만든 서버 컴포넌트를 그 안에 삽입.

In Next.js, during the initial page load, both the rendered result of Server Components from the above step and Client Components are pre-rendered on the server as HTML to produce a faster initial page load?? 차이가 뭐지. initial load에서는 클라 컴포넌트도 렌더링해준다는건가.

단, 클라컴포에서 서버컴포 임포트는 안되고 프롭으로 전달해줘야한다. 보통 children. 이러면 클라컴포에서 서버 컴포에 대해 알 필요가 없다.

The very same strategy of "lifting content up" has been used to avoid state changes in a parent component re-rendering an imported nested child component???

서버 컴포에서 클라 컴포로 보내는 prop은 serializable해야한다. App Router에서 network boundary는 서버 컴포와 클라 컴포 사이에 있다. Page router에서는 boundary가 getStaticProps와 getServerSideProps에 있어서 network boundary를 넘지 않았었다.

NEXT_PUBLIC으로 prefix되지 않은 환경변수는 클라단에는 빈 문자열로 보내진다. 이를 막으려면 server-only 패키지를 사용한다. window 객체를 사용하는 등의 클라이언트 전용 모듈에는 client-only 패키지를 사용한다.

...To fix this, you can wrap third-party components that rely on client-only features in your own Client Components:

```jsx
'use client';

import { Carousel } from 'acme-carousel';

export default Carousel;
```

In Next.js 13, context is fully supported within Client Components, but it cannot be created or consumed directly within Server Components. This is because Server Components have no React state (since they're not interactive), and context is primarily used for rerendering interactive components deep in the tree after some React state has been updated.

...However, context providers are typically rendered near the root of an application to share global concerns, like the current theme. 하지만 서버컴포에서는 못쓰니 다음 방법을 사용한다.

```jsx
'use client';

import { createContext } from 'react';

export const ThemeContext = createContext({});

export default function ThemeProvider({ children }) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>;
}
```

서버컴포끼리의 데이터 소통은 일반적인 JS 패턴을 사용하면 된다. 모듈 등등.

```jsx
// utils/database.ts
export const db = new DatabaseConnection();

// app/users/layout.tsx
import { db } from '@utils/database';

export async function UsersLayout() {
  let users = await db.query();
  // ...
}

// 이를 global singleton이라 한다.
```

데이터 fetch할 때 결과를 괜히 공유하려해서 컴포넌트간에 coupling을 만들지 말고 서버컴포넌트에서 fetch requests are automatically deduped되니 걱정하지 말자.

## Building Your Application

> Learn how to use Next.js features to build your application.

### Routing

> Fundamentals

- URL Segment: Part of the URL path delimited by slashes.
- URL Path: Part of the URL that comes after the domain (composed of segments).

App Router는 리액트 Server component 기반으로 작동한다.

폴더로 route를 결정하고, 파일로 UI를 만든다.

```jsx
<Layout>
    <Template>
        <ErrorBoundary fallback={<Error/>}>
            <Suspense fallback={<Loading/>}>
                <ErrorBoundary fallback={<NotFound/>}>
                    <Page/>
                </ErrorBoundary>
            </Suspence>
        </ErrorBoundary>
    </Template>
</Layout>
```

In a nested route, the components of a segment will be nested inside the components of its parent segment.

여러 파일이 있을 수 있지만 page.js와 route.js만 addressable하다. route.js는 뭔데??

Page router는 클라단 라우팅을 사용했지만 App Router는 **server-centric routing**을 사용한다. 클라가 라우트 맵을 받을 필요 없다.

하지만 Link Component를 통해 **client-side navigation**을 한다. 덕분에 navigation할 때 리로딩되지 않는다. URL이 업데이트되고 바뀌는 segment만 로드한다.

Parallel Routes, Intercepting Routes

> Defining Routes

A special page.js file is used to make route segments publicly accessible.

Special file conventions are used to create UI for each route segment. The most common are **pages** to show UI unique to a route, and **layouts** to show UI that is shared across multiple routes.

> Pages and Layouts

Page는 route에 유일하다.

A page is always the leaf of the route subtree.

layout은 children prop을 받아야한다. Root layout은 반드시 필요하며 html과 body 태그를 포함한다. Layouts do not have access to the current route segment(s). To access route segments, you can use useSelectedLayoutSegment or useSelectedLayoutSegments in a Client Component??

Only the root layout can contain <html> and <body> tags.

**Templates** are similar to layouts in that they wrap each child layout or page. Unlike layouts that persist across routes and maintain state, templates create a **new instance** for each of their children on navigation.

We recommend using Layouts unless you have a specific reason to use Template. 언제 써야할지 아직 잘 모르겠음.

<title>이나 <meta>를 직접 넣지 말고 Metadata API를 사용해야한다.

> Linking and Navigating

Link 컴포넌트와 useRouter 훅을 사용하는 방법이 있다.

usePathname은 클라 컴포에서만 쓸 수 있다.

Link의 href에 id가 있으면 그곳으로 스크롤한다.

The useRouter hook allows you to programmatically change routes inside Client Components. 별 이유 없으면 Link 쓰자.

How Navigation Works

- A route transition is initiated using <Link> or calling router.push().
- The router updates the URL in the browser's address bar.
- The router avoids unnecessary work by re-using segments that haven't changed (e.g. shared layouts) from the client-side cache. This is also referred to as partial rendering.
- If the conditions of soft navigation are met, the router fetches the new segment from the cache rather than the server. If not, the router performs a hard navigation and fetches the Server Component payload from the server.
- If created, loading UI is shown from the server while the payload is being fetched.
- The router uses the cached or fresh payload to render the new segments on the client.

On navigation, Next.js will use **soft navigation** if the route you are navigating to has been prefetched, and either doesn't include dynamic segments or has the same dynamic parameters as the current route.

navigation이랑 route가 뭐가 다른지 아직 잘 모르겠네,,

> Route Groups

In the app directory, nested folders are normally mapped to URL paths. However, you can mark a folder as a Route Group to prevent the folder from being included in the route's URL path.

Convention: A route group can be created by wrapping a folder's name in parenthesis: (folderName)

괄호 붙인건 URL path에서 빠진다. layout을 좀 더 자유롭게 지정할 수 있음. 비슷한 원리로 multiple root layout도 가능하다(대신 home page.js는 어딘가에 하나 있어야함). html과 body 태그는 각각에 필요하다.

> Dynamic Routes

[folderName]으로 만든다. layout, page, route, generateMetadata 함수에 전달된다.

```tsx
// app/blog/[slug]/page.tsx
export default function Page({ params }: { params: { slug: string } }) {
  return <div>My Post: {params.slug}</div>;
}
```

```tsx
// Statically generate routes at build time
// instead of on-demand at request time.
export async function generateStaticParams() {
  // fetch를 통해 컨텐츠를 가져오면 automatically deduplicated.
  const posts = await fetch('https://.../posts').then((res) => res.json());

  return posts.map((post) => ({
    slug: post.slug,
  }));
}
```

Dynamic Segments can be extended to catch-all subsequent segments by adding an ellipsis inside the brackets [...folderName]. 이때 params는 배열로 전달된다.

Catch-all Segments can be made optional by including the parameter in double square brackets: \[[...folderName]].

> Loading UI and Streaming

The special file loading.js helps you create meaningful Loading UI with **React Suspense**.

```jsx
export default function Loading() {
  // You can add any UI inside Loading, including a Skeleton.
  return <LoadingSkeleton />;
}
```

Navigation is interruptible, meaning changing routes does not need to wait for the content of the route to fully load before navigating to another route.

SSR도 단점이 있다. 유저가 페이지와 인터렉션하려면 페이지의 모든 데이터가 서버에서 fetch되어야하고, 서버가 이를 렌더링한 뒤, HTML, CSS, JS가 클라로 보내지면 non-interactive한 UI가 보여지고 마지막으로 리액트가 hydrate한다.

위 과정은 sequential/blocking하다. 유저에게 non-interactive page를 가능한 빨리 보여줌으로서 개선할 수 있지만 그전에 모든 data fetching이 끝나야하기에 느리다.

SSR 단점 찾아보니 TTFB(Time to First Byte)가 느리고, 페이지가 무거우면 오히려 사용자 경험이 저하되며, CDN 수준에서의 컨텐츠 캐시가 되지 않으며, 서버의 호스팅이 필요하다.

**Streaming**은 페이지의 HTML은 작은 청크로 나누고 progressively하게 보낼 수 있게 한다. Streaming works well with React's component model because each component can be considered a chunk.

Suspense를 사용해 Streaming Server Rendering과 Selective Hydration이 가능하다.

[모바일 친화성 테스트](https://search.google.com/test/mobile-friendly?url=https%3A%2F%2Fyeolyi.com%2F)란 것도 있음.

> Error Handling

The error.js file convention allows you to gracefully handle unexpected runtime errors in nested routes.

```tsx
'use client'; // Error components must be Client Components

import { useEffect } from 'react';

export default function Error({ error, reset }: { error: Error; reset: () => void }) {
  useEffect(() => {
    // Log the error to an error reporting service
    console.error(error);
  }, [error]);

  return (
    <div>
      <h2>Something went wrong!</h2>
      <button
        onClick={
          // Attempt to recover by trying to re-render the segment
          () => reset()
        }
      >
        Try again
      </button>
    </div>
  );
}
```

Errors bubble up to the nearest parent error boundary. An error.js boundary will not handle errors thrown in a layout.js component in the same segment(This intentional hierarchy keeps important UI that is shared between sibling routes (such as navigation) visible and functional when an error occurs).

루트에서 에러를 잡으려면 app/global-error.js를 사용한다. 얘는 반드시 스스로의 <html>, <body> 태그가 필요하다.

During production, the Error object forwarded to the client only includes a generic message and digest property.

> Parallel Routes

Parallel Routing allows you to simultaneously or conditionally render one or more pages in the same layout.

Parallel routes are created using named slots. Slots are defined with the @folder convention, and are **passed to the same-level layout as props**.

You can define a **default.js** file to render as a fallback when Next.js cannot recover a slot's active state based on the current URL??

Soft/Hard 표는 잘 모르겠음,,,

```tsx
// app/layout.tsx
export default async function Layout(props: {
  // ...
  authModal: React.ReactNode;
}) {
  return (
    <>
      {/* ... */}
      {props.authModal}
    </>
  );
}

// app/@authModal/login/page.tsx
import { Modal } from 'components/modal';

export default function Login() {
  return (
    <Modal>
      <h1>Login</h1>
      {/* ... */}
    </Modal>
  );
}

// To ensure that the contents of the modal don't get rendered when it's not active, you can create a default.js file that returns null.
export default function Default() {
  return null;
}
```

Catch-all routes take precedence over default.js??

Conditional Routes도 가능하다.

> Intercepting Routes

Intercepting routes allows you to load a route within the current layout while keeping the context for the current page.

[신기하네,,,](https://github.com/vercel-labs/nextgramz)

> Route Handlers

Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs.

app 디렉터리 내부에서만 가능하다. route.js|ts 파일에 정의. page.js와 같은 경로에 있을 수는 없다.

```jsx
import { NextResponse } from 'next/server';

export async function GET() {
  const res = await fetch('https://data.mongodb-api.com/...', {
    headers: {
      'Content-Type': 'application/json',
      'API-Key': process.env.DATA_API_KEY,
    },
  });
  const data = await res.json();

  return NextResponse.json({ data });
}
```

GET에서 Request 객체를 쓰거나 다른 HTTP 메서드를 쓰거나 cookies나 headers와 같은 dynamic functions를 쓰거나 Segment Config Options가 dynamic mode면 Route handler는 evaluated dynamically된다.

Route Handlers can be used for cases like handling form submissions.

아직 동기부여가 잘 안돼서 pass

>

### Rendering

Rendering converts the code you write into user interfaces.

클라이언트와 서버는 코드라 렌더링될 수 있는 두 환경이다.

Server can refer to computers in regions where your application is deployed to, the Edge Network where your application code is distributed, or Content Delivery Networks (CDNs) where the result of the rendering work can be cached.

원래 Next.js는 application을 페이지들로 나눠서 서버에서 프리렌더하고 HTML을 클라이언트로 보내 리액트가 hydrate하도록 했다. 하지만 이 방법은 초기 HTML을 interactive하게 만들기 위한 별도의 JS를 필요로 했다??

이제 서버와 클라 컴포로 컴포넌트 레벨에서 렌더링 환경을 결정할 수 있다.

> Static and Dynamic Rendering

Static route는 빌드 시점에 렌더된다(CDN에서 제공 가능). 서버와 클라 컴포 모두 가능. 대신 클라 컴포는 HTML과 JSON이 프리렌더되어 캐싱되고 결과물은 클라로 보내져 hydration된다. 서버 컴포는 서버에서 렌더되고 클라에서는 JS가 필요없다??

Dynamic route는 요청 시점에 렌더된다. 결과물이 캐싱되지 않는다. Pages router에서 getServerSideProps()와 같다.

Static Data Fetching - 기본적으로 fetch() 요청의 반환값은 캐싱된다. force-cache 옵션을 사용한다. 얘는 다음 섹션에서 더 살펴보자.

Data Fetching의 캐싱 유무에 상관 없이 dynamic function을 사용하면 렌더링도 dynamic해진다.

Dynamic functions rely on information that can only be known at request time such as a user's cookies, current requests headers, or the URL's search params.

We recommend wrapping the Client Component that uses useSearchParams() in a <Suspense/> boundary. This will allow any Client Components above it to be statically rendered.

**Dynamic data fetches** are fetch() requests that specifically opt out of caching behavior by setting the cache option to 'no-store' or revalidate to 0.

> Edge and Node.js Runtimes

In the context of Next.js, "**runtime**" refers to the set of libraries, APIs, and general functionality available to your code during execution.

코드의 일부를 렌더할 수 있는 두 개의 서버 런타임이 있다. Node.js Runtime / Edge Runtime. 기본값으로 app 디렉터리는 Node.js runtime을 사용한다.

- The Node.js Runtime (default) has access to all Node.js APIs and compatible packages from the ecosystem.
- The Edge Runtime is based on Web APIs.

위 두 개 다 streaming을 지원한다.

Serverless is ideal if you need a scalable solution that can handle more complex computational loads than the Edge Runtime. 서버리스는 부팅에 시간이 좀 걸리는 듯? 트래픽이 많지 않으면 좋지 않다.

```jsx
export const runtime = 'edge'; // 'nodejs' (default) | 'edge'
```

### Data Fetching

### Styling

- Global CSS: 예전 방식. 앱이 커지면 힘들다.
- CSS Modules: 지역 스코프를 가진 CSS 클래스.
- Tailwind CSS: Utility-first CSS framework
- Sass: CSS 전처리기. 변수, nested rules, mixins를 지원
- CSS-in-JS: CSS를 JS 컴포넌트에서 직접 삽입? dynamic/scoped 스타일 지원.

CSS Module을 기본 지원. .module.css 확장자를 사용한다.

layout.js에서 import './global.css'를 해서 앱의 모든 route에 스타일을 적용할 수 있다.

```npm
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
```

Inside tailwind.config.js, add paths to the files that will use Tailwind CSS class names. postcss.config.js는 수정할 필요 없다.

Warning: CSS-in-JS libraries which require runtime JavaScript are not currently supported in Server Components.

### Optimizing

> Images



> Fonts

> Scripts

> Metadata

> Static Assets

> Lazy Loading

> Analytics

> OpenTelemetry

> Instrumentation

### Configuring

> TypeScript

You can enable the plugin in VS Code by:

1. Opening the command palette (Ctrl/⌘ + Shift + P)
1. Searching for "TypeScript: Select TypeScript Version"
1. Selecting "Use Workspace Version"

next/link를 사용할 때 유용한 statically typed links도 실험적으로 지원한다.

Next.js 13 has **enhanced type safety**.

1. No serialization of data between fetching function and page
1. Streamlined data flow between components.

The next.config.js file must be a JavaScript file as it does not get parsed by Babel or TypeScript, however you can add some type checking in your IDE using JSDoc.

> ESLint

```json
{
  "scripts": {
    "lint": "next lint"
  }
}
```

[What's the difference between plugins and extends in eslint?](https://stackoverflow.com/questions/53189200/whats-the-difference-between-plugins-and-extends-in-eslint)

The default configuration **(eslint-config-next)** includes everything you need to have an optimal out-of-the-box linting experience in Next.js.

Next.js provides an ESLint plugin, **eslint-plugin-next**, already bundled within the base configuration that makes it possible to catch common issues and problems in a Next.js application.

If you include any ESLint rules that depend on more than the contents of a single source file and need to disable the cache, use the --no-cache flag with next lint.

```
// prettier
npm install --save-dev eslint-config-prettier
yarn add --dev eslint-config-prettier
```

```json
// ESLint config
{
  "extends": ["next", "prettier"]
}
```

```js
// .lintstagedrc.js
const path = require('path');

const buildEslintCommand = (filenames) =>
  `next lint --fix --file ${filenames
    .map((f) => path.relative(process.cwd(), f))
    .join(' --file ')}`;

module.exports = {
  '*.{js,jsx,ts,tsx}': [buildEslintCommand],
};
```

> Environment Variables

```env
// .env.local
DB_HOST = localhost;
DB_USER = myuser;
DB_PASS = mypassword;

TWITTER_USER=nextjs
TWITTER_URL=https://twitter.com/$TWITTER_USER
```

```js
// app/api/route.js
export async function GET() {
  const db = await myDB.connect({
    host: process.env.DB_HOST,
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
  });
  // ...
}
```

Non-NEXT_PUBLIC\_ environment variables are only available in the Node.js environment, meaning they aren't accessible to the browser

.env, .env.development, and .env.production files should be included in your repository as they define defaults. .env\*.local should be added to .gitignore, as those files are intended to be ignored. .env.local is where secrets can be stored.

테스트용 환경 변수도 있다.

> Absolute Imports and Module Path Aliases

Next.js has in-built support for the "paths" and "baseUrl" options of tsconfig.json and jsconfig.json files.

These options allow you to alias project directories to absolute paths, making it easier to import modules. For example:

```jsx
// before
import { Button } from '../../../components/button';

// after
import { Button } from '@/components/button';
```

Each of the "paths" are relative to the baseUrl location.

> MDX

MDX is a superset of markdown that lets you write JSX directly in your markdown files.

The Next.js plugin handles transforming Markdown and React components into HTML, including support for usage in Server Components (default in app).

@next/mdx package.

Remark, Frontmatter 등등...

> src Directory

Next.js also supports the common pattern of placing application code under the src directory.

This separates application code from project configuration files which mostly live in the root of a project.

> Draft Mode

### Deploying

Static Exports - Next.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server. 오 당장은 정적 파일로 serving하게 할 수 있는듯.

When passing data between a Server and Client Component through props, the data is still serialized (converted to a string) for use in the browser.

### Upgrading

Codemods are transformations that run on your codebase programmatically. next.js 업데이트할 때 쓰는 듯.

App Router Adoptation은 일단은 몰라도 될 듯.

## API Reference

> Next.js API Reference for the App router

## Architecture

## Community
