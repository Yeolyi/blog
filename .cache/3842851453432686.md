
```html
<style>
  body {
    width: 500px;
    margin: 0 auto;
  }

  p {
    background: aqua;
    border: 3px solid blue;
    padding: 10px;
    margin: 10px;
  }

  span {
    background: red;
    border: 1px solid black;
  }

  .positioned {
    position: absolute;
    background: yellow;
  }
</style>

<h1>Basic document flow</h1>

<p>I am a basic block level element. My adjacent block level elements sit on new lines below me.</p>

<p class="positioned">
  By default we span 100% of the width of our parent element, and our height is as tall as our child
  content. Our total width and height is our content + padding + border width/height.
</p>

<p>
  We are separated by our margins. Because of margin collapsing, we are separated by the width of
  one of our margins, not both.
</p>

<p>
  inline elements <span>like this one</span> and <span>this one</span> sit on the same line as one
  another, and adjacent text nodes, if there is space on the same line. Overflowing inline elements
  <span>wrap onto a new line if possible — like this one containing text</span>, or just go on to a
  new line if not, much like this image will do:
  <img src="long.jpg" alt="a wide but short section of a photo of several fabrics" />
</p>
```

이미지에 alt빼면 inline 요소처럼 같은줄에 있는데 이미지 파일이 없어서 그런건가?

You can use top, bottom, left, and right to resize elements if you need to.

Margin은 positioned element에 여전히 영향을 주지만 margin collapsing은 그렇지 않다.

The initial containing block has the dimensions of the viewport and is also the block that contains the <html> element.

따라서 absolute 요소는 기본적으로는 html 요소 밖에 위치하게된다.

Positioning context를 바꾸기 위해서는 absolute 요소의 상위 요소 중 하나의 position을 relative로 바꾼다.

z-index values affect where positioned elements sit on that axis; positive values move them higher up the stack, negative values move them lower down the stack.

Fixed, Sticky 생략

Sticky elements are "sticky" relative to the nearest ancestor with a "scrolling mechanism", which is determined by its ancestors' position property??
