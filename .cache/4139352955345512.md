
[soen.kr](http://soen.kr)를 읽고 몰랐던 내용이나 복습하면 좋을 내용 정리. 중간중간 무지성 질문들 있으니 나중에 돌아보자. 문법 훑어보는 목적이라서 실습 코드는 건너뛰었다.

## 1부. C 문법

> 그동안 셀 수 없을 정도로 많은 프로그래밍 언어가 개발되었다. 포트란으로부터 시작하여 코볼, 베이직, 알골 등을 거쳐 C, 파스칼과 최근의 자바, C#까지 헤아릴 수 없이 많은 종류가 있다.

하드웨어를 직접 제어할 수 있으며 크기가 작고 속도가 빠른 언어는 어셈블리밖에 없었다. 하지만 얘는 이식성이 없어 플랫폼 무관한게 목표인 UNIX와는 어울리지 않았다. 포트란이나 베이직은 효율이 좋지 못했다. 그래서 C 만듦.

> 예를 들어 파스칼이나 베이직은 교육용 언어로 분류되었고 코볼은 상업용 소프트웨어 작성에 효율적이었으며 포트란은 과학 기술용 언어로 주로 사용되었다. 또한 리스프는 인공 지능 구현에 적합했으며 어셈블리는 시스템 프로그래밍을 위한 최적의 언어였다.

컴파일러도 상품이고, 경쟁적으로 다른걸 만들다보니 이식성이 훼손됐다. 따라서 미 표준 위원회인 ANSI에서 만든 표준안이 ANSI C 혹은 C90. 그 이전은 클래식 C(K&R C). 이후 C95는 동양 언어 지원을 위한 멀티 바이트 문자 지원 등등. 강좌에서는 ANSI를 다루는 듯?

80년대 후반 소프트웨어가 하드웨어의 발전을 따라잡지 못하는 문제로 OOP가 제시됨. C++는 C에 Simula67의 문법을 참조해 만듦. 클래스, 상속, 다형성, 템플릿이 추가됨.

C++도 무분별한 기능 추가로 인한 문제가 있었는데 첫번째 표준안은 ISO 14882로 98년 발표되었다.

컴파일러는 소스 파일을 해석하여 기계어 코드로 바꾸고 그 결과를 목적 파일에 써 넣는다. 목적 파일은 운영체제가 요구하는 코드가 필요해서 바로 실행할 수 없다. 링커는 목적 파일을 운영체제에 맞게 형태를 바꾸고 스타트업이라는 추가 코드를 가지도록해 실행 파일을 만든다.

목적 파일이라는 중간 과정이 있는 이유는 여러 개의 소스를 합쳐 하나의 실행 파일을 만들어낼 수 있어야 하기 때문이다. 목적 파일은 개발 언어에 독립적인 형식을 가지고 있기 때문에 한 프로그램을 작성하는 데 여러 개의 언어를 같이 사용할 수 있다.

비주얼 C++(Visual C++)은 마이크로소프트사에서 만든 C/C++ 컴파일러이자 IDE이다.

gcc는 유닉스용 공개 컴파일러이며 C/C++ 뿐만 아니라 Ada, Pascal, Java 등의 언어도 컴파일할 수 있다.

C 프로그램은 항상 main 함수에서부터 실행을 시작한다.

C언어는 7개의 구성 요소로 나누어진다. 키워드(예약어), identifier, constant, operator, punctuator(, '', "", (), ;, []...), white space, comment.

=는 연산자처럼 보이지만 구두점이다?! 엥 뒤에 연산자 챕터에서는 대입 연산자라고 소개하는데 컴파일러 입장에서 다르다는건가;

C언어는 프리 포맷을 지원하여 여러 줄에 쓰든 한 줄에 쓰든 할 수 있다. 베이직은 프리 포맷이 아니다.

```txt
<일반적인 C 프로그램의 구조>

#include <...>
#define ...
함수의 원형
전역변수

void main()
{
     코드
}
함수
함수
함수
```

메모리 주소에 이름을 붙인 것이 변수다. 변수는 이전에 살펴본 7가지 구성 요소 중에 명칭으로 분류된다. 변수는 내부적으로 번지에 대한 위치를 가리키지만 컴파일러는 변수를 번지에 기억된 값으로 참조한다.

주소만 있으면 메모리에서 어디까지 읽어야하는지, 읽은걸 어떻게 해석할지 컴파일러는 알 수 없다. 따라서 변수의 타입에 대해서 명시해야한다.

> 변수는 저장된 메모리 위치와 함께 길이와 형태에 대한 정보를 가지는데 이런 변수의 특성을 타입(Type)이라고 한다.

기본형 타입은 수치를 저장하고, 파생형 타입은 기본형으로부터 만들어진다.

> 선언(Declaration)이란 컴파일러에게 앞으로 이런 이런 이름을 가진 어떤 타입의 변수를 사용하겠으니 준비해 달라고 부탁하는 것이다.

```c
// 이렇게도 됨
int a, b=3, c, d;
```

PRINT라는 기본적인 출력문을 언어 차원에서 제공하느느 베이직과 달리, C언어는 문법의 간결성과 이식성 확보를 위해 언어 자체에는 없고 컴파일러 제조사가 라이브러리 형태로 제공한다. C 표준에 의해 의무적으로 제공하도록 되어있다.

printf의 f는 formatting. 서식 문자열을 출력하되 %로 시작되는 서식이 있으면 이에 대응되는 뒤쪽의 인수를 넣어 포맷팅하는 과정을 먼저 거친다.

자주 쓰는건 %d, %c, %s, %f정도. f는 float. 포인터는 p, 16진수는 x.

> "%f" is the (or at least one) correct format for a double. There is no format for a float, because if you attempt to pass a float to printf, it'll be promoted to double before printf receives it. [출처](https://stackoverflow.com/questions/4264127/correct-format-specifier-for-double-in-printf)

[Why does printf specifier format %n not work?](https://stackoverflow.com/questions/54957216/why-does-printf-specifier-format-n-not-work)

```c
#include <stdio.h>

int main() {
    printf("|%d|\n", 123);
    printf("|%5d|\n", 123);
    printf("|%05d|\n", 123);
    printf("|%-5d|\n", 123);

    // 자리수 지정은 최소한의 지정이므로 만약 자리수보다 값이 더 클 경우 지정한 자리수가 무시된다.
    printf("|%5d|\n", 1234567);

    printf("\n");

    // %f는 기본적으로 소수점 이하 여섯 자리까지 출력한다.
    printf("|%f|\n", 3.14);
    printf("|%10f|\n", 3.14);
    printf("|%.2f|\n", 3.14);
    printf("|%10.2f|\n", 3.14);
    printf("|%010.2f|\n", 3.14);
    printf("|%-10.2f|\n", 3.14);
    // 반올림도 해준다.
    // nearest even 같은데... 자세히는 모르겠다.
    printf("%.3f\n", 0.1235);
    printf("%.3f\n", 0.1236);

    // 출력한 문자의 개수를 반환한다.
    printf("%d\n", printf("12345\n"));

    return 0;
}
```

printf와 달리 scanf에는 서식만 들어갈 수 있고 이외는 무시된다. 해보니까 잘 무시되는 것 같지는 않은데,,,?

scanf는 문자열을 공백에서 끊어 버리기 때문에 긴 문자열을 입력받을 수 없는데 비해 gets는 개행 코드 이전의 모든 문자를 입력받는다.

getch는 엔터키를 기다리지 않는다. 키를 누를 때까지 기다린다. 문자가 아닌 펑션키등을 누르면 getch를 한번 더 호출해 확장키의 키코드를 조사할 수 있다. [How to implement getch() function of C in Linux?](https://stackoverflow.com/questions/3276546/how-to-implement-getch-function-of-c-in-linux). getch가 없다고 뜨네 ㅠ.

그나저나 C 표준 라이브러리는 누가 만들어서 넣는거지?

> The <stdio.h> header file is part of the C standard library, and may be in any directory that the compiler searches for header files, it may be in a sub-directory to /usr/lib for example. [출처](https://stackoverflow.com/questions/28362994/where-is-my-stdio-h-in-mac)

내 컴퓨터에는 /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdio.h 등등에 있다.

getchar는 엔터를 눌러야 문자를 입력받는다.

exit은 프로그램을 강제로 종료한다. 괄호 안에는 리턴값을 적는다. -1이면 에러. 리턴값은 쉘로 전달된다.

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    exit(-1);
    printf("asd\n");
    return 0;
}
```

kbhit은 키가 눌렸는지 조사한다. getch는 대기하므로 게임에서 부적합하고 아래와 같이 사용한다.

```c
if (kbhit()) ch=getch();
```

[C data types](https://en.wikipedia.org/wiki/C_data_types). long의 크기가 달라진다.

> C 언어의 타입 정의에 int 형은 "CPU의 레지스터와 동일한 크기를 가지는 타입"으로 정의되어 있다. 즉, int형은 CPU가 가장 효율적으로 다룰 수 있는 정수형으로 정의되어 있다???

64비트에서 int가 32비트인데 찾아보니 위에 말은 사실이 아닌듯.

[Does the size of an int depend on the compiler and/or processor?](https://stackoverflow.com/a/2331835)

[Is there a relation between integer and register sizes?](https://stackoverflow.com/a/1079040)

printf하다가 찾아봤는데 unsigned는 %u를 사용한다. unsigned long은 lu인듯.

123은 크기를 보고 short 타입으로 메모리에 저장된다?! 28은 short형이지만 28L로 표기하면 4바이트의 long형 상수가 되고 123U는 부호없는 2바이트의 정수인 unsigned short가 된다.

0으로 시작하면 8진수 0x로 시작하면 16진수.

부동소수점에서 가수부는 값의 모양을 표현하며 지수부는 10의 거듭승으로 값의 크기를 표현한다. 지수부와 가수부의 크기는 float의 경우 8비트, 23비트이며 double형의 경우 11비트 52비트이다. 이런 실수 표현법은 C언어의 고유한 방식이 아니라 IEEE에서 제정한 국제 표준이다. 모든 언어가 같음.

실수형 상수에서 f를 붙이면 float, l을 붙이면 long double. %f 서식은 고정 소수점으로 실수를 출력하며 %e 서식은 부동 소수점으로 출력한다. %g 서식은 %f와 %e 중 더 짧고 간단한 방법을 자동으로 선택한다.

```c
#include <stdio.h>

int main() {
    double d = 123.456;

    printf("%f\n", d);
    printf("%e\n", d);
    printf("%g\n", d); // 0이 없어지네?

    return 0;
}
```

A는 65, 1은 49.

unsigned char가 아니어도 아스키가 127까지만 있어서 ㄱㅊ.

형변환은 어떻게 컴파일될까?

Word 크기가 4바이트일 때 short를 할당하면 가져와서 앞에 비트를 날리나?

> 키보드로 직접 입력할 수 없는 문자들은 좀 특수한 방법으로 표현하는데 이를 확장열(Escape Sequence)이라고 한다.

> 베이직이나 파스칼, 자바같은 언어는 별도의 문자열 타입을 제공하지만 C언어는 별도의 문자열 타입을 제공하지 않는다. 왜냐하면 문자열이란 문자형 변수의 배열로 표현할 수 있고 포인터와 함께 사용하면 훨씬 더 유연하게 활용할 수 있기 때문이다.

> 제일 끝에 있는 \0는 여기가 문자열의 끝임을 알리는 역할을 하며 널 종료 문자라고 한다. 메모리는 연속적인 공간이기 때문에 그 끝을 명확히 표시해야 한다.

> 열거형(Enumeration)이란 변수가 가질 수 있는 가능한 값들을 나열해 놓은 타입이다.

```c
int main() {
    enum { EAST,
           WEST,
           SOUTH,
           NORTH } mark;

    mark = 50;

    // 이런 짓도 된다. 뜻이 같으니까,,,
    enum { man = 1,
           woman = 2,
           girl = 2 } human;

    // 열거형 타입을 정의하고 이를 통해 변수를 선언할 수 있다.
    // 타입에 붙여지는 이름을 태그라 한다.
    enum origin { EAST2,
                  WEST2,
                  SOUTH2,
                  NORTH2 };

    // 예시 코드와 다르게 enum이 앞에 붙어있어야된다.
    // must use 'enum' tag to refer to type 'origin'
    // C 컴파일러는 태그를 타입으로 인정하지 않는다는 듯. 최신 버전도??
    // 아 밑에 써있네.
    // C 문법은 열거형 변수를 선언할 때 반드시 enum fruit a; 식으로 enum을 앞에 붙여야한다.
    // 이후 예제부터는 cpp로 간다.
    // cpp도 #include <stdio.h>가 되나보네,,
    enum origin mark2;

    return 0;
}
```

[Enum in C is not throwing an error on invalid input](https://stackoverflow.com/questions/21683289/enum-in-c-is-not-throwing-an-error-on-invalid-input)

[Variable-length array](https://en.wikipedia.org/wiki/Variable-length_array). 구현은 automatic variable과 연관되어있는듯.

구조체 전체의 크기는 멤버들 크기의 총합과 같다? 4의 배수로 맞췄던 것 같은데 그건 union이었나...

```cpp
#include <stdio.h>

struct {
    char Name[12];
    int Age;
    double Height;
} Friend;

int main() {
    // 식이 수정할 수 있는 lValue여야합니다.
    // Friend.Name = "ASD";

    Friend.Age = 123;
    int *ptr = (int *)&Friend.Name;
    // 구조체의 멤버는 선언된 순서대로 메모리에 할당된다.
    printf("%d, %d\n", Friend.Age, *(ptr + 3));
    return 0;
}
```

사용자 정의형 타입은 typedef 타입정의 타입이름;의 형태이다.

> X형의 데이터 타입을 정의하는 방식은 요령만 알면 생각보다 간단하다. X형의 변수를 선언하는 문장에서 변수를 타입명으로 바꾸고 앞에 typedef키워드만 붙이면 된다.

bool을 1바이트로 정의하든 4바이트로 정의하든 속도의 차이가 없다,,,?

> 여러 개의 명령을 하나의 명령인 것처럼 묶을 때는 중괄호 { }를 사용하며 { }로 묶여진 다수 개의 문장을 복문 또는 블록(block)라고 한다.

블록은 하나의 문장으로 취급되므로 문장이 들어갈 수 있는 위치라면 블록도 언제나 들어갈 수 있다.

> C89 and earlier versions only support declaration statements at the head of a block. [For loop says expression syntax error when initializing integer in the loop](https://stackoverflow.com/questions/3588035/for-loop-says-expression-syntax-error-when-initializing-integer-in-the-loop)

```c
// 이런 형태의 무한 루프도 가능하다.
for (i=1;;i++) {
     //...
}

// 문자 리터럴과 덧셈이 된다.
printf("%c\n", i + '0');
```

```cpp
#include <stdio.h>

int main() {
    char c;
    scanf("%c", &c);
    switch (c) {
        case '1':
            printf("One\n");
            break;
        case '2':
            printf("Two\n");
            break;
        default:
            printf("Other\n");
            break;
    }
    return 0;
}
```

문자형은 1바이트의 정수형과 같으므로 switch문에 사용할 수 있다.

case에 break가 있는지 항상 확인하자.

> getch 함수는 A, B, 1, 2 같은 문자키가 눌러졌을 때 문자를 바로 돌려 주지만 커서 이동키나 펑션키같이 문자가 할당되지 않은 확장키에 대해서는 0xE0 또는 0의 특이값을 리턴하도록 되어 있다.

블록의 끝을 제외하고는 레이블을 달아 goto할 수 있다. 물론 다른 함수로의 goto는 안된다. goto는 컴퓨터가 알아들을 수 있는 유일한 제어문이다.

for안에 switch안에 case안에 continue가 있다면 컴파일러는 이걸 어떻게 처리할까?

> 자료와 정보는 비슷한 것 같지만 많이 다르다. 자료는 불규칙하게 널려 있는 여러 가지 형태의 수치나 문자열이며 정보는 인간이 곧바로 사용할 수 있도록 정리된 유용한 것이다.

나눗셈 연산자는 피연산자중에 실수가 하나라도 있으면 결과도 실수형이 된다.

% 연산자의 피연산자로 실수형을 사용하면 에러로 처리된다.

```c
a = -1;
// 여기서의 -는 부호 연산자가 아니라 상수의 한 부분이다.

a+(-b)
// 이게 부호 연산자.
```

대입 연산자의 좌변에는 좌변값(lvalue, left value)만 올 수 있다. 즉 실제 메모리를 점유하고 있고 그 값을 바꿀 수 있는 대상이다.

나중에 또 살펴보겠지만 배열 이름은 좌변값이 아니다.

```c
// 연산자는 값을 리턴하기에 아래와 같은 사용이 가능하다.
int a, b, c;
a = b = c = 5;
```

```c
// 아래 두 while문은 다르다.
while (++i < 5);
while (--i < 5);

// 아래 두 for문을 동일하다.
// 조건식과 증감식이 별개로 실행되기 때문이다.
for (i=0;i<10;i++);
for (i=0;i<10;++i);

// 얘는 상수를 증가시키려는 셈이라서 에러
a++++;
// 얘는 돼??
++++a;
```

```c
#include <Turboc.h>

void main() {
     int i=3;
     // calling convention에 의해 뒤쪽 인수부터 평가하기에
     // 4 4가 출력된다.
     // 컴구에서 배웠지만 뒤쪽부터 평가해야 가변인수 다루기 편해진다.
     printf("%d, %d\n",i,++i);
}
```

C 스펙에서 undefined는 동작이 정의되지 않았다는 뜻, unspecified는 여러 방법 중 어떤 것을 사용하라는 강제가 없다는 뜻.

C 언어에서 0은 거짓, 그 이외의 모든 값은 참을 표현한다.

단축 평가를 잘 활용하려면 비용이 큰 피연산자를 뒤에 두는 것이 좋다.

& 연산자를 활용해 특정 비트를 강제로 0으로 만드는 연산을 mask off라 한다. |를 써서 1로 만드는건 mask on.

^ 연산자로 비트를 반전시킬 수 있다. 마스크 반전.

```c
// a*60
a<<6 - a<<2;
```

> In computing, a nibble is a four-bit aggregation, or half an octet. It is also known as half-byte or tetrade.

```c
// 쉼표도 연산자이다. 중괄호를 쓸 수 없는 환경에서 두 표현식을 묶는 역할을 한다.
for (i=1,j=1; i<5; i++,j+=2)
```

sizeof도 연산자다. 함수가 아닌듯?

> sizeof 연산자는 사용자가 직접 계산해야 할 변수의 크기를 컴파일러가 대신 계산해 주는 연산자이다.

```cpp
#include <stdio.h>

int main() {
    printf("%lu\n", sizeof("12345"));
    char str[] = "12345";
    printf("%lu\n", sizeof(str));
    printf("%lu\n", sizeof(str[0]));
    //  warning: ISO C++11 does not allow conversion from string literal to 'char *'
    char *str2 = "12345";
    printf("%lu\n", sizeof(str2));
    char *str3;
    printf("%lu\n", sizeof(str3));
    return 0
}
```

> 구조체는 정렬방식이라는 컴파일러 옵션에 따라 크기가 약간씩 달라질 수도 있기 때문에 직접 계산하면 틀릴 위험도 있다. 이럴 때는 크기를 직접 계산하지 말고 반드시 sizeof 연산자를 사용해야 한다.

> 프로그래머가 해야 할 잡스러운 계산을 컴파일러가 대신하는 것이므로 적극적으로 활용하도록 하자. (sizeof 내용)

> 비트 연산자와 관계 연산자는 많이 헷갈리는데 데니스 리치의 The C Programming Language에도 이 두 연산자의 우선 순위를 특히 조심하라고 강조되어 있다.

```cpp
// 결합 순서가 오른쪽 우선이다.
a=b=c=3;
```

```cpp
#include <stdio.h>

int main() {
    int i = 3;
    int d = 2.17;
    // i가 잠시 실수형으로 확장. 상승 변환.
    // 대입할 때 하강 변환
    int j = i + d;
    printf("j=%d\n", j);

    return 0;
}
```

> 1. 이항 연산시 양변의 타입이 다르면 큰 쪽으로 상승 변환된다. 그래야 가급적이면 정확한 계산을 할 수 있다.
> 2. 대입 연산시 좌변의 타입을 따른다. 값을 대입받을 변수의 능력치를 초과할 수는 없기 때문에 대입되는 값이 변수보다 더 크면 잘라낸다.
> 3. 함수 호출시 실인수와 형식인수의 타입이 다르면 형식인수의 타입을 따라간다. 함수 호출 과정에서의 인수 전달은 결국 대입 동작이기 때문에 2번 규칙과 같은 규칙이다.
> 4. 캐스트 연산자를 사용하면 강제로 타입을 변환할 수 있다. 이 변환은 암시적인 산술 변환 규칙이 아니라 사용자가 직접 지정한 명시적 변환이다.
> 5. 수식내에서 사용될 경우 char, unsigned char, enum형은 int형으로 자동 확장되며 float형은 double형으로 확장된다.

5번이 있어야 연산 중 오버플로우가 발생하지 않는다. 이래야 short a, b; int c = a + b;가 가능하다.

> 함수는 크게 표준 함수와 사용자 정의 함수로 구분할 수 있다. 표준 함수는 C언어와 함께 작성되어 제공되는 것이며 컴파일러와 함께 배포된다.

[Where does GCC find printf ? My code worked without any #include](https://stackoverflow.com/a/71759399)

> C는 명칭 뒤에 괄호가 있어야 함수 호출문으로 인식하며 괄호가 없으면 함수의 시작 번지를 나타내는 포인터 상수가 되어 버린다.

> 함수별로 특정 기능을 담당하도록 프로그램의 기능을 분할해 놓으면 코드의 구조가 만들어지기 때문에 관리하고 재사용하기 편리하다. C언어를 구조적 프로그래밍(Structural Programming) 언어라고 하는 이유가 바로 여기에 있다.

> ... main 함수에서 return문은 exit(0)와 효과가 같다.

파스칼이나 비주얼 베이직에는 C의 함수에 해당하는 두가지 개념이 있다.

- 함수(function) : 특정 계산을 수행하며 리턴값이 있다. 반드시 수식내에서만 사용할 수 있으며 함수 단독으로 문장을 구성할 수 없다. 이 경우는 수학적 의미의 함수와 거의 유사하므로 적합한 용어 사용예라 할 수 있다.
- 프로시저(procedure) : 특정 작업을 수행하며 리턴값이 없다. 리턴값이 없기 때문에 수식내에서는 사용할 수 없으며 단독으로 문장을 구성할 수는 있다. C의 void 함수가 이에 해당한다.

파스칼은 함수 내에 지역 함수를 정의할 수 있어 함수끼리 계층을 이룰 수 있다.

[One-pass compiler](https://en.wikipedia.org/wiki/One-pass_compiler). 컴파일을할 때 번역을 몇 번에 나눠서 하느냐에 따라 1패스, 2패스...로 나뉜다. 어셈블리는 레이블 주소값을 알아야하기에 2패스. 초기 C언어는 문법 구조가 복잡해 컴파일이 느려 1패스로 할수밖에 없었다. 따라서 함수의 원형(prototype)이 필요해졌다.

쓰는 함수를 먼저 정의해도 되지만 파일 크기 커지면 귀찮고 상호 호출이면 이 방법도 안된다.

> 요약하자면 원형 선언이 필요한 이유는 C 컴파일러가 1패스 방식을 사용하며 딱 한 번 읽어서 번역을 하기 때문에 뒷부분에 나올 함수에 대한 정보를 미리 제공해야 하기 때문이다.

C++은 인수 목록에 따른 다형성을 지원하기 때문에 구형 C 컴파일러와 다르게 함수의 원형에서 인수 리스트를 생략할 수 없다.

> 표준 함수의 원형을 미리 작성해 놓은 것을 헤더 파일이라 한다.

최신 c++ 표준에서는 헤더 파일에 별도의 확장자를 붙이지 않는다.

하나의 실행 파일을 만들기 위한 소스를 여러 개로 나누어 개발하는 방식을 모듈 분할 컴파일 방식이라고 한다. 각 파일들은 다른 파일의 헤더만 참고하면 된다. 이러면 컴파일할 때 수정한 파일만 컴파일하면 된다.

gcc는 컴파일과 링킹 모두 해주는 듯? 따로 하고 싶으면 -c -o등을 주면 되는 것 같다.

> cpp 파일에는 주로 함수의 코드가 작성되며 헤더 파일에는 원형이나 타입, 매크로 등 **실제 코드를 생성하지 않는 선언만 작성**하는 것이 일반저깅다.

함수 이름이 오브젝트 파일에 저장되나? 링킹할 때 뭐가 어디로 가야되는지 어떻게 알지,,

함수의 인수 전달 방식에 따라 call by value와 call by reference로 나뉘며 argument 값의 변경 여부에 따라 나뉜다.

> 함수 호출시 전달되는 대상이 실인수 그 자체가 아니라 실인수의 값이기 때문에 이런 호출 방식을 값 호출이라고 부른다. 값 호출의 특징은 형식 인수가 함수내에서 변경되더라도 실인수에는 전혀 영향을 미치지 못한다는 것이다.

[Passing by reference in C](https://stackoverflow.com/questions/2229498/passing-by-reference-in-c). C에는 call by reference는 없고 포인터로 흉내낸다.

> The C language is pass-by-value without exception. Passing a pointer as a parameter does not mean pass-by-reference.

입력용 인수, 출력용 인수, 입출력용 인수가 있다.

C++은 레퍼런스로 call by reference를 지원한다.

> 전처리기는 말 그대로 "앞서 먼저 처리하는 명령"이라는 뜻인데 컴파일하기 전에 소스를 재작성하는 역할을 한다.

#include는 파일을 읽어와 현재 위치에 삽입한다. C에서 제공하는 표준 헤더파일은 <>로, ""는 사용자가 직접 작성한 헤더 파일을 포함한다.

#include 명령은 중첩 가능하다. 포함한 파일이 다른 파일을 포함하고 있다면 해당 파일도 불러와진다. 같은 파일을 여러번 include하면??

값을 가지지 않는 #define 매크로도 가능하다. 이 경우 주로 조건부 컴파일 지시자와 함께 사용되며 존재 유무만으로 의미를 가진다.

```cpp
// 일련의 값에 이름을 붙일 때 아래와 같은 방법도 사용한다.
enum { LEFT=75, RIGHT=77, UP=72, DOWN=80 };
```

```cpp
// 이런 것도 된다.
#define clearprintmsg(x,y,str) \
     { clrscr(); \
     gotoxy(x, y); \
     puts(str); }
```

include하는 파일의 내용물을 바꿔버릴 수도 있기에 #include 이후 #define하는 것이 좋다. 다만 컴파일 옵션이나 환경 정의를 하는 매크로는 include 이전에 올 수도 있다.

> Storage Class란 변수가 저장되는 위치에 따라 결정되는 변수의 여러 가지 성질을 의미한다.

- 전역: extern, 정적 데이터 영역에 저장, 함수 외부에 선언, 프로그램 전체에서 사용, 프로그램 종료시 파괴, 0으로 초기화.
- 지역: auto, 스택, 함수 내부에 선언 및 사용, 함수 종료시 파괴, 초기화 안됨
- 정적: static, 정적 데이터 영역, 함수 내부에서 선언 및 사용, 프로그램 종료시 파괴, 0으로 초기화
- 레지스터: register, CPU 레지스터에 저장, 함수 내부에서 선언 및 사용, 함수 종료시 파괴, 초기화 안됨

전역변수는 컴파일러에 의해 초기화된 상태로 실행 파일에 배치되므로 초기화에 별도의 시간이 소요되지 않는다.

> 지역변수는 함수가 자신이 필요로 하는 모든 정보를 다 가질 수 있도록(Self Contained) 해 줌으로써 함수의 독립성을 높여 준다.

> 재귀 호출이나 상호 호출같은 특별한 기법은 지역변수가 있어야만 사용할 수 있다. 이런 기법에 대해서는 다음에 배우게 되겠지만 함수가 호출될 때마다 새로운 변수가 생성되어야만 가능한 기법이다. 재귀 호출이 가능하기 위해서는 각 호출시마다 고유의 값을 유지해야 하는데 전역변수로는 이런 기법을 구사할 수 없다.

지정자를 생략하면 자동으로 auto이다.

extern은 변수가 외부 어딘가에 선언되어있음을 알린다. 전역번수가 다른 외부 모듈에 선언되어있을 때 사용된다. 전역변수는 정적 데이터 영역에 생성되기에 외부 변수(external variable)이라고도 한다. 함수 내부에서 extern 선언을 하면 함수 내부에서만 유효하다.

정적변수의 초기화는 함수가 최초로 호출될 때 한번만 이루어진다. 호출 전에 안하나? 외부 정적변수는 전역변수와 다르게 외부 모듈로 알려지지 않아 extern으로도 쓸 수 없다.

정적 함수는 함수 앞에 static이 붙으며 외부에서 해당 함수를 호출할 수 없다.

> 컴파일러는 하나의 명칭에 대해 통용 범위가 겹쳐 있을 경우 좁은 범위를 가지는 명칭에게 우선권을 줌으로써 모호한 상황을 극복한다.

```cpp
// C++에서는 가려진 전역변수를 참조할 수 있다!!
printf("global i=%d\n",::i);
```

{} 괄호 안에서만 통용되는 범위를 블록 범위라 한다. for문에서 i 쓰는 것 생각해보자.

선언은 컴파일러에게 대상의 정보를 알릴 뿐이니 메모리를 사용하지 않고 실제 코드를 생성하지 않는다. 중복 선언할 경우 내용이 다르지만 않다면 상관없다. 정의는 대상을 실제로 만들며 항상 선언을 겸한다. 실제 대상을 만들기에 중복되어서는 안된다.

> 지역변수의 경우 정의와 선언이 완전히 일치하며 만든 영역에서만 사용하므로 별도의 선언을 할 수도 없고 할 필요도 없다. 그래서 지역변수는 정의만 가능한 대상이지만 일반적으로 "선언한다"라고 하지 "정의한다"라고는 하지 않는다?? 전역변수의 경우는 int i;가 정의이고 extern int i;가 선언으로 분명히 구분되지만 관습적으로 전역변수 정의문인 int i; 도 선언문이라고 부른다.

> 그래서 컴파일러 제작사들은 자주 사용되는 공통적인 함수들을 미리 만들어서 컴파일러와 함께 배포하는데 이를 표준 함수라고 하며 표준 함수들의 집합을 런타임 라이브러리(CRT)라고 부른다.

[Why hypot() function is so slow?](https://stackoverflow.com/questions/3764978/why-hypot-function-is-so-slow)

floor : 주어진 인수보다 크지 않은 최대 정수, ceil : 주어진 인수보다 작지 않은 최소 정수. 타입 캐스팅으로 int에 대입하면 소수점을 무지성 날린다.

> 실수 x를 반올림한 값 = floor(x+0.5)

```c
#define banollim(x,dig) (floor((x)*pow(10,dig)+0.5)/pow(10,dig))
```

```c
if ((a>10) && (a<50) { ... }
if (abs(a-30) < 20) { ... }
```

> srand는 난수 발생기에 난수를 발생시키는 시작점(seed)를 제공하며 난수 발생기는 이 시작점을 기준으로 하여 난수를 발생시킨다.

> 실수 난수가 필요하면 먼저 충분한 크기의 정수 난수를 구하고 필요한 유효자리수만큼 10의 거듭승으로 나눈다.

> ctime이 변환 결과를 저장하기 위해 사용하는 버퍼는 라이브러리에서 미리 할당해 놓은 정적 메모리 영역이며 이 영역은 asctime, gmtime, localtime 등의 함수들이 공유한다. 따라서 상기 함수 중 하나를 호출하면 다른 함수가 작성한 문자열은 파괴되므로 변환한 문자열을 계속 사용하려면 사본을 복사해 두어야 한다. ... 시간 관련 함수들이 버퍼를 공유하는 이런 설계는 이후 멀티 스레드에서 문제거리가 된다. C 라이브러리 함수를 만들 때는 멀티 스레드라는 것이 없었기 때문에 이런 점을 미처 고려하지 못했다.

> gmtime, localtime 함수는 둘 다 time_t형의 값을 tm 구조체로 변환하는데 gmtime은 세계 표준시로 변환하며 localtime은 지역시간으로 변환한다. ... 이 두 함수도 라이브러리에 정적으로 할당되어 있는 tm 구조체를 사용하므로 한 함수가 구해 놓은 정보는 다른 함수를 호출하면 파괴된다.

월이 0부터 시작하네??

```cpp
#include <stdio.h>
#include <time.h>

int main() {
    time_t t;
    time(&t);
    printf("%s", ctime(&t));
    // Mon Mar 13 01:40:21 2023

    tm *pt;
    time(&t);
    pt = localtime(&t);
    printf("현재 시간 %d년 %d월 %d일 %d시 %d분 %d초입니다.\n",
           pt->tm_year + 1900, pt->tm_mon + 1, pt->tm_mday,
           pt->tm_hour, pt->tm_min, pt->tm_sec);

    char Format[128];
    // 여러 포맷팅 설정이 가능하다. 
    strftime(Format, 128, "%Y %B %d %A %I:%M:%S %p", localtime(&t));
    puts(Format);

    // return 안해도 에러 안뜨네?
    // https://stackoverflow.com/questions/19293642/why-does-the-main-function-work-with-no-return-value
}
```

```cpp
#include <time.h>

#include <iostream>

using namespace std;

int main() {
    for (int i = 0; i < 10; i++) {
        // clock returns the amount of time spent *in your program*.
        int first_clock = clock();
        int first_time = time(NULL);

        while (time(NULL) <= first_time) {
        }

        int second_time = time(NULL);
        int second_clock = clock();

        cout << "Actual clocks per second = " << (second_clock - first_clock) / (second_time - first_time) << "\n";

        cout << "CLOCKS_PER_SEC = " << CLOCKS_PER_SEC << "\n";
    }

    return 0;
}
```

[Why is CLOCKS_PER_SEC not the actual number of clocks per second?](https://stackoverflow.com/questions/10455905/why-is-clocks-per-sec-not-the-actual-number-of-clocks-per-second)

> 시스템 속도에 상관없이 일정 시간동안 어떤 작업을 하고 싶다면 clock 함수로 구한 시간을 이용하면 된다.

그나저나 포인터 변수와 배열 이름의 차이 중 하나가 sizeof의 결과값인듯?

[Order of local variable allocation on the stack](https://stackoverflow.com/questions/1102049/order-of-local-variable-allocation-on-the-stack)

[Does stack grow upward or downward?](https://stackoverflow.com/questions/1677415/does-stack-grow-upward-or-downward)

```cpp
#include <stdio.h>

int main() {
    // 지역 변수 순서는 컴파일러 마음인듯?
    int temp;
    int i = 1234;
    int arr[5];
    arr[-1] = 5678;
    printf("%d\n", i);
    printf("%p, %p, %p\n", &temp, &i, arr);

    // 이러면 순서가 강제된다. 
    struct {
        int x;
        int arr[5];
    } locals;

    printf("%p, %p\n", &locals.x, locals.arr);
    locals.x = 1234;
    locals.arr[-1] = 5678;
    printf("%d\n", locals.x);
}
```

> 배열명이 단독으로 사용되면 배열의 시작번지값을 가지는 포인터 **상수**이다.

> 배열명은 포인터 상수이되 단, 예외가 있다. sizeof 연산자의 피연산자로 사용될 때만은 포인터로 취급되지 않고 배열 그 자체로 취급된다.

```c
// 여기서 =는 구두점. 변수 선언문과 초기값을 구분한다.
int i=3;

// 여기서 =는 대입 연산자.
int i;
i = 3;

// 배열 초기화에 사용되는 = 기호는 구두점이기에 아래는 불가능하다.
int arr[5];
arr = { 4, 8, 3, 69, -8};
```

C는 초기값이 배열 크기보다 적을 경우 나머지 배열 요소들을 전부 0으로 초기화한다.

```c
int ar[2][3]={1,2,3,4,5,6};
int ar[2][3]={{1,2,3},{4,5,6}}
int ar[2][3]={
     {1,2,3},
     {4,5,6},
};
int ar[2][3]={{1},{4,5,6}};
int ar[][3]={{1,2,3},{4,5,6}};
// error: array has incomplete element type 'int[]'
int ar[3][] = {{1, 2, 3}, {4, 5, 6}};
```

> In computer science, a lookup table (LUT) is an array that replaces runtime computation with a simpler array indexing operation. [Lookup table](https://en.wikipedia.org/wiki/Lookup_table)

룩업 테이블은 보통 한 함수만 사용하는데다 읽기 전용인 경우가 많으므로 static으로 선언하는 것이 좋다.

```c
i = 3*4 // 연산자
*pi // 연산자
int *pi // 구두점
```

> T형 포인터 변수 px에 정수 i를 더하면 px=px+(i\*sizeof(T))가 된다.

```cpp
#include <stdio.h>

int main() {
    int a = 0x01020304;
    char *p = (char *)&a;
    printf("%d\n", *p);
    printf("%d\n", *(p + 3));
    return 0;
}
```

```cpp
#include <stdio.h>

int main() {
    int ar[] = {1, 2, 3, 4, 5};
    int *p1, *p2, *p3;

    p1 = &ar[0];
    p2 = &ar[4];
    p3 = p1 + (p2 - p1) / 2;

    printf("중간의 요소 = %d\n", *p3);
}
```

```cpp
#include <stdio.h>

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int i, *ptr;
    ptr = arr;
    for (i = 0; i < 5; i++) {
        // *(ptr++)도 결과는 같다.
        // *++ptr은 다음번지로 이동한 후 값을 읽는다.
        // (*ptr)++은 ptr은 그대로고 메모리 내용이 증가한다.
        // ++(*ptr) 혹은 ++*ptr은 위와 같은데 순서만 다르다. 
        printf("%d\n", *ptr++);
    }
    return 0;
}
```

void형 포인터는 임의의 대상체를 가리킬 수 있다. 캐스팅이 필요 없다. \* 연산자와 증감 연산자를 쓸 수 없다.

((int \*)vp)++는 캐스팅 결과가 좌변값이 아니므로 불가능하다.

```c
// void 포인터로 여러 종류의 포인터들을 퉁칠 수 있어 유용하다.
void *memset(void *s, int c, size_t n);
```

> 참고로 임의의 타입을 가리키는 void라는 키워드는 클래식 C에는 없었다. 그래서 클래식 C에서는 타입없이 메모리의 한 지점을 가리키는 용도로 1바이트 단위로 이동되는 char *를 대신 사용했었다. 그러나 이렇게 되면 char *형에 다른 타입의 포인터를 대입할 때마다 캐스트 연산자가 필요해서 무척 불편하며 char *가 정말 char형 변수를 가리키는 것과 임의의 타입을 가리키는 것이 구분되지 않아 실수의 가능성도 무척 높다. 그래서 ANSI C표준에서 void라는 타입을 추가했으며 임의 타입의 포인터가 필요할 때 void *를 쓰기로 한 것이다.

```cpp
#include <stdio.h>

int main() {
    int *p;
    printf("%d %d\n", p == NULL, p == 0);
    // error: comparison between pointer and integer ('int *' and 'int')
    printf("%d\n", p == 1);
    return 0;
}
```

0도 되네?

> 최근의 운영체제들은 요청한 만큼 메모리가 남아 있지 않을 경우 가상 메모리 공간을 늘려서라도 필요한 메모리를 만들어 줄 정도로 친절하다.

malloc은 엠얼록!!!

> size_t는 메모리의 양을 나타내는 단위인데 \_t로 끝나는 사용자 정의 타입은 표준에 의해 반드시 정의하도록 되어 있으므로 기본 타입과 거의 대등한 자격을 가진다

malloc은 필요한 메모리를 바이트 단위로 전달받지만 calloc은 요소의 개수와 요소의 크기 두 개로 나누어 전달받는다. 또한 할당된 메모리를 0으로 초기화한다.

realloc은 할당된 메모리의 크기를 바꾸어 재할당한다. 기존 메모리 크기를 전달받지 않네?? 내부적으로 알 수 있는 방법이 있나,,,

[How does realloc know how much to copy?](https://stackoverflow.com/questions/3476448/how-does-realloc-know-how-much-to-copy)

생각해보니까 free도 사이즈 정보 없이 가능하네.

```cpp
#include <malloc/malloc.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    int* ptr = (int*)malloc(1234);
    // Having a separate size modifier for size_t ensures you're using the correct size.
    printf("%zu\n", malloc_size(ptr));
}
```

> A printf format specifier follows the form %[flags][width][.precision][length]specifier.
>
> u is a specifier meaning "unsigned decimal integer".
>
> l is a length modifier meaning "long".
>
> [What's the difference between %ul and %lu C format specifiers?](https://stackoverflow.com/questions/23852073/whats-the-difference-between-ul-and-lu-c-format-specifiers)

> The z portion is a length specifier which says the argument will be size_t in length. [What's the correct way to use printf to print a size_t?](https://stackoverflow.com/questions/940087/whats-the-correct-way-to-use-printf-to-print-a-size-t)

```c
// main함수의 원형
int main(int argc,char *argv[],char *env[]);
// main함수의 첫번째 인수를 프로그램 이름이기에 argc는 항상 1 이상이다.
```

[Is char \*envp[] as a third argument to main() portable](https://stackoverflow.com/questions/10321435/is-char-envp-as-a-third-argument-to-main-portable)

> env 인수가 아니더라도 환경 변수를 조사할 수 있는 다른 방법이 있기 때문에 실질적으로 사용되지 않는다. 무시해 버리자.

[What's the relationship between "a" heap and "the" heap?](https://stackoverflow.com/questions/756861/whats-the-relationship-between-a-heap-and-the-heap)

void\*\*는 대상체의 크기가 명확하므로 void형 포인터의 규칙 대신 일반 포인터의 규칙이 적용된다.

강좌에 따르면 C는 다차원 배열을 지원하지 않는다. 즉, C의 모든 배열은 내부적으로 1차원이다. 하지만 배열 요소로 또 다른 배열을 사용할 수 있으므로 외부적으로는 다차원 배열을 지원한다???

```cpp
#include <stdio.h>

void arDump(void *array, int length) {
    for (int i = 0; i < length; i++)
        printf("%02X ", *((unsigned char *)array + i));
    printf("\n");
}

int main(void) {
    unsigned char ari[2][3] = {{1, 2, 3}, {4, 5, 6}};
    // 부분 배열이 온전하게 배열로 대접받는다. 
    arDump(ari, sizeof(ari));
    arDump(ari[0], sizeof(ari[0]));
    arDump(ari[1], sizeof(ari[1]));
}
```

베이직같은 언어는 다차원 배열만 지원해서 부분 배열이라는 개념이 없다. 오로지 전체 배열을 통해 배열의 최하위 요소에 접근할 수 있다.

> 배열을 단순히 사용하기만 한다면 과연 2차원 배열로 보든 배열의 배열로 보든 전혀 차이점이 없다. 그러나 배열이 내부적으로 어떻게 처리되는가에 따라서 큰 차이점이 발생하는데 바로 ① 첨자 연산 방법과 ② 부분 배열의 자격 문제가 달라진다. 다차원 배열에서는 부분 배열만 단독으로 사용할 수 없지만 배열의 배열에서는 부분 배열 단독으로도 배열로 인정된다는 큰 차이점이 있다. 다음 예제는 부분 배열이 온전하게 배열로 대접받는다는 것을 보여준다.

[]는 구두점같지만 첨자 연산을 하는 포인터 연산자이다.

> ptr이 임의의 배열을 가리키는 포인터이고 n이 정수일 때 ptr[n] = \*(ptr+n)

따라서 2[arr]와 같은 사용도 가능하긴 하다.

> 베이직같은 고급 언어들의 다차원 배열 참조 연산은 C의 그것과는 상당히 다르다. T arr[A,B,C]라는 3차원 배열에 arr[a,b,c]를 읽으면 \*(arr+(aBC+bC+c)\*sizeof(T))식으로 한 번에 최종 요소값을 읽어낸다. C와는 달리 첨자 연산이 따로 정의되어 있으므로 최종 요소만 읽을 수 있으며 부분 배열을 개별적으로 액세스하는 것은 허가되지 않는다.

2차원 int 배열은 메모리 상에서는 일렬로 int들이 있는거 아닌가? 왜 배열의 이름이 int\*형이 아니지? arr+2를 한다고 int\*를 가르키는 포인터가 나오는게 아니지 않나? 아 배열 이름에서 역참조를 하면 주소값이 나온다,,,? 배열 이름은 배열이 저장된 곳과 다른 별개의 곳에 위치한 변수?

> The answer is based on the idea that C doesn't really have 2D arrays - it has arrays-of-arrays. [How are multi-dimensional arrays formatted in memory?](https://stackoverflow.com/questions/2565039/how-are-multi-dimensional-arrays-formatted-in-memory)

> 컴파일러가 ar을 2차 정수 배열로 인식한다기 보다는 정수형 부분 배열의 1차 배열로 인식한다는 것을 확인할 수 있다.

[Why can't we use double pointer to represent two dimensional arrays?](https://stackoverflow.com/questions/4470950/why-cant-we-use-double-pointer-to-represent-two-dimensional-arrays)

뭔가,,, 뭔가 헷갈리게 써져있음. 정적 배열이 2중 포인터를 쓰는 것처럼 써져있는데? 위에 링크 답변이랑 댓글 보는게 나을 듯. 다시 읽어보니까 좀 알 것 같기도.

> \*연산자는 피연산자의 크기만큼을 읽어내는데 ...

```cpp
// 포인터 배열
int *arpi[5];
```

> ■ 포인터 배열(Array of Pointer) : 그 원소가 포인터인 배열이다. 각각의 배열 요소인 포인터가 가리키는 대상은 원칙적으로 임의의 타입을 가질 수 있지만 주로 문자형을 가리키는 경우가 많다.
>
> ■ 배열 포인터(Pointer to Array) : 배열의 번지를 담는 포인터 변수이다. 포인터가 가리키는 대상은 배열형으로 구성되어 있으며 포인터가 가리키는 배열의 요소는 임의의 타입을 가진다.

```cpp
#include <stdio.h>

int main() {
    // 예제에서는 [5][9]인데 안되네?
    char arps[5][20] = {"고양이", "개", "오랑우탄", "돼지", "지렁이"};
    char(*ps)[20];

    ps = arps;
    int i;

    for (i = 0; i < 5; i++) {
        printf("%s\n", *ps++);
    }
}
```

> 배열 포인터는 자신이 가리킬 수 있는 배열의 타입과 크기를 정확하게 기억하고 있기 때문에 사용자의 부주의한 대입을 막을 수 있다.

```cpp
#include <stdio.h>

// 크기 7의 정수형 배열 이외에는 받지 않는다. 
int GetTotalForWeek(int (*pa)[7]) {
    int sum = 0;
    for (int i = 0; i < 7; i++)
        sum += pa[0][i];
    return sum;
}

void main(void) {
    int ari[][7] = {
        {1, 2, 3, 4, 5, 6, 7},
        {8, 9, 10, 11, 12, 13, 14},
        {15, 16, 17, 18, 19, 20, 21}};

    for (int i = 0; i < 3; i++)
        printf("%d주의 판매량 = %d\n", i + 1, GetTotalForWeek(&ari[i]));
}
```

> C는 함수의 인수로 배열을 전달하는 방법은 제공하지 않으며 오로지 포인터만 전달할 수 있다.

```cpp
// 상수값은 무시된다.
void foo(int arr[5]);

// 아래 두 개는 같다.
int GetTotalForWeek(int (*pa)[7]);
int GetTotalForWeek(int pa[][7]);
```

> 정수형 포인터 pi는 정수형 포인터 상수인 ar을 대입받을 수 있지만 &ar을 대입받을 수는 없다. 대입이 안된다는 얘기는 좌우변의 타입이 다르다는 뜻이다. ar은 정수형 배열의 시작 번지를 가리키는 포인터 상수이므로 정확한 타입은 int \* const이며 대상체는 int이다. 그러나 &ar의 타입은 이와는 다른데 대상체가 크기 5의 정수형 배열이며 타입은 int (\*)[5] const가 된다. 즉 &ar은 크기 5의 정수형 배열을 가리키는 배열 포인터 상수이다.

> &ar의 의미는 ar을 부분 배열로 가지는 가상의 전체 배열에 대한 이차 배열 포인터 상수라고 할 수 있다.

```cpp
#include <stdio.h>

int main(void) {
    int ar[5] = {1, 2, 3, 4, 5};
    int *p1;
    int(*p2)[5];

    p1 = ar;
    p2 = &ar;
    printf("before = %p\n", p1);
    printf("before = %p\n", p2);
    p1++;
    p2++;
    printf("after = %p\n", p1);
    printf("after = %p\n", p2);
}
```

> When arrays are passed to functions, they decay to pointers to their first element. [Is 2d array a double pointer? ](https://stackoverflow.com/questions/7586702/is-2d-array-a-double-pointer)

[Please Explain the ambiguity in pointers in C?](https://stackoverflow.com/questions/7351331/please-explain-the-ambiguity-in-pointers-in-c/7351390#7351390)

[Dereferencing a pointer to 2d array](https://stackoverflow.com/questions/65334464/dereferencing-a-pointer-to-2d-array)

> 행 계속 문자 \를 행의 끝에다 붙이면 다음 줄을 하나로 합쳐 주는데 주로 여러 줄의 매크로를 정의할 때 사용한다.

```cpp
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "가나다라";
    printf("%zu\n", strlen(str));

    return 0;
}
```

```cpp
#include <stdio.h>

int main() {
    // 정적 데이터 영역의 Korea가 배열로 복사된다.
    char str[] = "Korea";
    char *ptr = "Korea";

    puts(str);
    puts(ptr);

    ptr = "China";
    //  str="China";

    str[0] = 'C';
    // 정적 데이터 영역의 내용을 바꿀 수 없다.
    // ptr[0] = 'C';

    // 수정 가능, 직사각형 모양
    char countryArr[][32] = {"Korea", "America", "Iran"};
    // 수정 불가, ragged 모양
    char *countryPtr[] = {"Korea", "America", "Iran"};
}
```

strncpy 함수는 strcpy 함수와는 달리 지정한 개수만큼만 문자를 복사한다. 중간에 널이 등장하면 그 이후는 널로 채운다.

> ...strncpy 함수는 널 종료 문자를 붙이지 않는 반면 strncat 함수는 일부 문자열만 연결하더라도 항상 널 종료 문자를 뒤에 붙인다는 점이 다르다.

> (strcmp의) 리턴값이 0, 1, -1 과 같이 상수로 정의되어 있지 않고 부호로 정의되어 있는 이유는 비교 속도를 높이기 위해서이다. strcmp 함수는 두 문자열의 대응되는 문자들을 차례대로 비교해 나가다가 최초로 다른 문자가 발견되면 두 문자의 코드값을 그대로 뺄셈해서 리턴해 버린다. 그래서 비교 결과도 부호로 판별해야 한다.

stricmp는 대소문자를 무시하고 비교한다.

strchr는 문자열에서 문자를 찾는다. strrchr는 오른쪽부터 찾는다. r은 rear.

strstr는 부분 문자열을 찾는다.

strpbrk는 첫 번째 인수로 주어진 문자열에서 두 번째 인수로 주어진 문자열에 속해 있는 문자 중 가장 먼저 발견된 문자를 찾아 그 번지를 리턴한다.

> strtok 함수는 최초 호출될 때 문자열의 첫 번째 토큰을 찾고? 두 번째 토큰 위치를 NULL문자로 만든 후?? 토큰의 포인터를 리턴한다. 검색한 토큰을 널 종료 문자열로 만들어 주므로 strtok가 리턴하는 포인터를 바로 출력하거나 별도의 버퍼에 복사하면 분리된 토큰을 얻을 수 있다. 이때 strtok 함수는 중간 검색 결과를 자신의 정적변수에 저장해 놓는데 검색을 계속 하려면 첫 번째 인수를 NULL로 전달하면 된다.

```cpp
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "I am a boy,you are a girl";
    char *p;

    p = strtok(str, " ,");
    while (p != NULL) {
        puts(p);
        p = strtok(NULL, " ,");
    }
}
```

[strstr.c - Apple Open Source](https://opensource.apple.com/source/tcl/tcl-14/tcl/compat/strstr.c.auto.html). 구현은 단순함.

strset은 널 문자 직전까지 채우고, strlwr, strupr은 소문자 대문자로 통일시킨다. strrev는 순서를 뒤집는다. 한글은 안된다.

ctype.h는 개별 문자가 그룹에 속하는지 여부를 알려주는 함수들이 있다. isalpha,(a-z, A-Z) issupper(A-Z), islower(a-z), isdigit, isxdigit(16진수), isalnum(al+num), isprint(인쇄 가능 여부), isgraph(공백 제외 인쇄 가능 여부), ispunct(공백 제외 isalnum 제외), isspace.

[isalpha.c - Apple Open Source](https://opensource.apple.com/source/BerkeleyDB/BerkeleyDB-18/db/clib/isalpha.c.auto.html)

메모리 관리 함수는 char* 대신 void*를 사용하고 크기를 따로 넣어줘야하는 것을 제외하고는 문자열 관리 함수와 유사하다. memset, memcpy, memchr, memset, memmove등이 있다.

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
    char str[32] = "You are beautiful";
    char str2[] = "very ";

    memmove(str + 13, str + 8, 10);
    memcpy(str + 8, str2, strlen(str2));
    puts(str);
}
```

[memcpy() vs memmove()](https://stackoverflow.com/questions/4415910/memcpy-vs-memmove)

itoa, ltoa, ultoa들로 정수를 문자열로 바꿀 수 있다. itoa는 표준 함수가 아니라고 함. clang에 없네 ㅠ. atoi는 또 있네??

atio는 변환할 수 없으면 0을 리턴한다. 0을 입력받은거면 어쩌지?? [atoi — how to identify the difference between zero and error?](https://stackoverflow.com/questions/8871711/atoi-how-to-identify-the-difference-between-zero-and-error)

> strtol 함수는 atoi 함수에 비해 진법을 인식한다는 점에 있어서 조금 더 기능이 많다. atoi는 문자열에 들어 있는 값을 10진수로만 인식하지만 strtol 함수는 세 번째 인수 base로 문자열에 들어 있는 값의 진법을 지정할 수 있다.

실수에서 문자열로의 변환은 gcvt, ecvt, fcvt등으로 한다. 문자열에서 실수로의 변환은 atof, strtod로 한다. 강좌에서는 소개만 한다.

sprintf는 서식화된 출력을 화면이 아닌 buffer로 보낸다.

```cpp
char *my_strcpy(char *dest, const char *src) {
     char *d=dest;
     // strcpy를 이렇게 구현할 수도 있다.
     while (*dest++ = *src++) {;}
     return d;
}
```

```cpp
// 아래를 문자열 뒤에 문자 하나를 추가하는 함수의 일부라 할 때
// 동작하지 않는 이유는?
str[strlen(str)]=c;
str[strlen(str)+1]=0;
```

> 구조체(Structure)를 문장화하여 정의 내리면 "타입이 다른 변수들의 집합"이라고 할 수 있으며 더 간단하게 표현하면 이종 변수 집합이다.

> 구조체 선언은 어디까지나 구조체의 모양을 컴파일러에게 알리는 것뿐이므로 static, register같은 기억 부류를 지정한다든가 초기값을 줄 수는 없다.

구조체는 배열에 비해 함수의 인수로 전달하거나 리턴이 가능하다. 배열은 왜 안됐던거지?? 타입을 int[5]로 지정할 수 있게 하면 컴파일러에서 다 알 수 있지 않나. [C: Why can you pass (to a function) a struct by value, but not an array?](https://stackoverflow.com/questions/38543797/c-why-can-you-pass-to-a-function-a-struct-by-value-but-not-an-array)

구조체 태그는 타입에 대해 이름을 붙이는 것이다. struct 태그명 { 멤버 목록 };.

```cpp
struct {
     char Name[10];
     int Age;
     double Height;
} Friend;

struct tag_Friend {
     char Name[10];
     int Age;
     double Height;
};

struct tag_Friend Friend; // C, 구조체 태그임을 알려야했다.
tag_Friend Friend; // C++, 태그가 하나의 타입으로 인정된다.

typedef struct {
     char Name[10];
     int Age;
     double Height;
} FriendType;
```

> 컴파일러는 구조체가 선언될 때 각 멤버의 오프셋과 타입을 기억해 둔다. 그리고 멤버를 참조하는 문장을 만나면 구조체의 시작 번지에서 오프셋을 더한만큼 이동한 후 이 위치에서 멤버의 타입 길이만큼 값을 읽도록 코드를 생성할 것이다. 이런 동작을 하는 연산자가 바로 . 연산자이다.

> p가 구조체를 가리키는 포인터이고 m이 멤버일 때 (\*p).m 은 p->m과 같다.

구조체끼리의 대입 연산 동작은 구조체의 길이만큼 메모리 복사로 정의되어 있다. 구조체의 이름은 좌변값으로 인정된다.

함수의 지역변수인 구조체의 포인터를 반환값으로 사용하면 안된다.

얕은 복사는 종속적인 관계를 만들고 메모리를 이중으로 해제할 위험이 있다.

> 비트 구조체는 비트들을 멤버로 가지는 구조체이며 비트 필드(bit field)라고도 부른다

[What is the use of declaring different datatypes inside bitfields?](https://stackoverflow.com/questions/9213622/what-is-the-use-of-declaring-different-datatypes-inside-bitfields)

```cpp
#include <stdio.h>

struct tag_bit {
    unsigned short a : 4;
    unsigned short b : 3;
    unsigned short c : 1;
    unsigned short d : 8;
};

int main() {
    tag_bit bit;
    bit.a = 0xf;
    bit.b = 0;
    bit.c = 1;
    bit.d = 0xff;
    printf("크기=%zu, 값=%x\n", sizeof(bit), bit);
}
```

> Bitfields are not quite as portable as you think, as "C gives no guarantee of the ordering of fields within machine words". [Bitfield manipulation in C](https://stackoverflow.com/questions/1044654/bitfield-manipulation-in-c/1044689#1044689)

[Bit Fields in C](https://www.geeksforgeeks.org/bit-fields-c/)

요즘엔 메모리 많아서 비트 구조체 잘 안쓰는듯? 속도에도 불리하다.

Union에 속한 멤버들은 기억 장보를 공유한다. 아래와 같이 엔디언과 관련되어있다.

```cpp
#include <stdio.h>

int main() {
    union {
        int a;
        short b[2];
    } x;

    x.a = 0x12345678;
    printf("x.a=%x\n", x.a);
    printf("x.b[0]=%x\n", x.b[0]);
    printf("x.b[1]=%x\n", x.b[1]);

    x.b[0] = 0x9999;
    printf("x.a=%x\n", x.a);
}
```

이름없는 공용체를 선언하면 멤버 이름으로 바로 접근할 수 있다. 배타적인 멤버가 있을 때 활용할 수 있다.

```cpp
struct Part {
     PartType Type;
     char Maker[32];
     int Price;
     union {
          int Capacity;
          int Size;
          int KeyNum;
     };
};
```

## 2부. C 고급

const는 #define 대비 타입 지정이 가능하고 범위가 제한되며 디버깅이 용이하고 부작용이 적다.

```cpp
const int *p; // const int를 가리키는 포인터, 상수 지시 포인터(pointer to constant)
int * const p; // int를 가리키는 const 포인터, 상수 포인터(constant pointer)

// ㅋㅋㅋㅋ..
const int * const * const p;
// 가운데 const는 p가 가르키는 포인터가 상수임을 의미한다.
```

```cpp
#include <stdio.h>

int main() {
    const int i = 2;
    int *pi = (int *)&i;
    *pi = 3;
    // 상수 참조문을 컴파일러가 상수로 바꿔버리는 듯?
    printf("%d, %d\n", i, *pi); // 2, 3
}
```

> 상수 지시 포인터를 받은 함수가 일반 포인터를 취하는 함수를 호출해야 하는 경우는 없다. 만약 있다면 함수 설계를 잘못한 것이다.

> 어떤 변수를 다른 프로세스나 스레드가 바꿀 수도 있다는 것을 컴파일러는 알 수 없기 때문에 전역 환경을 참조하는 변수에 대해서는 개발자가 volatile 선언을 해야 한다?

[Why is volatile needed in C?](https://stackoverflow.com/questions/246127/why-is-volatile-needed-in-c)

[When to use volatile with multi threading?](https://stackoverflow.com/questions/4557979/when-to-use-volatile-with-multi-threading/58535118#58535118)

함수형 포인터 형식: 리턴타입 (\*변수명)(인수의 목록);

```cpp
// 둘다 된다. 두번째는 편의성을 위한 것.
(*pf)(2);
pf(2);
```

> 그러나 타입이 다른 함수 포인터끼리라도 강제로 대입할 수는 있는데 이것이 일단은 가능해야 한다. void 포인터에 저장된 함수의 번지를 대입받는다거나 자료 구조 설계시에 미리 알 수 없는 함수에 대한 포인터를 다루고자 할 때이다.

(int (\*)(char \*)) 이런 식으로 생김.

함수 포인터 배열을 선언할 때는 변수명 다음에 첨자 크기를 밝혀 주면 된다. int (\*arpf[5])(int);.

```cpp
// 함수 포인터를 인수로 받는 함수의 예
void qsort(
     void *base,
     size_t num,
     size_t width,
     int ( *compare )(const void *, const void *)
);
```

```cpp
// 함수 포인터를 반환하는 함수
int (*SelectFunc(char ch))(int,double) // 요상해,,

typedef int (*PF)(int,double);
PF SelectFunc(char ch); // 이게 낫다.
```

가변인수 함수에서 ...는 컴파일러가 이후의 인수에 대해서 개수와 타입을 점검하지 않게 한다.

다음은 필요한 변수와 매크로 함수들. va_list ap. 스택에서 인수를 어디까지 읽었는지 기억하는 포인터. va_start. ap가 첫 인수를 가리키도록 초기화. va_arg. 가변인수를 실제로 읽음. va_end. 뒷정리, 호환성용.

```cpp
#include <stdarg.h>
#include <stdio.h>

int GetSum(int num, ...) {
    int sum = 0;
    int i;
    va_list ap;
    int arg;

    va_start(ap, num);
    for (i = 0; i < num; i++) {
        arg = va_arg(ap, int);
        sum += arg;
    }
    va_end(ap);
    return sum;
}

int main() {
    printf("%d\n", GetSum(2, 1, 2));
    printf("%d\n", GetSum(4, 3, 4, 5, 6));
    printf("%d\n", GetSum(6, 10, 11, 12, 13, 14, 15));
}
```

```cpp
// 강좌에서는 에러 안난다는데 요즘 컴파일러는 좋아서인지 다 warning 뜬다 오
printf("%d%d\n",1,2);getch();
printf("%d%d%d\n",1,2,3,4,5);getch();
printf("%d%d\n",1,3.14);getch();
printf("%f%f\n",1,2);getch();
printf("%s\n",1);getch();
```

...을 제외하고 가변 인수에 대한 모든 지원은 stdarg.h의 매크로에 의한 것이다.

```cpp
// 정수형의 정수배로 바꾼다. 4의 배수로 올림.
#define _INTSIZEOF(n) ((sizeof(n) + sizeof(int) - 1) & ~(sizeof(int)-1))
// 여러 동작을 열심히 구겨넣었다.
#define va_arg(ap, t) (*(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))
```

가변 인수를 활용하는 함수로는 vprintf나 vsprintf가 있다.

```cpp
#include <stdio.h>

void add(int &a) {
    a += 1;
}

int main() {
    int i = 3;
    int &ri = i;
    printf("%d, %d\n", i, ri);
    ri = 4;
    printf("%d, %d\n", i, ri);

    add(i);
    printf("%d\n", i);
}
```

레퍼런스는 변수 자체이며 온전한 좌변값이다.

레퍼런스는 일단 선언되면 참조 대상을 변경할 수 없다. 레퍼런스의 대상체는 좌변값이어야한다.

포인터에 대한 레퍼런스는 char &\*가 아니라 char \*&이다. 전자는 레퍼런스에 대한 포인터인데 invalid하다.

> 비트 필드에 대한 레퍼런스도 선언할 수 없다. 비트 필드는 주소를 가지지 않기 때문에 포인터의 대상체가 될 수 없으며 마찬가지로 레퍼런스의 참조 대상이 될 수도 없다.

리턴값으로 레퍼런스를 쓰는건 자제하면 좋지만 연산자 오버로딩에서는 꼭 사용해야한다.

```cpp
const int &ri; // 가르키는 대상이 상수
int & const ri; // 레퍼런스가 상수인데 의미 없음.
```

[Why do stacks typically grow downwards?](https://stackoverflow.com/questions/2035568/why-do-stacks-typically-grow-downwards)

```cpp
#include <stdio.h>

int myaddfunc(int a, int b) {
    return a + b;
}

int main() {
    myaddfunc(1, 2);
}
```

```s
.section	__TEXT,__text,regular,pure_instructions
	.build_version macos, 13, 0	sdk_version 13, 1
	.globl	__Z9myaddfuncii                 ; -- Begin function _Z9myaddfuncii
	.p2align	2
__Z9myaddfuncii:                        ; @_Z9myaddfuncii
	.cfi_startproc
; %bb.0:
	sub	sp, sp, #16
	.cfi_def_cfa_offset 16
	str	w0, [sp, #12]
	str	w1, [sp, #8]
	ldr	w8, [sp, #12]
	ldr	w9, [sp, #8]
	add	w0, w8, w9
	add	sp, sp, #16
	ret
	.cfi_endproc
                                        ; -- End function
	.globl	_main                           ; -- Begin function main
	.p2align	2
_main:                                  ; @main
	.cfi_startproc
; %bb.0:
	stp	x29, x30, [sp, #-16]!           ; 16-byte Folded Spill
	mov	x29, sp
	.cfi_def_cfa w29, 16
	.cfi_offset w30, -8
	.cfi_offset w29, -16
	mov	w0, #1
	mov	w1, #2
	bl	__Z9myaddfuncii
	mov	w0, #0
	ldp	x29, x30, [sp], #16             ; 16-byte Folded Reload
	ret
	.cfi_endproc
                                        ; -- End function
.subsections_via_symbols
```

스택 프레임을 통해 지역변수의 선언 개수가 프로그램의 크기와 함수의 실행 속도가 연관 없으며 지역변수가 초기화되지 않음을 알 수 있다.

> ... 그러나 아주 특수한 경우 호출원과 함수의 호출 규약이 달라질 수도 있다. 어떤 때 이런 불일치가 발생할 수 있는가 하면 함수를 작성한 언어와 호출하는 언어가 다를때, 분리된 DLL에 있는 함수를 호출할 때, 원형이 이미 정해져 있는 콜백함수를 호출할 때 등이다.

호출 규약을 바꾸는 문법도 있는 것 같은데, 일단 clang에서는 안된다.

> 재귀 호출이 가능한 물적 토대는 함수 호출시마다 생성되는 스택 프레임이며 각 호출에 대해 독립적으로 저장되는 지역변수가 재귀 호출의 문법적 근거이다. 지역변수의 개념이 없는 베이직이나 포트란은 재귀 호출을 지원하지 않는다.

지역 변수가 많아질수록 가능한 재귀 호출의 개수가 줄어드는 듯.

```cpp
#include <stdio.h>

void foo() {
    static int a;
    int b, c, d, e, f, g, h, i, j, k, l;
    printf("%d\n", ++a);
    foo();
}

int main() {
    foo();
}
```

> 함수가 인라인이 될 것인가 아닌가는 프로그래머가 지정하지만 최종 결정은 컴파일러가 한다.

```cpp
// 인라인 함수가 매크로 함수보다 좋은 점이 많지만, 아래와 같은 경우는 매크로 함수에서만 가능하다.
#define ARSIZE(ar) (sizeof(ar)/sizeof(ar[0]))
// 함수로 배열 자체를 넘길 수 없다. sizeof(arr)를 할 수 없는 듯.
```

> 디폴트 인수는 **함수의 원형에만** 지정할 수 있으며 정의부에서는 중복 지정할 수 없다. 원형 선언없이 정의부만 있다면 정의부에 디폴트 인수를 지정할 수 있지만 원형과 정의부가 동시에 존재하는 일반적인 경우에는 원형 선언에만 디폴트 인수가 있어야 한다.

당연하지만 디폴트 인수는 오른쪽부터 순서대로.

```cpp
#include <stdio.h>

// 확장자 c면 'error: C does not support default arguments'
void f(int a = 3) {
    printf("%d\n", a);
}

int main() {
    // cpp면 error: default arguments can only be specified for parameters in a function declaration
    void (*pf)(int = 3);
    void (*pf2)(int = 4);
    pf = f;
    pf2 = pf;
    pf();
    pf2();
}
```

> 함수의 인터페이스를 유지하면서 이미 사용하고 있는 함수의 기능 중 일부를 확장하고자 할 때 디폴트 인수는 아주 좋은 방법을 제공한다.

오버로딩은 C++부터 지원한다.

모든 프로그래밍 언어는 목적 파일을 만들고 링크를 통해 이들을 연결해 실행 파일을 만든다. 이때 목적 파일에 속한 함수의 명칭과 주소를 공개하는 방법은 표준으로 규정되어있다. 이덕분에 다른 언어로 컴파일된 목적 파일들이 링크될 수 있다. 하지만 이 표준으로는 오버로딩된 함수를 구분하지 못해 name mangling으로 인수의 개수와 타입도 포함시킨다. extern "C"로 이를 비활성화시켜 C와의 호환성을 지킬 수 있다.

[Name mangling](https://en.wikipedia.org/wiki/Name_mangling)

```cpp
// 아래 두개는 컴파일러가 구분할 수 있다.
// 인수가 상수 성질을 가지는가 아닌가는 호출 시점에서 구분 가능하다.
int strlength(char *s);
int strlength(const char *s);

// 아래 두개는 같다.
int strlength(char * const s);
int strlength(char *s);
```

```cpp
#include <stdio.h>

int strlength(char *s) {
    puts("char *");
    return 0;
}

int strlength(const char *s) {
    puts("const char *");
    return 0;
}

/*
int strlength(char * const s)
{
     puts("const char *");
     return 0;
}
//*/

int main() {
    char str1[] = "1234";
    // warning: ISO C++11 does not allow conversion from string literal to 'char *const'
    const char *str2 = "가나다라";
    char *const str3 = "abcd";

    strlength(str1);
    strlength(str2);
    strlength(str3);
}
```

> 인수로 전달된 포인터의 상수성은 함수 본체에서 이 형식 인수를 바꿀 수 있는가 아닌가를 지정할 뿐이지 실인수의 상수성과는 아무런 상관이 없으므로 호출 시점에서 어떤 함수가 정확한지 판단할 수 없는 것이다.

C가 제공하는 파일 엑세스 함수를 배워보자. 운영체제 무관 사용할 수 있다.

고수준 파일 입출력 방식은 **버퍼**를 사용하며 스트림에 입출력한다. 저수준 파일 입출력 방식은 메모리로 직접 읽어들이며 파일 핸들에 입출력한다.

한 번 읽을 때 버퍼에 많이 저장해두면 하드 디스크 엑세스 횟수를 줄일 수 있다. 요즘엔 워낙 빨라서 저수준의 이점이 희박해졌다.

r은 읽기 전용이며 없으면 에러, w는 쓰기 전용이며 없으면 새로 만들고 있으면 지워짐, a는 추가며 없으면 만듦, r+는 읽고 쓰기 없으면 에러, w+는 읽고 쓰기 없으면 만듦, a+는 읽고 추가 없으면 새로 만듦.

텍스트 파일 모드로 열면...

> 1. 개행 코드를 의미하는 CR/LF 조합은 LF로 변환되어 읽혀지며 LF를 기록하면 CR/LF가 출력된다. 이런 변환을 해 주는 이유는 C 문자열 출력 함수들은 개행을 위해 확장열 LF(\n)를 사용하기 때문이다.
>
> 2. 파일의 끝을 나타내는 Ctrl+Z(0x1A)는 EOF(-1)로 변환되어 읽혀진다. 단 "a+" 모드로 열었을 때는 끝부분에 데이터를 추가할 수 있도록 Ctrl+Z를 제거한다.

오픈 모드 + 파일 형태로 mode 인수에 전달된다.

[Standard header files in C](https://www.tutorialspoint.com/standard-header-files-in-c)

```cpp
#include <stdio.h>

int main() {
    FILE *f;
    char str[] = "Aasdadads\nBB\nC\nD\nE\nF\n";
    f = fopen("test.txt", "wt");
    if (f) {
        //  str 문자열내에 개행 코드는 '\n'으로 기록되어 있지만 텍스트 모드로 파일을 생성했으므로 fputs가 실제로 파일로 출력하는 코드는 '\r\n'으로 변환된다.
        fputs(str, f);
        fclose(f);
    } else {
        printf("Error\n");
        return -1;
    }

    char buf[256];
    f = fopen("test.txt", "rt");
    if (f) {
        // 한줄씩 읽는다.
        while (fgets(buf, 5, f)) {
            // 줄바꿈이 있어야 두번재 인자에 대한 다른 출력을 볼 수 있음.
            printf("%s\n", buf);
        }
        fclose(f);
    }    
}
```

> fgets() 함수는 성공하면 string 버퍼를 가리키는 포인터를 리턴합니다. NULL 리턴값은 오류 또는 파일의 끝 조건을 표시합니다. **feof()** 또는 ferror() 함수를 사용하여 NULL 값이 오류를 표시하는지 파일의 끝을 표시하는지 여부를 판별하십시오. [fgets() — 스트링 읽기](https://www.ibm.com/docs/ko/i/7.3?topic=functions-fgets-read-string)

```cpp
#include <stdio.h>

// size_t fread(void *buffer, size_t size, size_t count, FILE *stream);
// size_t fwrite(const void *buffer, size_t size, size_t count, FILE *stream);
int main() {
    FILE *src, *dest;
    char buf[256];
    size_t nRead;

    // 왜 binary?
    src = fopen("test.txt", "rt");
    if (src != NULL) {
        dest = fopen("test2.txt", "wt");
        if (dest) {
            while (!feof(src)) {
                nRead = fread(buf, 1, 256, src);
                printf("%zu\n", nRead);
                fwrite(buf, 1, nRead, dest);
            }
            fclose(dest);
        }
        fclose(src);
    }
}
```

> The b flag opens the file in binary mode, which disables the special handling of certain characters in DOS and Windows, but has no effect on macOS and POSIX systems.. [About binary modes in fopen](https://stackoverflow.com/a/50739169)

> 이 두 함수(fprintf, fscanf)를 사용하면 화면으로 출력할 수 있는 모든 값들을 파일로도 출력할 수 있고 키보드로 입력받을 수 있는 모든 값을 파일에서 입력받을 수 있다. 화면이나 키보드도 파일과 같은 동질적인 스트림이므로 이것이 가능하다.

> 스트림은 다음 입출력할 파일의 위치를 항상 기억하고 있는데 이 위치를 FP(File Position)라고 한다.

> [Stream (computing) - Wikipedia](<https://en.wikipedia.org/wiki/Stream_(computing)>)

스트림의 FP를 옮기는 함수는 int fseek(FILE \*stream, long offset, int origin);이다. origin은 SEEK_SET, SEEK_CUR, SEEK_END 상수값이 있다.

> The header should only include what users of the software need; not what the implementers need. [Should I use #include in headers?](https://stackoverflow.com/questions/1804486/should-i-use-include-in-headers)

> ftell은 스트림의 현재 FP를 조사하는데 커서의 wherex, wherey 함수에 대응된다고 할 수 있다. rewind는 FP를 파일 선두로 보내는데 fseek(f,0,SEEK_SET)과 동일한 명령이다. 파일의 처음부터 다시 액세스하고 싶을 때 이 함수를 사용한다. fseek, ftell과 똑같은 동작을 하는 fgetpos, fsetpos라는 함수들도 있다.

> 고수준 입출력 함수들은 스트림을 대상으로 입출력을 수행한다. 스트림이란 파일뿐만 아니라 키보드나 모니터처럼 바이트를 연속적으로 입출력하는 물리적인 장치까지를 포괄하는 개념이므로 고수준 입출력 함수로 이런 장치들을 다룰 수 있다.

stdin은 표준 입력, stdout은 표준 출력, stderr은 표준 에러. 이중 표준 입력만 버퍼를 사용. 항상 열려있으니 사용하고 닫을 필요도 없다.

```cpp
#include <stdio.h>
#include <string.h>

int main() {
    char buf[256];

    while (true) {
        printf("문자열을 입력하시오(끝낼 때 0) : ");
        // aaa bbb ccc 입력하면 이상해짐.
        // scanf는 공백까지만 읽고 나머지는 버퍼에 남겨두고 다음에 읽는다.
        scanf("%s", buf);
        if (strcmp(buf, "0") == 0) {
            break;
        }
        // 버퍼에 남아있는 데이터를 비운다.
        // fflush(stdin);
        printf("입력한 문자열은 \"%s\"입니다.\n", buf);

        int i;
        char ch;

        // 엔터가 버퍼에 남아있다. 
        scanf("%d", &i);
        scanf("%c", &ch);

        printf("i=%d, ch=%c\n", i, ch);
    }
}
```

> ...gets는 문자열 입력을 완료하면서 버퍼의 Enter를 지우는 특성이 있다

stdin의 정체가 뭐길래?

[The Lost Art of Structure Packing](http://www.catb.org/esr/structure-packing)

```cpp
#include <stdio.h>

int main() {
    struct {
        char *p;
        short s;
        int x;
    } foo = {
        NULL,
        0x1234,
        0x12345678};

    char *ptr = (char *)&foo;

    for (int i = 0; i < 16; i++) {
        printf("%x\n", *ptr++);
    }
}
```

저수준 파일 입출력 방법은 패스,,, clang에 있는지도 모르겠음.

```cpp
#include <stdio.h>
#include <unistd.h>

int main() {
    if (access("test.txt", F_OK) == 0) {
        rename("test.txt", "testtest.txt");
    } else {
        rename("testtest.txt", "test.txt");
    }
    // int remove(const char *path)
}
```

[POSIX is an ISO standard; it defines access(). C is another ISO standard; it does not.](https://stackoverflow.com/a/230068)

책은 윈도우 기준인 것 같아서 POSIX로 나중에 공부해보면 될 듯.

> 보수(Complement)란 어떤 수(기수라고 한다)가 되기 위해 보충되어야 하는 수를 의미하는데 가령 기수 10에 대한 3의 보수는 7이다. 일반적으로 a+b=기수일 때 a와 b는 기수에 대해 보수 관계에 있다고 표현한다. 2의 보수란 n비트에 대해 2n을 기수로 한 보수이다. n이 8일 때 기수는 28=256이 되며 결국 8비트에서 2의 보수는 256이 되기 위해 더 필요한 수로 정의할 수 있다. a의 2의 보수 b가 있을 때 a+b=256이며 8비트에서 256은 0과 같다. 그러므로 a+b=0이 되고 a=-b, b=-a의 관계가 성립한다.

리틀 엔디안은 타입의 축소나 확장이 있을 때 효율적이다. 각 바이트를 배열처럼 다루려면 빅 엔디안이 낫다. 소켓은 빅 엔디안으로 통일되어있다.

부동 소수점 방식에서 가수는 실수의 실제값을 표현하며 지수는 크기를 표현하여 가수의 어디쯤에 소수점이 있는지를 나타낸다. 12.345\*100, 1.2345\*101 처럼 같은 수를 여러 방법으로 나타낼 수 있기에 정규화를 한다. 가수의 정수부를 한자리로 제한한다.

지수는 왜 바이어스를 적용? 대소 비교의 편의를 위해서인가.

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* itoa(int value, char* result, int base) {
    // check that the base if valid
    if (base < 2 || base > 36) {
        *result = '\0';
        return result;
    }

    char *ptr = result, *ptr1 = result, tmp_char;
    int tmp_value;

    do {
        tmp_value = value;
        value /= base;
        *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz"[35 + (tmp_value - value * base)];
    } while (value);

    // Apply negative sign
    if (tmp_value < 0) *ptr++ = '-';
    *ptr-- = '\0';
    while (ptr1 < ptr) {
        tmp_char = *ptr;
        *ptr-- = *ptr1;
        *ptr1++ = tmp_char;
    }
    return result;
}

void printfloat(float f) {
    unsigned t;
    char temp[35], bin[35];

    // 비트를 다루기 쉽도록 정수형 변수에 대입한다.
    t = *(unsigned*)&f;

    // 선행 제로를 포함한 32자리의 2진수 문자열로 변환
    itoa(t, bin, 2);
    memset(temp, '0', 35);
    strcpy(temp + 32 - strlen(bin), bin);

    // 부호, 지수 다음에 공백을 하나씩 넣음
    bin[0] = temp[0];
    bin[1] = ' ';
    strncpy(bin + 2, temp + 1, 8);
    bin[10] = ' ';
    strcpy(bin + 11, temp + 9);

    printf("실수=%f(%s), ", f, bin);

    // 지수 출력
    printf("지수부 = %d\n", (t >> 23 & 0xff) - 127);
}

int main() {
    printfloat(0.375f);
    printfloat(3.14f);
    printfloat(-0.5f);
    printfloat(0.1f);
}
```

[itoa with GCC](http://www.strudel.org.uk/itoa/#performance)

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* itoa(int value, char* result, int base) {
    // check that the base if valid
    if (base < 2 || base > 36) {
        *result = '\0';
        return result;
    }

    char *ptr = result, *ptr1 = result, tmp_char;
    int tmp_value;

    do {
        tmp_value = value;
        value /= base;
        *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz"[35 + (tmp_value - value * base)];
    } while (value);

    // Apply negative sign
    if (tmp_value < 0) *ptr++ = '-';
    *ptr-- = '\0';
    while (ptr1 < ptr) {
        tmp_char = *ptr;
        *ptr-- = *ptr1;
        *ptr1++ = tmp_char;
    }
    return result;
}

void printfloat(float f) {
    unsigned t;
    char temp[35], bin[35];

    // 비트를 다루기 쉽도록 정수형 변수에 대입한다.
    t = *(unsigned*)&f;

    // 선행 제로를 포함한 32자리의 2진수 문자열로 변환
    itoa(t, bin, 2);
    memset(temp, '0', 35);
    strcpy(temp + 32 - strlen(bin), bin);

    // 부호, 지수 다음에 공백을 하나씩 넣음
    bin[0] = temp[0];
    bin[1] = ' ';
    strncpy(bin + 2, temp + 1, 8);
    bin[10] = ' ';
    strcpy(bin + 11, temp + 9);

    printf("실수=%f(%s), ", f, bin);

    // 지수 출력
    printf("지수부 = %d\n", (t >> 23 & 0xff) - 127);
}

int main() {
    printfloat(0.375f);
    printfloat(3.14f);
    printfloat(-0.5f);
    printfloat(0.1f);
}
```

float은 소수점 7자리, double 소수점 15자리까지 유효하다.

> 실수끼리 더할 때는 지수부를 일치시킨 후 가수부를 더하는데 두 값의 지수차가 심할수록 덧셈 결과의 가수부가 길어져 정밀도를 초과할 확률이 높다.

> 파일러는 CPU가 메모리를 최대한 빠른 속도로 액세스할 수 있도록 구조체의 베이스와 멤버의 오프셋을 조정해서 배치하는데 이를 구조체의 정렬(alignment)이라고 한다.

```cpp
#define offsetof(s,m)   (size_t)&(((s *)0)->m)

offsetof(Node,prev);
```

> 조건부 컴파일 지시자(Conditional Compile Directive)는 지정한 조건의 진위 여부에 따라 코드의 일정 부분을 컴파일할 것인지 아닌지를 지정한다. ... 조건부 컴파일 지시자를 잘 활용하면 한벌의 코드를 조건에 따라 다르게 컴파일하여 상이한 실행 파일을 만들어낼 수 있다.

#ifdef는 매크로의 존재 여부만으로, #if는 매크로의 값을 평가하거나 여러가지 조건을 결합하여.

> defined 연산자로 매크로의 존재 여부를 평가할 수 있다. #if defined(MACRO) 전처리문은 #ifdef MACRO와 완전히 동일한 문장이다. 그러나 다른 조건과 함께 매크로의 존재 여부를 평가할 때는 #ifdef를 쓸 수 없으므로 defined 연산자가 따로 제공된다.

```cpp
// undef 용례
#define TIME 800
#include <ext1.h>
#undef TIME
#define TIME 1400
#include <ext2.h>
```

> 미리 정의된 매크로(Predefined Macro)는 컴파일러가 제공하는 매크로이다.

```cpp
#include <stdio.h>

int main() {
    printf("오늘은 %s이고  최후 컴파일된 시간은 %s입니다.\n", __DATE__, __TIME__);
    printf("이 파일이 최종 수정된 시간은 %s입니다.\n", __TIMESTAMP__);
    printf("이 파일은 %s이고 이 줄은 %d입니다.\n", __FILE__, __LINE__);
#ifdef __STDC__
    printf("이 컴파일러는 ANSI C표준을 따릅니다.\n");
#else
    printf("이 컴파일러는 ANSI C표준의 확장(C++)입니다.\n");
#endif
}
```

C++로 컴파일할 때는 **STDC** 매크로가 없다??

```cpp
#ifndef UNICODE
#error This program require unicode environment
#endif
```

> 그래서 각 플랫폼에서 실행되는 컴파일러는 플랫폼의 고유한 기능을 수행하기 위한 지원을 해야 한다. ... #pragma 지시자는 플랫폼별로 다른 이런 기능에 대한 지시 사항을 컴파일러에게 전달하는 방법이다.

#pragma는 전처리 명령처럼 보이지만 컴파일러 지시자이다.

```cpp
// #pragma once와 같다. 헤더 파일에 중복되면 안되는 정의가 있으면 이런 식으로 처리를 해야한다.
#ifndef _SOME_HEADER_FILE
#define _SOME_HEADER_FILE
// 헤더 파일 내용
#endif // _SOME_HEADER_FILE
```

> pack 지시자는 이후부터 선언되는 구조체의 정렬 방식을 지정한다.

pack(push, n), pack(pop, n)도 있다.

컴파일러가 경고를 출력하는 방법을 바꾸고 싶다면 다음 명령을 사용한다. #pragma warning(경고제어문:경고번호).

## 3부. C++ 문법

소프트웨어가 하드웨어의 발전을 따라가지 못하는 현상을 소프트웨어 위기(Software Crisis)라고 하며 주요 이유는 절차식 프로그래밍 방법의 낮은 생산성이다. 절차가 아닌 데이터를 중심으로 개발을 진행하는 객체 지향적 프로그래밍이 대안으로 제시되었다.

객체지향 3요소 캡슐화, 상속, 다형성. 객체지향 5원칙 SOLID.

C와 달리 범위 연산자(지역변수에 가려진 전역변수 참조), 명시적 캐스팅(int(var)), 인라인 함수, 디폴트 인수, 함수 오버로딩, 태그가 타입으로 승격, 이름없는 공용체, 한 줄 주석, 레퍼런스, bool 타입등이 추가되었다.

delete는 NULL 포인터에는 아무 동작도 하지 않으니 무지성 delete해도 좋다.

> 동적으로 할당한 배열을 삭제할 때는 delete 대신 반드시 delete [ ] 문을 사용해야 한다. 그렇지 않았을 때 그러니까 할당은 new [ ]로 해 놓고 해제는 delete로 했을 때의 동작은 정의되어 있지 않으며(Undefined) 상황에 따라 다르다.

```cpp
#include <iostream>
using namespace std;

struct Position {
    int x, y;
    char ch;
    void print() {
        cout << x << " " << y << " " << ch << endl;
    }
    void print2();
};  // 세미콜론 잊지 말기,,,

int main() {
    Position here;
    here.x = 30;
    here.y = 30;
    here.ch = 'A';
    here.print();
    here.print2();
}

// ::는 범위 연산자 
void Position::print2() {
    cout << "print2" << endl;
}
```

C++는 구조체 선언문에 함수의 원형만 선언하고 본체는 구조체 바깥에 따로 작성하는 방법을 지원한다. 내부 정의는 인라인 속성을 가져 멤버 함수를 호출하는 코드가 본체 코드로 대체되고, 외부 정의는 스택을 경유하여 제어의 분기가 발생한다. 진짜?? [C++ struct member functions definitions have differences if they are defined outside the struct body ?](https://stackoverflow.com/a/18753022)

엑세스 지정으로는 private, public, protected가 있다.

C++에서 구조체와 클래스의 유일한 차이는 멤버에 대한 티폴트 엑세스 지정뿐이다. 전자는 public, 후자는 private.

> 클래스 선언은 어떤 타입의 어떤 멤버들이 포함되어 있는지를 컴파일러에게 알리는 역할만 할 뿐이며 클래스형의 변수를 선언해야 실제 메모리가 할당된다.

> The C++ ISO standard says:
>
> A function defined within a class definition is an inline function.
>
> But, this doesn't mean the function will necessarily be inlined: generally nowadays, it appears that the compiler will decide if inlining the function will lead to any benefits. [Is "inline" implicit in C++ member functions defined in class definition](https://stackoverflow.com/a/9192159)

> 독립된 정보 저장을 위해 멤버 변수는 각 인스턴스들이 따로 가지지만 멤버 함수는 클래스에 속한 모든 인스턴스들이 공유한다. 인스턴스의 상태는 달라질 수 있지만 동작은 모두 동일하기 때문에 함수를 인스턴스별로 따로 가질 필요는 없다.

> 객체들을 먼저 만들고 객체들을 조립하여 프로그램을 완성하므로 상향식 개발이라고 한다.

> ...이렇게 헤더 파일과 구현 파일에 클래스의 선언과 정의를 나누어 놓으면 클래스를 사용하는 모듈에서 헤더 파일만 인클루드하면 되므로 재사용하기 편리하다.

> 생성자의 이름은 항상 클래스의 이름과 동일하며 필요할 경우 초기화에 사용할 인수를 받아 들일 수는 있지만 리턴값은 가질 수 없다.

```cpp
#include <stdio.h>
#include <stdlib.h>

class Foo {
   public:
    double x;
    // 초기화 안해도 잔소리 안함.
    Foo() {
        printf("Foo init\n");
    }
};

int main() {
    // warning: empty parentheses interpreted as a function declaration
    // Foo foo();
    Foo foo = Foo();
    printf("%f\n", foo.x);
}
```

```cpp
// 이름을 겹치게하고 범위연산자를 활용할 수 있다.
// this도 있다네? 뒤에서 살펴볼 예정.
Position(int x, int y, char ch) {
     Position::x=x;
     Position::y=y;
     Position::ch=ch;
}
```

```cpp
class Person {
private:
     char *Name;
     int Age;

public:
     Person(const char *aName, int aAge) {
          Name=new char[strlen(aName)+1];
          strcpy(Name,aName);
          Age=aAge;
     }
     ~Person() {
          delete [] Name;
     }
};
```

생성자와 파괴자는 컴파일러에 의해 자동으로 호출된다.

> 파괴자는 생성자가 할당해 놓은 메모리를 해제하며 delete 연산자는 객체 그 자체를 메모리에서 해제한다.

정적이든 동적이든 생성자와 파괴자가 모두 호출된다.

```cpp
#include <stdio.h>

class Foo {
   public:
    int value;
    Foo() {
        printf("Constructor\n");
    }
};

Foo foo3;

int main() {
    Foo foo;
    Foo *foo2 = new Foo;
    delete foo2;

    Foo foo4;
    printf("%d\n", foo3.value);
    printf("%d\n", foo4.value);  // 왜 0?
}
```

클래스에 생성자가 하나도 없으면 컴파일러가 만들어주는데 전역이나 정적 객체면 모든 멤버가 0이 되고 지역 객체면 쓰레기 값이 있다. 하나라도 생성자가 정의되어있으면 디폴트 생성자를 만들지 않는다.

디폴트 생성자가 없으면 객체 배열을 선언할 수 없다.

```cpp
// 이렇게는 됨
Position There[3]={
     Position(1,2,'x'),
     Position(3,4,'y'),
     Position(5,6,'z')
};
```

컴파일러는 디폴트 복사 생성자도 만드는데 얕은 복사를 한다.

> C++은 일반적인 타입도 클래스와 동등하게 취급하며 클래스에 적용되는 문법이 일반 타입에 대해서도 적용된다.

```cpp
#include <iostream>
using namespace std;

class Bar {
    int val;

   public:
    Bar(int val) {
        this->val = val;
        cout << "BAR INIT: " << val << endl;
    }
    ~Bar() {
        cout << "BAR DEINIT: " << val << endl;
    }
    Bar(const Bar& other) {
        val = other.val;
        cout << "BAR COPY: " << val << endl;
    }
};

class Foo {
    int x, y, z;
    // 강좌에서는 여기서 초기화할 수 없다던데 되네?
    // warning: default member initializer for non-static data member is a C++11 extension
    const int c = 123;
    Bar bar;

   public:
    // constructor for 'Foo' must explicitly initialize the const member 'c'
    Foo(int ax, int ay, int az) : x(ax), y(ay), z(az), bar(10) {
        // c = 123;는 안됨

        // elision of copy operation?
        // https://stackoverflow.com/questions/3663506/why-is-the-copy-constructor-not-called
        // -fno-elide-constructors 주면 copy 뜬다. 
        Bar bar2 = Bar(30);
        bar = bar2;

        cout << "FOO INIT" << endl;
    }
    void print() {
        cout << "FOO PRINT: " << x << y << z << endl;
    }
};

int main() {
    Foo foo(1, 2, 3);
    foo.print();
}
```

상수, 레퍼런스 멤버, 포함된 객체, 상속받은 멤버는 초기화 리스트에서 초기화할 수도 있다.

> 변환 생성자는 기본 타입으로부터 객체를 만드는 생성자이며 인수를 하나만 취한다.

```cpp
#include <stdio.h>

class Time {
    int h, m, s;

   public:
    Time(int ss) {
        h = ss / 3600;
        m = (ss / 60) % 60;
        s = ss % 60;
    }
    void print() {
        printf("%02d시간 %02d분 %02d초\n", h, m, s);
    }
    operator int() {
        return h * 3600 + m * 60 + s;
    }
};

int main() {
    Time t = 3668;
    t.print();
    int i = t;
    printf("%d\n", i);
}
```

함수 인수에서도 변환 생성자가 적용되어 버그를 일으킬 수 있다. 변환 생성자 앞에 explicit 키워드를 붙이면 암시적인 형 변환에 사용되지 않는다.

변환 함수는 변환 생성자와 달리 explicit같은게 없다.

```cpp
#include <stdio.h>

// 원리가 뭐임??
// It's a forward declaration.
// It's just there to inform the compiler that a class template named Robot will be defined later and that it should expect that definition. class Fahrenheit;
// https://stackoverflow.com/questions/10148605/empty-class-declaration-in-header-file

class Fahrenheit;

class Celsius {
   public:
    double Tem;
    Celsius(double aTem) : Tem(aTem) {}
    operator Fahrenheit();
    void OutTem() { printf("섭씨=%f\n", Tem); }
};

class Fahrenheit {
   public:
    double Tem;
    Fahrenheit(double aTem) : Tem(aTem) {}
    operator Celsius();
    void OutTem() { printf("화씨=%f\n", Tem); }
};

Celsius::operator Fahrenheit() {
    return Fahrenheit(Tem * 1.8 + 32);
}

Fahrenheit::operator Celsius() {
    return Celsius((Tem - 32) / 1.8);
}

int main() {
    Celsius C(100);
    Fahrenheit F = C;
    C.OutTem();
    F.OutTem();

    printf("\n");
    Fahrenheit F2 = 120;
    Celsius C2 = F2;
    F2.OutTem();
    C2.OutTem();
}
```

[When can I use a forward declaration?](https://stackoverflow.com/questions/553682/when-can-i-use-a-forward-declaration)

[Forward declaration (Wikipedia)](https://en.wikipedia.org/wiki/Forward_declaration)

> 변환 생성자와 변환 함수는 상호 대체성이 있다고 할 수 있다. 어쨌든 양방향으로 두 개의 함수가 있으면 된다.

> 공개 영역은 이미 사용자들이 알고 있는 영역이며 많은 사람들이 사용하고 있기 때문에 함부로 수정할 수 없다. 만약 불가피하게 수정하게 되면 기존 사용자들이 이 객체에 대해 습득한 지식은 무효가 되며 추상화의 조건을 어기게 되는 것이다.

문자열의 경우 읽기 전용 포인터(const char\*)를 반환하여 캡슐화를 할 수 있다.

```cpp
#include <iostream>
using namespace std;

class Foo {
    friend void f(Foo &foo);
    int val;
};

Foo foo;

void f(Foo &foo) {
    cout << foo.val << endl;
}

int main() {
    f(foo);
    Foo foo2;
    f(foo2);  // 왜 1?
}
```

클래스를 통째로 friend 지정할 수도 있다.

[When should you use 'friend' in C++?](https://stackoverflow.com/a/17443)

> 프렌드 클래스 지정은 특정 클래스의 모든 멤버 함수들이 자신의 숨겨진 멤버를 마음대로 읽도록 허락하는 것이다.

> 프렌드 멤버 함수는 특정 클래스의 특정 멤버 함수만 프렌드로 지정하는 것이며 꼭 필요한 함수에 대해서만 숨겨진 멤버를 액세스하도록 범위를 좁게 설정할 수 있는 장점이 있다.

> It is important to notice that a class cannot give itself access to another class's private part; that would break encapsulation. Rather, a class gives access to its own private parts to another class --- by declaring that class as a friend. [Friend_class, 위키피디아](https://en.wikipedia.org/wiki/Friend_class)

```cpp
#include <stdio.h>

class Foo {
    int value;

   public:
    Foo(int value) {
        this->value = value;
    }
};

int main() {
    Foo foo(10);
    printf("%zu\n", sizeof(foo));  // 4
}
```

멤버 함수는 메모리에 하나만 존재해도 된다. 그나저나 자신을 호출한 함수를 어떻게 아는걸까? 멤버 함수를 호출할 때 C++의 컴파일러가 호출문의 객체를 함수의 인수로 몰래 전달한다. 이때 전달된 인수를 this라 하며 포인터 상수이다.

> 이처럼 멤버 함수 호출시에 this를 암시적으로 전달하는 호출 규약을 thiscall이라고 하는데 모든 멤버 함수에 자동으로 적용된다. 단, 가변 인수를 취하는 멤버 함수는 cdecl 호출 규약을 사용한다.

delete this도 가능하다. [Is "delete this" allowed in C++?](https://stackoverflow.com/questions/3150942/is-delete-this-allowed-in-c)

```cpp
// static 멤버 변수 초기화
class Count {
     static int Num;
}
int Count::Num = 0;
```

> 관습에 따라 클래스를 헤더 파일에 선언하고 멤버 함수를 구현 파일에 작성할 때 정적 멤버에 대한 외부 정의는 통상 클래스 구현 파일(\*.cpp)에 작성한다.

헤더 파일에서 정의하면 이중 정의의 가능성이 있다. 객체 크기에 정적 멤버의 크기는 포함되지 않는다. 외부에서 정적 멤버 변수를 정의할 때는 예외적으로 엑세스 속성에 상관없이 초기값을 줄 수 있다.

> 단, 어디까지나 논리적으로 소속되는 것 뿐이지 클래스는 실체가 아니므로 클래스 안에 정적 멤버가 배치되는 것은 아니다.

> 상수 멤버 함수는 멤버값을 변경할 수 없는 함수이다. ... 상수로 선언된 객체에 대해서는 상수 멤버 함수만 호출할 수 있으며 비상수 멤버 함수는 호출할 수 없다.

비상수 멤버함수는 T \* const의 this를 받고, 상수 멤버함수는 const T \* const의 this를 받는다. 멤버 함수의 const 유무에 따라 오버로딩할 수 있다. 상수 객체면 상수 멤버 함수를, 비상수 객체면 비상수 멤버 함수를 호출한다.

volatile도 함수 원형의 일부이다??

```cpp
#include <iostream>

struct A {
    void foo() {
        std::cout << "in non-volatile" << std::endl;
    }
    void foo() volatile {
        std::cout << "in volatile" << std::endl;
    }
};

int main() {
    A a;
    a.foo();
    volatile A b;
    b.foo();
}
```

> mutable로 지정된 멤버는 상수 함수나 상수 객체에 대해서도 값을 변경할 수 있다.

[Does the 'mutable' keyword have any purpose other than allowing the variable to be modified by a const function?](https://stackoverflow.com/questions/105014/does-the-mutable-keyword-have-any-purpose-other-than-allowing-the-variable-to)

```cpp
class Complex {
private:
     double real;
     double image;

public:
     Complex(double r, double i) : real(r), image(i) { }
     // const 세 개 다 중요하다.
     // 레퍼런스를 반환하면 지역 변수라서 사라지기에 안된다.
     // i+j=5는 안되니 반환값도 const다?
     const Complex operator +(const Complex &T) const {
          Complex R;
          R.image = image + T.image;
          R.real = real + T.real;
          return R;
    }
};
```

A + B는 A.operator+(B)와 같다.

> 연산자 함수로 피연산자를 넘기는 방법은 사실 세 가지 모두 가능하다. 값으로 넘기는 방법은 객체가 커지면 효율이 좋지 못하다는 문제가 있고 포인터로 넘기는 방법은 효율은 좋지만 호출 구문이 요상해진다. 레퍼런스로 넘기면 효율과 직관적인 표기라는 두 마리 토끼를 다 잡을 수 있다. C++이 레퍼런스 타입을 지원하는 주된 이유 중의 하나가 바로 객체 연산식의 직관적인 표현을 위해서이다.

> In the context of the C++ programming language, return value optimization (RVO) is a compiler optimization that involves eliminating the temporary object created to hold a function's return value.
>
> [Copy elision (Wikipedia)](https://en.wikipedia.org/wiki/Copy_elision)

전역 함수로 연산자 오버로딩을 할 수도 있다. class 내부에서 해당 함수를 friend처리하고, 전역 함수에서는 같은 타입의 두 인자를 받는다.

=, ( ), [ ], -> 연산자들은 반드시 멤버 연산자 함수로만 만들어야 한다.

5+A와 같은 연산자 오버로딩을 정의할 때 friend 선언이 유용하다. 프렌드의 가장 실용적인 활용예가 바로 전역 연산자 함수이다.

```cpp
// 이건 int 내부에 선언이 없어 불가능하고
const Time int::operator+(Time);
// 이건 그냥 정의하면 Time의 private 프로퍼티에 접근할 수 없다.
const Time operator+(int, Time);
```

> 컴파일러는 표준위원들이 정한 규칙대로 ++A 형태의 식을 컴파일할 때는 operator ++() 멤버 함수를 호출하고 A++ 형태의 식을 컴파일할 때는 operator ++(int) 멤버 함수를 찾는다.

전위형은 T &를 리턴하고 후위형은 const T을 리턴한다.

[Is there a performance difference between i++ and ++i in C++?](https://stackoverflow.com/questions/24901/is-there-a-performance-difference-between-i-and-i-in-c)

T A=B;는 복사 생성자를 호출하고, Person A,B; A=B;는 대입 연산자를 호출한다. 대입은 이미 생성된 객체에 적용되며 한 객체에 여러번 대입될 수 있다는 점에서 초기화와 다르다.

```cpp
// 연쇄 대입을 지원하기 위해 반환값이 Person &이다.
Person &operator =(const Person &Other) {
     if (this != &Other) {
          delete [] Name;
          Name=new char[strlen(Other.Name)+1];
          strcpy(Name,Other.Name);
          Age=Other.Age;
     }
     return *this;
}

// 연쇄 대입 예시
// i=3, j=2
int i=1,j=2;
(i=j)=3;
printf("%d,%d\n",i,j);
```

동적 할당이 있는 클래스라면 생성자, 파괴자, 복사 생성자, 대입 연산자를 신경써야한다.

```cpp
// +=를 정의해놓고 +에서 이를 활용하면 편하다.
Time operator +(int s) {
     Time R=*this;
     R+=s;
     return R;
}
```

원하지 않는 생성자는 private 영역에 선언하면 된다. 없으면 컴파일러가 디폴트를 만들어서 안된다.

> 두 함수를 private 영역에 둘 때 본체 내용은 아예 작성하지 않는 것이 좋다. 왜냐하면 외부에서 이 함수를 호출하는 것은 컴파일러가 컴파일 중에 막아 주지만 클래스 내부의 멤버 함수나 프렌드 함수에서는 여전히 이 함수를 호출할 수 있기 때문이다. 함수를 선언만 해 놓고 본체를 정의하지 않더라도 이 함수가 호출되기 전에는 링커가 본체를 찾지 않으므로 아무 이상이 없다.

```cpp
#include <iostream>
using namespace std;

class Point {
    int x, y;
    friend ostream& operator<<(ostream& cout, const Point& p);

   public:
    Point(int x, int y) {
        this->x = x;
        this->y = y;
    }
};

ostream& operator<<(ostream& cout, const Point& p) {
    cout << p.x << " " << p.y << endl;
    return cout;
}

int main() {
    Point p(1, 2);
    cout << p << p;
}
```

[What are the basic rules and idioms for operator overloading?](https://stackoverflow.com/questions/4421706/what-are-the-basic-rules-and-idioms-for-operator-overloading/4421715#4421715) 미친건가 분량 겁나 많네,,,

```cpp
#include <iostream>
using namespace std;

class Foo {
    int arr[10] = {0};

   public:
    // 첨자로부터 읽고 쓰기 모두 가능하다
    // 리턴값에 const가 붙으면 읽기가 막히고, 함수가 const가 되면 레퍼런스를 반환할 수 없다.
    // 반환받은걸로 값을 바꿀 수 있기 때문인듯.
    int& operator[](int idx) {
        return arr[idx];
    }

    // 객체가 const면 const 함수만 부를 수 있어서 필요.
    const int& operator[](int idx) const {
        return arr[idx];
    }
};

int main() {
    Foo foo;
    cout << foo[0] << endl;
    foo[0] = 10;
    cout << foo[0] << endl;

    const Foo foo2;
    cout << foo2[0] << endl;
    // 상수 객체니까 안되는게 맞음. 
    // foo2[0] = 10;
    // cout << foo2[0] << endl;
}

// 이처럼 [] 연산자는 항상 상수 버전, 비상수 버전이 필요하다.
```

-> 연산자는 전역 함수로는 정의할 수 없고 클래스의 멤버 함수로만 정의할 수 있다. 리턴 타입은 반드시 클래스나 구조체의 포인터이다. 스마트 포인터를 흉내내기 위해 사용된다. 래핑된 객체를 감싸 유효성 점검이나 사용 카운트 관리 등을 한다.

```cpp
#include <iostream>
#include <string>

using namespace std;

struct Author {
    char Name[32];
    int Age;
};

class Book {
   private:
    Author Writer;

   public:
    Book(const char *name, int age) {
        strcpy(this->Writer.Name, name);
        Writer.Age = age;
    }
    Author *operator->() { return &Writer; }
};

int main() {
    Book book("김상형", 25);
    cout << book->Age << endl;
    cout << book->Name << endl;
}
```

> () 연산자를 정의하는 클래스를 함수 객체(Functor)라고 하는데 C++ 표준 라이브러리에서 일반화된 알고리즘의 동작에 변화를 주기 위해 흔히 사용된다.

```cpp
class Sum {
public:
     int operator()(int a,int b,int c,int d) {
          return a+b+c+d;
     }
     double operator()(double a,double b) {
          return a+b;
     }
};

int main() {
     Sum S;
     printf("1+2+3+4=%d\n",S(1,2,3,4));
     printf("1.2+3.4=%f\n",S(1.2,3.4));
}
```

new, delete 오버로딩. 할당, 해제가 아주 빈번하다면 충분한 크기의 메모리 큐를 만들고 응용 프로그램이 메모리를 회전시키는 방법도 쓸 수 있다. 사실 현실적인 실용성은 크게 없다. 대용량의 메모리를 다루는 프로그램 정도,,

> 이미 정의되어 있는 클래스의 모든 특성을 물려 받아 새로운 클래스를 작성하는 기법을 상속이라고 한다.

상속에는 클래스 재활용, 상위 클래스로의 통합을 통한 반복 제거, 다형성 부여의 효과가 있다.

클래스 선언문의 : 이후에 상속 엑세스 지정자를 설정할 수 있다. private 멤버는 뭘 하든 접근할 수 없고, 엑세스 지정자가 public이면 기반 클래스의 속성 유지, private나 protect는 부모의 모든 멤버가 상속되며 각각 private, protected로 바뀐다. 디폴트 상속 엑세스 지정자는 private이다. 구조체는 public.

상속받은 멤버의 초기화는 초기화 리스트에서 기반 클래스의 생성자를 호출해서 진행한다.

파괴자는 생성자의 역순으로 호출된다. 부모는 자식을 모르기에 이게 자연스럽다.

생성자, 파괴자, 대입 연산자, 정적 멤버 변수 및 함수, 프렌드 관계 지정은 상속되지 않는다.

상속 받은 멤버와 자신의 멤버가 중복되면 자신의 멤버가 우선적으로 참조된다.

다중 상속에서 기반 클래스들의 초기화 순서는 초기화 리스트 순서가 아니라 클래스 선언문의 기반 클래스 지정 순서와 같다.

```cpp
#include <iostream>
using namespace std;

struct A {
    int a;
    A(int aa) { a = aa; }
};

struct B : public A {
    int b;
    B(int aa, int ab) : A(aa) { b = ab; }
};

struct C : public A {
    int c;
    C(int aa, int ac) : A(aa) { c = ac; }
};

struct D : public B, public C {
    int d;
    D(int aa, int ab, int ac, int ad) : B(aa, ab), C(aa, ac) { d = ad; }
    void fD() {
        b = 1;
        c = 2;
        /*
        non-static member 'a' found in multiple base-class subobjects of type 'A':
        struct D -> struct B -> struct A
        struct D -> struct C -> struct A
        */
        // a = 3;
    }
};

int main() {
    D d(1, 2, 3, 4);
}
```

Virtual base class는 간접적으로 두 번 상속되어도 결과 클래스에는 자신의 멤버를 한 번만 상속시킨다. 가상 기반 클래스의 생성자는 자식의 생성자에서 호출되지 않는다. 최종 클래스에 맡긴다.

private 상속은 포함과 유사한 효과가 있으며 HAS A 관계를 구현하는 또 다른 방법이다.

> private 상속이 포함과 유사하다고 하는 가장 큰 이유는 구현만 상속할 뿐 인터페이스를 상속하지 않기 때문이다. private 상속은 기반 클래스의 모든 멤버를 상속과 동시에 private 속성으로 바꾸어 버린다. 그래서 Product의 내부에서는 상속받은 멤버 함수 OutDate를 호출할 수 있지만 외부에 대해서는 이 멤버 함수가 숨겨지므로 Product는 이 인터페이스를 가지지 않는 것과 같아진다. 외부뿐만 아니라 Product로부터 파생되는 클래스에 대해서도 마찬가지로 OutDate는 알려지지 않는다. ... 함수는 물려받지 않고 코드만 물려받는 이런 상속을 구현 상속이라고 한다.

public 상속은 기반 클래스에 정의되어 있는 멤버 함수를 직접 호출할 수 있다.

```cpp
// 중첩 클래스
class LinkedList {
private:
     struct Node {
          int data;
          Node *prev,*next;
     };
     Node *head,*tail;

public:
     LinkedList();
     ~LinkedList();
     Insert(Node *p,int a);
     Delete(Node *p);
     int GetData(Node *p);
};
```

```cpp
void adderFactory(int n) {
    int temp = 0;
    struct dummy {
        static int adder(int n) {
            // reference to local variable 'temp' declared in enclosing function 'adderFactory'
            return temp += n;
        }
    };
    dummy::adder(n);
}

int main() {
    adderFactory(10);
}
```

[Do we have closures in C++?](https://stackoverflow.com/questions/12635184/do-we-have-closures-in-c)

[What is the difference between a 'closure' and a 'lambda'?](https://stackoverflow.com/questions/220658/what-is-the-difference-between-a-closure-and-a-lambda)

가상 함수란 클래스 타입의 포인터로 멤버 함수를 호출할 때 동작하는 특별한 함수이며 다형성을 구현하는 문법적 기반이다.

> 포인터는 두 가지 종류의 타입을 가진다. 정적 타입(Static Type)이란 포인터가 선언될 때의 타입, 즉 포인터 자체의 타입을 의미하며 동적 타입(Dynamic Type)이란 포인터가 실행중에 가리키고 있는 대상체의 타입, 즉 대상체의 타입을 의미한다.

**클래스는 타입이다 / 부모는 자식을 가리킬 수 있다.**

virtual로 가상 함수로 선언하면 자식의 함수도 가상 함수가 된다. 양쪽 붙이는게 좋긴 함. 클래스 선언문에서만 쓸 수 있다. 외부 함수는 안됨.

```cpp
#include <iostream>
using namespace std;

struct A {
    void foo() {
        cout << "A" << endl;
    }
};

// class이면서 public 없으면
// error: cannot cast 'B' to its private base class 'A'
struct B : A {
    void foo() {
        cout << "B" << endl;
    }
};

int main() {
    A* ptr;
    B b;
    // error: taking the address of a temporary object of type 'B'
    // ptr = &B();
    ptr = &b;
    ptr->foo();

    // virtual 붙이면 1 -> 8 됨. B도 마찬가지.
    cout << sizeof(A) << endl;
}
```

[C++: What is the size of an object of an empty class?](https://stackoverflow.com/questions/621616/c-what-is-the-size-of-an-object-of-an-empty-class)

> 부모 클래스형의 포인터로부터 멤버 함수를 호출할 때 비가상 함수는 포인터가 어떤 객체를 가리키는가에 상관없이 항상 포인터 타입 클래스의 멤버 함수를 호출한다. 반면 가상 함수는 포인터가 가리키는 실제 객체의 함수를 호출한다는 점이 다르다.

지금까지의 함수 호출은 함수 주소가 고정된 정적 결합이었지만 위 경우는 동적 결합이다. 포인터가 가르키는 객체의 타입에 따라 적절한 함수를 선택해서 점프하는 코드로 번역해야한다.

이전에 배운 가상 기반 클래스의 virtual과 아얘 다르다.

대부분의 컴파일러는 동적 결합을 vtable이라는 가상 함수 목록을 작성하고 각 객체에 vtable을 가리키는 멤버 vptr을 추가하는 방식을 사용한다. 컴파일러는 가상 함수를 단 한개라도 가진 클래스에 대해 vtable을 작성하며 해당 클래스에 소속된 가상 함수들의 실제 번지들이 선언된 순서대로 기록되어있다.

```cpp
#include <iostream>
using namespace std;

typedef void (*VoidFunc)();

struct A {
    virtual void foo() {
        cout << "A" << endl;
    }
};

struct B : A {
    void foo() {
        cout << "B" << endl;
    }
    // void foo2() {
    //     cout << "B2" << endl;
    // }
};

int main() {
    B b;
    VoidFunc* vtbl = *((VoidFunc**)&b);
    // int *vtbl2 = ((int*)vtbl)+1;
    cout << sizeof(b) << endl;
    (*vtbl)();
    // (*(vtbl + 1))();
    // (*(VoidFunc*)vtbl2)();
}
```

> vtable(가상 함수 테이블)이란 **가상 함수의** 번지 목록을 가지는 일종의 함수 포인터 배열이다.

자바의 메소드는 모두 가상이다.

클래스 멤버 함수 내부에서도 결국에는 this->로 호출하니 다형성이 적용된다.

```cpp
#include <iostream>
using namespace std;

typedef void (*VoidFunc)();

class A {
    virtual void foo() {
        cout << "A" << endl;
    }

   public:
    void foo2() {
        foo();
    }
};

class B : public A {
    void foo() {
        cout << "B" << endl;
    }
};

int main() {
    B().foo2();
}
```

[What is the use of having destructor as private?](https://stackoverflow.com/questions/631783/what-is-the-use-of-having-destructor-as-private)

가상 함수는 재정의해도 되는 함수고 순수 가상 함수는 재정의해야되는 함수다.

> 하나 이상의 순수 가상 함수를 가지는 클래스를 추상 클래스(Abstract Class)라고 한다.

> 만약 파생 클래스가 추상 클래스의 순수 가상 함수를 재정의하지 않는다면 이 클래스도 여전히 추상 클래스이므로 인스턴스를 생성할 수 없다.

```cpp
#include <iostream>
using namespace std;

class A {
    // 구현을 넣을 수 있기는 하다.
    // 그러고 A::foo() 식으로 호출.
    virtual void foo() = 0;
};

class B : A {
};

int main() {
    // variable type 'B' is an abstract class
    B b;
}
```

> 일반화 프로그래밍 : 임의 타입에 대해 동작하는 함수나 클래스를 작성할 수 있다. 객체 지향보다 재사용성과 편의성이 더 우수하다.

템플릿 타입으로 지역적으로 선언된 타입은 사용할 수 없다. 함수 간 소통에 사용할 수 없기 때문이다.

> 함수 템플릿은 함수를 만들기 위한 템플릿이고 템플릿 함수는 템플릿으로부터 만들어지는 함수이다.

```cpp
#include <iostream>
using namespace std;

template <typename T>
void printSize() {
    cout << sizeof(T) << endl;
}

int main() {
    printSize<int>();
    printSize<char>();
}
```

> 리턴 타입만 다른 템플릿이나 알지도 못하는 타입의 지역변수를 선언하는 함수는 그다지 실용성이 없어 보이고 저런 걸 어디다 쓸까 싶지만 호환되는 여러 가지 타입의 객체 중 원하는 것을 선택해서 대신 생성해 주는 래퍼 함수를 만들고 싶을 때 이런 기법이 가끔 사용되기도 한다. STL을 연구하다 보면 이런 함수를 실제로 볼 수 있는데 그때를 위해 이런 문법도 있다는 것은 기억해 두도록 하자.

템플릿끼리의 오버로딩도 가능하다.

> printf 함수처럼 타입에 따라 서식을 미리 결정해야 하는 함수는 함수 템플릿에서 쓰지 않는 것이 바람직하다. 다음 함수를 보자.

> 템플릿은 지금 당장 잘 컴파일되고 이상없이 동작하는 것처럼 보이더라도 타입이 바뀌면 어떻게 될지 장담할 수 없다.

```cpp
#include <iostream>
using namespace std;

template <typename T>
void foo() {
    cout << "normal" << endl;
}

// <> 없으면
// error: explicit template instantiation cannot have a definition; if this definition is meant to be an explicit specialization, add '<>' after the 'template' keyword
template <>
void foo<double>() {
    cout << "specialized" << endl;
}

int main() {
    foo<int>();
    foo<double>();
    foo<ostream>();
}
```

```cpp
#include <iostream>
using namespace std;

// 클래스 템플릿
template <typename T>
struct SizeOf {
    void print() {
        cout << sizeof(T) << endl;
    }
};

int main() {
    // 템플릿 클래스
    SizeOf<int>().print();
    SizeOf<float>().print();
    SizeOf<double>().print();
}
```

생성자의 이름은 클래스의 이름을 따라가지만 클래스 템플릿에서는 보통 생성자에 <T>를 붙이지 않는다.

```cpp
#include <iostream>
using namespace std;

template <typename T>
struct A {
    void print() {
        cout << sizeof(T) << endl;
    }
};

template <typename T>
struct B : A<T> {
    void print() {
        A<T>::print();
        cout << sizeof(T) << endl;
    }
};

int main() {
    B<double> b;
    b.print();
}
```

[Inheriting from a template class in c++](https://stackoverflow.com/questions/8810224/inheriting-from-a-template-class-in-c)

[How to call a parent class function from derived class function?](https://stackoverflow.com/questions/357307/how-to-call-a-parent-class-function-from-derived-class-function)

> 템플릿 클래스가 다른 클래스의 기반 클래스로 사용되면 컴파일러는 클래스를 즉시 구체화한다. 설사 이 클래스의 인스턴스 선언문이 없더라도 말이다.

[Why can templates only be implemented in the header file?](https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file)

[Reason for using non-type template parameter instead of regular parameter?](https://stackoverflow.com/questions/7395700/reason-for-using-non-type-template-parameter-instead-of-regular-parameter)

```cpp
#include <stdio.h>

template <unsigned n>
struct Factorial {
    enum {
        result = n * Factorial<n - 1>::result
    };
};
template <>
struct Factorial<0> {
    enum {
        result = 1
    };
};

int main() {
    printf("%d\n", Factorial<5>().result);
}
```

```cpp
template <typename T=int>
class Foo {
     ...
}

template <>
class Foo<int> {
     ...
}

// 부분 특수화, partial specialization
template <typename T1, typename T2> class SomeClass { ... };
template <typename T1> class SomeClass<T1, double> { ... };

// 템플릿 중첩
// 오른쪽 쉬프트 연산자로 해석되기에 두 > 사이에 공백이 있어야한다.
TStack<PosValue<int> > sPos(10);
```

```cpp
// 구조가 끔찍하다.
// 모든 함수가 성공 여부도 리턴해야한다. 특수한 리턴값으로 성공 여부를 나타내는건 겹칠? 위험이 있다.
// 작업 코드와 예외 처리 코드가 섞여있다.
// 예외 처리 문법이 필요하다.
size=필요한 메모리 양 조사
if (size < 100M || size > 0) {
     ptr=malloc(size);
     if (ptr) {
          if (InputData(ptr) == TRUE) {
              if (CalcData(ptr) == TRUE) {
                   File=파일 열기();
                   if (File) {
                        if (파일 쓰기()) {
                            에러 출력("파일 쓰기 실패");
                        }
                        파일 닫기();
                   } else {
                        에러 출력("파일을 열 수 없음");
                   }
              } else {
                   에러 출력("계산중 에러 발생");
          } else {
              에러 출력("입력중 에러 발생");
          }
          free(ptr);
     } else {
          에러 출력("메모리 할당 실패");
     }
} else {
     에러 출력("요구하는 메모리 크기가 너무 크거나 황당하게 작음");
}
```

[What is the difference between exit and return?](https://stackoverflow.com/questions/3463551/what-is-the-difference-between-exit-and-return)

> throw는 호출원으로 돌아가기 전에 자신과 자신을 호출한 함수의 스택을 모두 정리하고 돌아가는데 이를 **스택 되감기(Stack Unwinding)**라고 한다.
>
> throw는 대응되는 try 블록의 catch를 찾기 위해 스택에서 위쪽 함수를 찾아 올라가면서 호출 스택을 차례대로 정리하는데 이때 각 함수들이 지역적으로 선언한 객체들도 정상적으로 파괴된다.

```cpp
#include <stdio.h>

class C {
    int a;

   public:
    C() { puts("C INIT"); }
    // 스택 정리 과정에서 호출된다.
    ~C() { puts("C DEINIT"); }
};

void divide(int a, int d) {
    if (d == 0) throw "Can't divide by 0";
}

void calc(int t, const char *m) {
    C c;
    divide(10, 0);
}

int main() {
    try {
        calc(1, "계산");
    } catch (const char *message) {
        puts(message);
    }
    puts("프로그램이 종료됩니다.");
}
```

예외로 클래스를 던져 보다 자세한 정보를 전달할 수 있다.

```cpp
#include <stdio.h>

class Exception {
   private:
    int ErrorCode;

   public:
    Exception(int ae) : ErrorCode(ae) {}
    int GetErrorCode() const { return ErrorCode; }
    void ReportError() const {
        switch (ErrorCode) {
            case 1:
                puts("메모리가 부족합니다.");
                break;
            case 2:
                puts("연산 범위를 초과했습니다.");
                break;
        }
    }
};

void foo() {
    throw Exception(1);
}

int main() {
    try {
        foo();
        // const는 stackoverflow 참고해서 내가 추가함
    } catch (const Exception &e) {
        e.ReportError();
    }
}
```

에러 객체는 스택 할당인 것 같은데 어떻게 남는거지? [Is catching an exception by reference dangerous?](https://stackoverflow.com/questions/33387545/is-catching-an-exception-by-reference-dangerous)

상속을 통해 예외 계층을 만들면 필요에 따라 catch에서 부모 클래스로 퉁칠 수 있다. 다형성 활용.

클래스 내부에 예외 클래스를 지역적으로 선언하여 클래스 내부에서 예외를 처리할 수 있다.

객체 생성자라 에러를 던지는 경우 스코프때문에 객체 선언문만 try 블록으로 감쌀 수는 없기에 예외 처리 구문 대신 성공적인 생성 여부를 표시하는 별도의 멤버를 두고 이를 보는 방법을 더 많이 사용한다.

```cpp
#include <iostream>
using namespace std;

void divide(int a, int d) try {
    if (d == 0) throw "Cannot divide by zero.";
} catch (const char* e) {  // char*이면 안된다!!
    cout << e << endl;
}

int main() {
    divide(1, 0);
}
```

중괄호가 없는 표기법은 생성자에서 에러 처리를 할 때 유용한데, 기존의 일부 코드만 감싸는 try 블록 표기법으로는 초기화 리스트까지 예외 처리 블록에 포함시킬 수 없다. try 블록 형태로 생성자를 작성하면 초기화 리스트의 코드도 try 블록에 포함된다. 생성자의 예외는 호출자에게도 전달된다.

표준 C++ 라이브러리는 모든 예외의 루트로 사용할 수 있는 exception 클래스를 정의하며 문자열 포인터를 리턴하는 what이라는 가상 함수를 제공한다. 표준 예외는 exception에서 파생되어나오며 크게 논리 에러와 런타임 에러로 나뉜다.

[How to deal with bad_alloc in C++?](https://stackoverflow.com/questions/9456728/how-to-deal-with-bad-alloc-in-c)

> 만약 미처리 예외를 특별한 방식으로 처리하고 싶다면 미처리 예외의 핸들러를 따로 등록할 수 있다.

```cpp
#include <exception>
#include <iostream>

void myTerminate() {
    std::cout << "myTerminate" << std::endl;
}

int main() {
    std::set_terminate(myTerminate);
    throw 1;
    // libc++abi: terminate_handler unexpectedly returned
    // 아래 실행 안됨
    std::cout << "main" << std::endl;
}
```

> 함수를 작성할 때 함수의 원형 뒤쪽에 이 함수 실행중에 발생할 수 있는 예외의 종류를 지정할 수 있다.

```cpp
void func(int a, int d) throw(char *, int)

// 이딴게 된다니
void fA() throw(int, double) {
}

void fB() throw(char) {
     fA();
}

// 위와 같은 경우에서 지정하지 않은 예외가 발생하면 unexpected라는 함수가 호출되어 미지정 예외를 처리한다.
unexpected_handler set_unexpected(unexpected_handler ph)

// unexpected handler에서 에러를 던지면 지정된 타입의 예외 핸들러로 제어를 옮긴다.
```

아래처럼 예외로 인해 메모리 누수가 발생할 수도 있다.

```cpp
#include <stdio.h>
#include <stdlib.h>

class SomeClass {};

// error: ISO C++17 does not allow dynamic exception specifications
// ?????
void calc() noexcept(false) {
    SomeClass obj;
    char *p = (char *)malloc(1000);
    if (true /*예외 발생*/) throw 1;
    free(p);
}

int main() {
    try {
        calc();
    } catch (int) {
        puts("정수형 예외 발생");
    }
}
```

예외 처리 구문은 클래스 템플릿에서 사용할 수 없고, 멀티 스레드 환경에서 사용하기 어렵다.

> 이 외에도 예외 처리는 스택 되감기 중 파괴자에서 예외 발생시의 애매함, 예외 핸들러에서 예외가 발생한 지점을 알 수 없다는 한계들이 존재한다.

[If you shouldn't throw exceptions in a destructor, how do you handle errors in it?](https://stackoverflow.com/questions/130117/if-you-shouldnt-throw-exceptions-in-a-destructor-how-do-you-handle-errors-in-i)

[Are Exceptions in C++ really slow](https://stackoverflow.com/questions/13835817/are-exceptions-in-c-really-slow)

[Why is "using namespace std;" considered bad practice?](https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice)

> 변수는 잘못 읽어봐야 쓰레기가 출력되고 말지만 함수는 잘못 호출되면 어디로 튈지 예측할 수 없기 때문에 다운될 확률이 아주 높다.

```cpp
#include <iostream>
using std::cout;
using std::endl;

class Parent {
   public:
    virtual void PrintMe() { cout << "Parent" << endl; }
};

class Child : public Parent {
   private:
    int num;

   public:
    Child(int anum = 1234) : num(anum) {}
    virtual void PrintMe() { cout << "Child" << endl; }
    void PrintNum() { cout << "Child: " << num << endl; }
};

void foo(Parent *p) {
    p->PrintMe();
    ((Child *)p)->PrintNum();
    // p가 어떤 객체를 가르키고 있는지 런타입에 알 방법이 필요하다. 
    // RTTI, Runtime Type Information. 
    // 컴파일러 옵션으로 조절할 수 있다. 사실 위 예시는 기반 클래스에 PrintNum을 선언하면 된다. 
}

int main() {
    Child c(5);
    Parent p;
    foo(&c);
    foo(&p);
}
```

```cpp
#include <stdio.h>

#include <typeinfo>

class Parent {
   public:
    virtual void PrintMe() { printf("Parent\n"); }
};

class Child : public Parent {
   private:
    int num;

   public:
    Child(int anum = 1234) : num(anum) {}
    virtual void PrintMe() { printf("Child\n"); }
    void PrintNum() { printf("Child=%d\n", num); }
};

int main() {
    Parent P, *pP;
    Child C, *pC;
    pP = &P;
    pC = &C;

    printf("P=%s, pP=%s, *pP=%s\n",
           typeid(P).name(), typeid(pP).name(), typeid(*pP).name());

    printf("C=%s, pC=%s, *pC=%s\n",
           typeid(C).name(), typeid(pC).name(), typeid(*pC).name());

    pP = &C;
    printf("pP=%s, *pP=%s\n",
           typeid(pP).name(), typeid(*pP).name());

    printf("%d\n", typeid(*pP) == typeid(C));
    printf("%d\n", typeid(*pP) == typeid(Child));
    printf("%d\n", typeid(*pP) == typeid(P));
}
```

> C언어의 캐스트 연산자는 확실히 너무 무책임하고 개발자에게 모든 것을 떠 넘긴다. 원하는대로 바꿔 줄테니 결과가 어찌 되든 개발자가 책임을 지라는 식이다. 그래서 C++에서는 좀 더 안전하고 변환 목적에 맞게 골라 쓸 수 있는 4개의 새로운 캐스트 연산자를 제공한다. 이 연산자들은 C의 캐스트 연산자에 비해 규칙이 다소 엄격해 실수를 줄일 뿐만 아니라 어떤 의도의 타입 변환인지를 좀 더 분명히 표시하는 장점이 있다.

static_cast는 정수형 실수형 사이 가능, 포인터는 상속 관계만.

[Why use static_cast<int>(x) instead of (int)x?](https://stackoverflow.com/questions/103512/why-use-static-castintx-instead-of-intx)

dynamic_cast는 포인터끼리, 레퍼런스끼리 변환. 포인터끼리는 부모 자식 관계여야하고 다운 캐스팅은 안전할 때만. 변환 대상 포인터가 실제 자식 객체를 가리키고 있을 때. 이때는 NULL을 리턴. 레퍼런스는 bad_cast 예외 던짐. 다중 상속에서는 복잡해지는데 생략,,

const_cast는 포인터의 상수성을 바꾼다.

```cpp
const char *c1;
char *c2;
c2=(char *)c1;

// 이 상태에서 어떤 이유로 c1을 const double *로 변경했다고 하자.
// 애초에 상수성을 없애기 위해 (char *) 연산자를 사용했는데 의미가 완전히 바뀌어 버려 타입을 변경하라는 명령이 되어 버린다.
```

> C의 캐스트 연산자는 변환의 범위가 너무 넓은데 비해 C++의 캐스트 연산자는 기능이 제한적이다.

reinterpret_cast는 임의의 포인터끼리, 정수형과 포인터 사이 가능. 위험함. 정수형과 구조체는 얘로도 안된다. C로도 안된다네?

> 멤버 포인터 변수란 특정 클래스(구조체도 물론 포함된다.)에 속한 멤버만을 가리키는 포인터이다.

```cpp
struct MyClass {
    int i, j;
    double d;
};

int main() {
    MyClass C;
    int MyClass::*pi;
    double MyClass::*pd;
    int num;

    pi = &MyClass::i;
    pi = &MyClass::j;
    pd = &MyClass::d;
    // pd=&MyClass::i;
    // pi=&MyClass::d;
    // pi=&num;
}
```

> 주로 클래스내의 멤버 위치인 오프셋을 기억해 두었다가 .\*연산자가 적용될 때 객체의 오프셋을 대상체 타입만큼 읽는 방법을 쓴다.

```cpp
#include <stdio.h>

class Position {
   public:
    int x, y;
    char ch;

    Position() {
        x = 0;
        y = 0;
        ch = 'A';
    }

    void Print() {
        printf("%c: (%d, %d)\n", ch, x, y);
    }
};

int main() {
    Position pos;
    Position *ptr = &pos;
    int Position::*iptr;

    iptr = &Position::x;
    pos.*iptr = 30;
    iptr = &Position::y;
    ptr->*iptr = 5;
    pos.Print();
}
```

함수 포인터를 쓸까 싶기도 하지만 클래스에 속한 멤버 함수는 일반 함수와는 달리 호출 방법이 달라 이에 대한 포인터를 선언하는 문법도 달라야한다.

```cpp
class Test;
typedef void (Test::*fpop)(int,int);

class Test {
public:
     void Op1(int a,int b) { printf("%d\n",a+b); }
     void Op2(int a,int b) { printf("%d\n",a-b); }
     void Op3(int a,int b) { printf("%d\n",a*b); }
};

int main() {
     int ch;
     Test t;
     int a=3,b=4;
     static fpop arop[3]={&Test::Op1,&Test::Op2,&Test::Op3};

     printf("연산 방법을 선택하시오. 0=더하기, 1=빼기, 2=곱하기 : ");
     scanf("%d",&ch);

     if (ch >= 0 && ch <= 2) {
          (t.*arop[ch])(3,4);
     }
}
```

> 네임 스페이스(Name Space)는 말 뜻 그대로 명칭들이 기억되는 영역이며 명칭의 소속 공간이다.

```cpp
int i;  // 전역 네임 스페이스 소속
namespace A {
int i;  // A 소속
}

void func() {
    int i;

    i = 1;     // 지역변수 i
    ::i = 2;   // 전역 네임 스페이스의 i
    A::i = 3;  // A 네임 스페이스의 i
}

int main() {
    func();
}
```

이름 없는 네임스페이스는 C의 static과 유사하게 파일 범위 스코프를 가진다.

```cpp
// *.cpp
#include "Util.h"
int main() {
     A::func();
}

// Util.h
namespace A {
     void func();
}

// Util.cpp
void A::func() {

}
```

> 헤더 파일의 네임 스페이스안에 변수를 선언하면 이 헤더 파일을 인클루드하는 모든 모듈에 동일한 이름의 변수가 중복 생성될 것이다. 주로 클래스나 구조체같은 타입 선언이 네임 스페이스에 배치된다. C++에서는 주로 클래스간의 충돌이 문제가 되며 변수나 함수는 클래스안에서 지역적이므로 문제가 되는 경우가 드물다.

using 지시자는 지시자가 속한 영역에 국한된다. 함수 안에서 하면 함수 스코프 내에서만 됨.

using 선언(using namespace A::b)은 식별자가 충돌하면 에러로 처리하지만 using 지시자(using namespace A)는 에러나 경고를 내지 않는다.

```cpp
// namespace 별명
namespace VeryVeryLongNameSpaceName {
     struct Person { };
}

int main() {
     namespace A=VeryVeryLongNameSpaceName;
     A::Person P;
}
```

C++ 표준 라이브러리는 모두 std 네임 스페이스에 선언되어있다.

> 구조체는 외부에서 주는 값을 선택의 여지없이 저장하기만 하는데 비해 객체는 생성자가 직접 초기화하므로 스스로의 무결성을 지킬 수 있다.

```cpp
// C++이 언어 차원에서 가장 권장하는 방법은 예외를 던지는 것이다.
Position(int ax, int ay, char ach) {
     if (ax < 0 || ax >= 80) { throw ax; }
     if (ay < 0 || ay >= 25) { throw ay; }
     x=ax; y=ay; ch=ach;
}
```

```cpp
#include <iostream>

struct Foo {
    Foo() {
        std::cout << "Foo" << std::endl;
    }
};

Foo foo;

int main() {
    std::cout << "main" << std::endl;
}
```

생성자와 소멸자가 자동 호출되는 특성을 활용해 전역적이거나 지역적인(스택) 초기화(소멸자에서는 원상복구)를 할 수 있다.

> 위에서 봤다시피 전역 객체의 생성자가 (main함수의 실행보다) 더 우선적으로 실행되는데 이런 식으로 프로그램 시작 후에 초기화되는 것을 동적 초기화(runtime initialize)라고 한다. ... 이 점을 이용하면 전역변수 초기화 함수에서 원하는 전역 초기화를 할 수 있다.

```cpp
class ConstRef {
   public:
    int value;
    int &ri;
    const int ci;
    ConstRef(int value, int &ri, const int ci) : value(value), ri(ri), ci(ci) {}

    // ConstRef &operator=(const ConstRef &Other) {
    //     if (this != &Other) {
    //         value = Other.value;
    //     }
    //     return *this;
    // }
};

int main() {
    int i, j;
    ConstRef t1(1, i, 2);
    ConstRef t2(3, j, 4);
    // copy assignment operator of 'ConstRef' is implicitly deleted
    // because field 'ri' is of reference type 'int &'
    t2 = t1;
}
```

> 클래스에서는 오버로딩과 오버라이딩이 동시에 일어날 수 있다. 클래스의 멤버 함수들끼리 중복 정의가 가능하고 또 파생 클래스에서 상속받은 멤버를 재정의하는 것도 가능하다. 그런데 파생 클래스에서 상속된 멤버 함수와 인수 목록이 다른 함수를 같은 이름으로 재정의하면 이때는 오버로딩이 적용되지 않는다. 즉, 인수 목록이 아무리 달라도 파생 클래스가 같은 이름으로 함수를 재정의하면 동일한 이름을 가지는 부모의 모든 함수들이 가려진다.

```cpp
#include <stdio.h>

struct B {
    void f(int a) { puts("B::f(int)"); }
    void f(double a) { puts("B::f(int)"); }
};

struct D : B {
    void f(char *a) { puts("D::f(char *)"); }
};

void main() {
    D d;
    d.f("");   // 가능
    d.f(1);    // 에러
    d.f(2.3);  // 에러
}
```

> 오버로딩과 오버라이딩이 양립할 수 없기 때문에 상속받은 멤버 함수를 재정의할 때는 부모의 멤버 함수와 완전히 같은 원형으로 재정의해야 한다.

> 또한 기반 클래스에 여러 개의 함수가 중복 정의되어 있다면 이 함수들을 모두 재정의하거나 아니면 아예 재정의하지 말아야 한다. 하나만 재정의하면 이 함수에 의해 원형이 다른 함수들은 모두 가려질 것이다.

```cpp
#include <stdio.h>

struct Base {
    void f(char *) { puts("B::f(char *)"); }
    void f(long) { puts("B::f(long)"); }
};

struct Derived : Base {
    void f(double) { puts("D::f(double)"); }
};

int main() {
    Derived d;
    d.f(1234);
}
```

부모 클래스가 바뀌었다고 자식 클래스의 동작이 바뀌는게 싫어서 이렇게 만든 듯?

```cpp
#include <stdio.h>

class Base {
   protected:
    long bnum = 0;

   public:
    virtual void OutMessage() { printf("Base Class"); }
};

class Derived : public Base {
   private:
    long dnum = 0;

   public:
    virtual void OutMessage() { printf("Derived Class"); }
};

int main() {
    Derived arD[5];
    Base *pB = arD;
    for (int i = 0; i < 5; i++) {
        printf("%p\n", pB);
        (pB++)->OutMessage();
    }
}
```

위 예제에서 원래는 멤버 변수가 int로 선언되어있었는데, 이게 1개든 2개든 64비트 환경에서는 align이 되서인지 에러가 발생하지 않음. 

```cpp
#include <stdio.h>

class Foo {};

class Bar : Foo {};

int main() {
    Bar bar;
    // error: cannot cast 'Bar' to its private base class 'Foo'
    // private 상속은 인터페이스를 상속받지 않는다. 
    Foo* fptr = &bar;
}
```

```cpp
class B {
private:
     void p() { puts("Base private function"); };
protected:
     void f() { puts("Base protected function"); }
public:
     void u() { puts("Base public function"); }
};
 
class D : public B {
protected:
//  using B::u;
// 여기로 옮기면 u를 외부에서 호출할 수 없다. 
public:
//  using B::f; 
// using 선언을 통해 protected 영역의 f 함수를 public 영역으로 명칭을 가져올 수 있다. 
     void f() { B::f(); }
};
 
int main() {
     D d;
     d.f();
     d.u();
}
```

## 4부. C++ 고급


