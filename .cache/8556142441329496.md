
귀납법 마스터해보자... 일단 이산수학 수업 범위부터 살펴보자.

중간1 범위는 여기로 옮겨적지 못함. 나중에 공부할 때 정리하기.

## Preface

> A discrete mathematics course has more than one purpose. Students should learn a particular set of mathematical facts and how to apply them; more importantly, such a course should teach students how to think logically and mathematically.

위 목표들을 이루기 위해 아래의 것들이 필요하다.

- Mathematical Reasoning: Students must understand mathematical reasoning in order to read, comprehend, and construct mathematical arguments.
- Combinatorial Analysis: An important problem-solving skill is the ability to count or enumerate objects.
- Discrete Structures: A course in discrete mathematics should teach students how to work with discrete structures.
- Algorithmic Thinking: Computer program can be constructed implementing algorithm. The mathematical portions of this activity, which include the specification of the algorithm, the verification that it works properly, and the analysis of the computer memory and time required to perform it, are all covered in this text.
- Applications and Modeling: Discrete mathematics has applications to almost every conceivable area of study.

[Student companion site](https://highered.mheducation.com/sites/125967651x/student_view0/)

> Discrete mathematics is the part of mathematics devoted to the study of discrete objects. (Here discrete means consisting of distinct or unconnected elements.)

> Discrete mathematics is used whenever objects are counted, when relationships between finite (or countable) sets are studied, and when processes involving a finite number of steps are analyzed.

> ...discrete mathematics course to be significantly more challenging ... One reason for this is that one of the primary goals of this course is to teach mathematical reasoning and problem solving, rather than a discrete set of skills.

## 1. The Foundations: Logic and Proofs

> Everyone knows that proofs are important throughout mathematics, but many people find it surprising how important proofs are in computer science. In fact, proofs are used to verify that computer programs produce the correct output for all possible input values, to show that algorithms always produce the correct result ...

> In this chapter, we will explain what makes up a correct mathematical argument and introduce tools to construct these arguments.

### Propositional Logic

> Because a major goal of this book is to teach the reader how to understand and how to construct correct mathematical arguments, we begin our study of discrete mathematics with an introduction to logic.

> A **proposition** is a declarative sentence (that is, a sentence that declares a fact) that is either true or false, but not both.

> We use letters to denote **propositional variables** (or statement variables), that is, vari- ables that represent propositions.

Proposional variable은 truth value를 가진다.

> The area of logic that deals with propositions is called the propositional calculus or propo- sitional logic.

조지 불이 이미 있는 명제로 다른 명제를 만들어내는 방법을 *The Laws of Thought*에서 발표했다. 이렇게 기존 명제들로부터 logical operator를 사용해 만든 새로운 명제를 **compound propositions**라 한다.

> We will now introduce the logical operators that are used to form new propositions from two or more existing propositions. These logical operators are also called connectives.

AND -> conjunction. but이 and의 의미로 사용되는 경우가 있으니 주의. "The sun is shining, but it is raining."

OR -> disjuction. 자연어에서는 inclusive or와 exclusive or가 있으니 주의. 전자는 "Students who have taken calculus or computer science can take this class.", 후자는 "Soup or salad comes with entrée."

p->q에서 p는 hypothesis(antecedent, premise), q는 conclusion(consequence).

- “if p, then q”
- “if p, q”
- “p is sufficient for q”
- “q if p”
- “q when p”
- “a necessary condition for p is q”
- **“q unless ¬p”**
- “p implies q”
- **“p only if q”**
- “a sufficient condition for q is p”
- “q whenever p”
- “q is necessary for p”
- “q follows from p”

p->q가 있을 때 q->p는 converse, ~q->~p는 contrapositive, ~p->~q는 inverse.

> When two compound propositions always have the same truth value we call them equiv- alent.

p<->q는 두 명제가 같은 진리값을 가져야 참이다. Biconditional statement. bi-implications라고도 한다. (p → q) ∧ (q → p).

- “p is necessary and sufficient for q”
- “if p then q, and conversely”
- “p iff q.”

Biconditional은 자연어에서는 명시적이지 않을 수 있다. 'If you finish your meal, then you can have dessert.' -> F/T인 경우가 함축적으로 거짓임.

논리 연산자의 우선순위는 ~, (AND, OR), ->, <->이다.

> A variable is called a Boolean variable if its value is either true or false.

> A bit string is a sequence of zero or more bits. The length of this string is the number of bits in the string.

> We can extend bit operations to bit strings. We define the bitwise OR, bitwise AND, and bitwise XOR.

## 2. Basis Structures: Sets, Functions, Sequences, Sums, and Matrices

2.1-6

**여기까지 중간1**

## 3. Algorithms

3.1-3

### 1. Algorithms

> An **algorithm** is a finite sequence of precise instructions for performing a computation or for solving a problem.

Pseudocode provides an **intermediate step** between an English language description of an algorithm and an implementation of this algorithm in a programming language.

```txt
procedure max(a1, a2, ..., an: integers)
max := a1
for i := 2 to n
    if max < ai then max := ai
return max
```

위 알고리즘의 엄격한 증명은 5.1 단원에서.

알고리즘의 properties. Input, Output, Definiteness(The steps of an algorithm must be defined precisely.), Correctness(An algorithm should produce the correct output values for each set of input values.), Finiteness, Effectiveness(It must be possible to perform each step of an algorithm **exactly** and in a finite amount of time.), Generality.

```txt
procedure linear search(x: integer, a1, a2, ..., an: distinct integers)
i := 1
while (i <= n and x != ai)
    i := i+1
if i <= n then location := i
else location := 0
return location
```

```txt
procedure binary search(x: integer, a1, a2,...,an: increasing integers)
i := 1
j := n
while i < j
    m := ⌊(i + j)/2⌋
    if x > am then i := m + 1
    else j := m
if x = ai then location := i
else location := 0
return location
```

```txt
procedure bubblesort(a1, . . . , an : real numbers with n ≥ 2)
for i := 1 to n - 1
    for j := 1 to n - i
        if aj > aj+1 then interchange aj and aj+1
```

In general, in the jth step of the insertion sort, the jth element of the list is inserted into the correct position in the list of the previously sorted j − 1 elements.

```txt
procedure insertion sort(a1, a2, . . . , an: real number with n >= 2)
for j := 2 to n
    i := 1
    while aj > ai // 본인 이전까지긴 함
        i := i + 1
    m := aj
    for k := 0 to j − i − 1
        aj−k := aj-1−k
    ai := m
```

Many algorithms we will study in this book are designed to solve **optimization problems**. The goal of such problems is to find a solution to the given problem that either minimizes or maximizes the value of some parameter.

Algorithms that make what seems to be the “best” choice at each step are called **greedy algorithms**.

quarters dimes, nickels, and pennies, we have c1 = 25, c2 = 10, c3 = 5, and c4 = 1.

If n is a positive integer, then n cents in change using quarters, dimes, nickels, and pennies using the fewest coins possible has at most two dimes, at most one nickel, at most four pennies, and cannot have two dimes and a nickel. The amount of change in dimes, nickels, and pennies cannot exceed 24 cents.

회의실 예약 증명은 5단원에서 귀납법을 사용해서 한다.

**Halting problem**. Problem that cannot be solved using any procedure.

멈춤 문제를 푸는 프로시저 H(P, I)가 있다고 하자. Program P, Input I. K(P)는 H(P, P)가 루프면 멈추고, 멈추면 루프를 돈다, 즉 H(P, P)와 반대로 행동한다.

이제 K를 K에 입력으로 줘보자. H(K, K)가 루프를 돌면 K의 정의에 따라 K(K)는 멈춘다. 이는 모순이다.

```txt
procedure selection(a1, a2, . . . , an)
for i := 1 to n − 1
    minspot := i
    for j := i + 1 to n
        if aj < aminspot then minspot := j
            interchange aminspot and ai
{the list is now in order}
```

```txt
procedure binary insertion sort(a1, a2, . . . , an: real numbers with n ≥ 2)
for j :=2 to n
    {binary search for insertion location i }
    left := 1
    right:=j−1
    while left < right
        middle := ⌊(left + right)/2⌋
        if a_j > a_middle then left:=middle+1
        else right := middle
    if aj <aleft then i:=left
    elsei:=left+1
    m:=aj
    for k := 0 to j − i − 1
        aj−k := aj−k−1 ai := m
{a1,a2,...,an are sorted}
```

```txt
procedure backward insertion sort(a1, a2, . . . , an : real numbers with n ≥ 2)
    for j := 2 to n
        m := aj
        i := j − 1
    while (m<ai and i>0)
        ai+1 := ai
        i := i − 1 ai+1 := m
{a1,a2,...,an are sorted}
```

### 2. The Growth of Functions

In **Section 3.1** we discussed the concept of an algorithm. We introduced algorithms that solve a variety of problems, including searching for an element in a list and sorting a list. In **Section 3.3** we will study the number of operations used by these algorithms.

One of the advantages of using **big-O notation**, which we introduce in this section, is that we can estimate the growth of a function without worrying about constant multipliers or smaller order terms.

Let f and g be functions from the set of integers or the set of real numbers to the set of real numbers. We say that f (x) is O(g(x)) if there are constants C and k such that |f (x)| ≤ C|g(x)| whenever x > k. [This is read as “f (x) is big-oh of g(x).”]

The constants C and k in the definition of big-O notation are called witnesses to the relationship f(x) is O(g(x)).

Show that f(x) = x2 + 2x+ 1 is O(x2).

We say that two func- tions f (x) and g(x) that satisfy both of these big-O relationships are of the same order.

Remark: The fact that f (x) is O(g(x)) is sometimes written f (x) = O(g(x)). However, the equals sign in this notation does not represent a genuine equality. Rather, this notation tells us that an inequality holds relating the values of the functions f and g for sufficiently large numbers in the domains of these functions. However, it is acceptable to write f (x) ∈ O(g(x)) because O(g(x)) represents the set of functions that are O(g(x)).

When big-O notation is used, the function g in the relationship f (x) is O(g(x)) is chosen to be as small as possible.

To show that n2 is not O(n), we must show that no pair of witnesses C and k exist such that n2 ≤ Cn whenever n > k. We will use a proof by contradiction to show this.

Let f(x) = anxn + an−1xn−1 + ··· + a1x + a0, where a0,a1,...,an−1,an are real numbers. Then f (x) is O(xn). The witnesses C = |an| + |an−1| + · · · + |a0| and k = 1 show that f (x) is O(xn).

Every power of n is big-O of every exponential function of n with a base that is greater than one, but the reverse relationship never holds

Suppose that f1(x) is O(g1(x)) and that f2(x) is O(g2(x)). Then (f1+f2)(x) is O(max(|g1(x)|, |g2(x)|)).

Suppose that f1(x) is O(g1(x)) and f2(x) is O(g2(x)). Then (f1f2)(x) is O(g1(x)g2(x)).

Both big-Omega and big-Theta notation were introduced by Donald Knuth in the 1970s. His motivation for introducing these notations was the common misuse of big-O notation when both an upper and a lower bound on the size of a function are needed.

Let f and g be functions from the set of integers or the set of real numbers to the set of real numbers. We say that f (x) is Ω(g(x)) if there are positive constants C and k such that |f (x)| ≥ C|g(x)| whenever x > k. [This is read as “f (x) is big-Omega of g(x).”]

f (x) is Ω(g(x)) if and only if g(x) is O(f(x)).

Let f and g be functions from the set of integers or the set of real numbers to the set of real numbers. We say that f (x) is "(g(x)) if f (x) is O(g(x)) and f (x) is Ω(g(x)). When f (x) is "(g(x)) we say that f is big-Theta of g(x), that f (x) is of order g(x), and that f (x) and g(x) are of the same order.

When f (x) is "(g(x)), it is also the case that g(x) is "(f (x)). Also note that f (x) is "(g(x)) if and only if f (x) is O(g(x)) and g(x) is O(f (x)).

Let f(x) = anxn +an−1xn−1 +···+a1x +a0,wherea0,a1,...,an arerealnumberswith an ̸= 0. Then f(x) is of order xn.

If f (x) is Ω(g(x)), then there exist con- stants C1 and C2 with C1|g(x)| ≤ |f(x)| ≤ C2|g(x)|.

### 3. Complexity of Algorithms

The efficiency of algorithms will be discussed in this section.

... Questions such as these involve the **computational complexity** of the algorithm. An analysis of the time required to solve a problem of a particular size involves the **time complexity** of the algorithm. An analysis of the computer memory required involves the **space complexity** of the algorithm.

공간 복잡도는 자료 구조 책에서 배우고 여기서는 시간 복잡도를 살펴보자.

Hence, at most 2k + 2 = 2 log n + 2 comparisons are required to perform a binary search when the list being searched has 2^k elements.

Note that the insertion sort may use considerably fewer comparisons if the smaller elements started out at the end of the list.

```txt
procedure matrix multiplication(A, B: matrices)
for i := 1 to m
    forj :=1 to n
        cij := 0
        for q := 1 to k
            cij := cij + a_iq * b_qj
return C {C = [cij] is the product of A and B}
```

Note that m1m2m3 multiplications of integers are performed to multiply an m1 × m2 matrix and an m2 × m3 matrix

```txt
procedure Boolean product of Zero-One Matrices (A, B: zero–one matrices)
for i := 1 to m
    for j := 1to n
        cij := 0
        for q := 1 to k
            cij := cij ∨ (a_iq ∧ b_qj)
return C {C = [cij ] is the Boolean product of A and B}
```

Algorithmic paradigm is a general approach based on a particular concept that can be used to construct algorithms for solving a variety of problems.

Note that Algorithm 1 in Section 3.1 for finding the maximum number in a sequence is a brute-force algorithm because it examines each of the n numbers in a sequence to find the maximum term. The algorithm for finding the sum of n numbers by adding one additional number at a time is also a brute-force algorithm, as is the algorithm for matrix multiplication based on its definition (Algorithm 1). The bubble, insertion, and selection sorts (described in Section 3.1 in Algorithms 4 and 5 and in Exercise 42, respectively) are also considered to be brute-force algorithms; all three of these sorting algorithms are straightforward approaches much less efficient than other sorting algorithms such as the merge sort and the quick sort discussed in Chapters 5 and 8.

A problem that is solvable using an algorithm with polynomial worst-case complexity is called **tractable**, because the expectation is that the algorithm will produce the solution to the problem for reasonably sized input in a relatively short time.

The situation is much worse for problems that cannot be solved using an algorithm with worst-case polynomial time complexity. Such problems are called **intractable**.

Some problems even exist for which it can be shown that no algorithm exists for solving them. Such problems are called **unsolvable**.

Problems for which a solution can be checked in polynomial time are said to belong to the **class NP** (tractable problems are said to belong to class P). The abbreviation NP stands for nondeterministic polynomial time.

**NP-complete problems**, with the property that if any of these problems can be solved by a polynomial worst-case time algorithm, then all problems in the class NP can be solved by polynomial worst-case time algorithms.

...the satisfiability problem was the first problem shown to be NP-complete. The theorem that asserts this is known as the **Cook-Levin theorem**.

The **P versus NP problem** asks whether NP, the class of problems for which it is possible to check solutions in polynomial time, equals P, the class of tractable problems.

Efficient algorithms, including most algorithms with polynomial time complexity, benefit most from significant technology improvements.

## 5. Induction and Recursion

5.1-4

A major goal of this chapter, and the book, is to give the student a thorough understanding of mathematical induction which is used to prove many mathematical statements assert that a property is true for all positive integers.

Sets can be defined by listing some of their elements and giving rules for constructing elements from those already known to be in the set. Such definitions, called recursive definitions, are used throughout discrete mathematics and computer science. Once we have defined a set recursively, we can use a proof method called structural induction to prove results about this set.

### 1. Mathematical Induction

It is extremely important to note that mathematical induction can be used only to prove results obtained in some other way. It is not a tool for discovering formulae or theorems.

Mathematical proofs, including arguments that use mathematical induction, are deductive, not inductive.

> PRINCIPLE OF MATHEMATICAL INDUCTION To prove that P(n) is true for all positive integers n, where P (n) is a propositional function, we complete two steps:
>
> BASIS STEP: We verify that P (1) is true.
>
> INDUCTIVE STEP: We show that the conditional statement P (k) → P (k + 1) is true for all positive integers k.

가정 P(K)를 **inductive hypothesis**라 한다.

> The Well-Ordering Property: Every nonmempty subset of the set of positive integers has a least element.

Why is mathematical induction a valid proof technique?

Suppose we know that P (1) is true and that the proposition P (k) → P (k + 1) is true for all positive integers k. To show that P(n) must be true for all positive integers n, assume that there is at least one positive integer for which P (n) is false.

Then the set S of positive integers for which P (n) is false is nonempty. Thus, by the well-ordering property, S has a least element, which will be denoted by m. We know that m cannot be 1, because P (1) is true. Because m is positive and greater than 1, m − 1 is a positive integer. Furthermore, because m − 1 is less than m, it is not in S, so P (m − 1) must be true. Because the conditional statement P (m − 1) → P (m) is also true, it must be the case that P (m) is true. This contradicts the choice of m. Hence, P (n) must be true for every positive integer n.

Proofs of these theorems by methods other than mathematical induction are often preferred because of the insights they bring.

As we noted, mathematical induction is not a tool for finding theorems about all positive integers. Rather, it is a proof method for proving such results once they are conjectured.

Mathematical induction can be used to prove a variety of inequalities that hold for all positive integers greater than a particular positive integer.

The Number of Subsets of a Finite Set. 모든 경우를 포함하는지에 대한 검사는 필요 없나?

We let P(n) be the proposition that if the greedy algorithm schedules n talks in the main lecture hall, then it is not possible to schedule more than n talks in this hall.

**Template for Proofs by Mathematical Induction**

1. Express the statement that is to be proved in the form “for all n ≥ b, P (n)” for a fixed integer b.
2. Writeoutthewords“BasisStep.”ThenshowthatP(b)istrue,takingcarethatthecorrect value of b is used. This completes the first part of the proof.
3. Write out the words “Inductive Step.”
4. State,andclearlyidentify,theinductivehypothesis,intheform“assumethatP(k)istrue for an arbitrary fixed integer k ≥ b.”
5. State what needs to be proved under the assumption that the inductive hypothesis is true. That is, write out what P (k + 1) says.
6. Prove the statement P (k + 1) making use the assumption P (k). Be sure that your proof is valid for all integers k with k ≥ b, taking care that the proof works for small values of k, including k = b.
7. Clearly identify the conclusion of the inductive step, such as by saying “this completes the inductive step.”
8. After completing the basis step and the inductive step, state the conclusion, namely that by mathematical induction, P (n) is true for all integers n with n ≥ b.

### 2. Strong Induction and Well-Ordering

The validity of both mathematical induction and strong induction follow from the well- ordering property in Appendix 1. In fact, mathematical induction, strong induction, and well ordering are all equivalent principles.

> STRONG INDUCTION
>
> To prove that P (n) is true for all positive integers n, where P (n) is a propositional function, we complete two steps:
>
> BASIS STEP: We verify that the proposition P (1) is true.
>
> INDUCTIVE STEP: We show that the conditional statement [P (1) ∧ P (2) ∧ · · · > ∧ P (k)] → P (k + 1) is true for all positive integers k.

> Computational geometry: the part of discrete mathematics that studies computational problems involving geometric objects

A polygon is a closed geometric figure consisting of a sequence of line segments s1,s2,...,sn,calledsides.Eachpairofconsecutivesides,si andsi+1,i=1,2,...,n−1, as well as the last side sn and the first side s1, of the polygon meet at a common endpoint, called a vertex. A polygon is called simple if no two nonconsecutive sides intersect. Every sim- ple polygon divides the plane into two regions: its interior, consisting of the points inside the curve, and its exterior, consisting of the points outside the curve.

A polygon is called convex if every line segment connecting two points in the interior of the polygon lies entirely inside the polygon. (A polygon that is not convex is said to be nonconvex.)

A diagonal of a simple polygon is a line segment connecting two nonconsecutive vertices of the polygon, and a diagonal is called an interior diagonal if it lies entirely inside the polygon, except for its endpoints.

One of the most basic operations of computational geometry involves dividing a simple polygon into triangles by adding nonintersecting diagonals. This process is called triangulation.

A simple polygon with n sides, where n is an integer with n >= 3, can be triangulated into n-2 triangles.

Every simple polygon with at least four sides has an interior diagnoal.

### 3. Recursive Definitions and Structural Induction

However, it may be easy to define this object in terms of itself. This process is called **recursion**.

To prove results about recursively defined sets we use a method called **structural induction**.

We use two steps to define a function with the set of nonnegative integers as its domain. Such a definition is called a **recursive** or **inductive definition**.

> BASIS STEP: Specify the value of the function at zero.
>
> RECURSIVE STEP: Give a rule for finding its value at an integer from its values at smaller integers.

Recursively defined functions are well defined. That is, for every positive integer, the value of the function at this integer is determined in an unambiguous way.

LAMÉ’S THEOREM 다시 읽어보기. 피보나치와 연결되어있음.

Just as in the recursive definition of functions, recursive definitions of sets have two parts, a **basis step** and a **recursive step**.

> The set SIGMA\* of strings over the alphabet SIGMA is defined recursively by
>
> BASIS STEP: λ ∈ SIGMA\∗ (where λ is the empty string containing no symbols).
>
> RECURSIVE STEP: If w ∈ SIGMA\∗ and x∈SIGMA,then wx ∈ SIGMA\∗.

Two strings can be combined via the operation of concatenation. Let " be a set of symbols and "∗ the set of strings formed from symbols in ". We can define the concatenation of two strings, denoted by ·, recursively as follows.

> BASIS STEP: If w ∈ SIGMA∗,then w·λ = w, where λ is the empty string.
>
> RECURSIVE STEP: If w1 ∈ SIGMA∗ and w2 ∈ SIGMA∗ and x ∈SIGMA, then w1 ·(w2x)=(w1 · w2)x.

\∗ denotes multiplication and ↑ denotes exponentiation

The set of rooted trees, where a rooted tree consists of a set of vertices containing a distin- guished vertex called the root, and edges connecting these vertices, can be defined recursively by these steps:

> BASIS STEP: A single vertex r is a rooted tree.
>
> RECURSIVE STEP: Suppose that T1, T2, . . . , Tn are disjoint rooted trees with roots r1, r2, . . . , rn, respectively. Then the graph formed by starting with a root r, which is not in any of the rooted trees T1, T2, . . . , Tn, and adding an edge from r to each of the vertices r1,r2,...,rn, is also a rooted tree.

The set of extended binary trees can be defined recursively by these steps:

> BASIS STEP: The empty set is an extended binary tree.
>
> RECURSIVE STEP: If T1 and T2 are disjoint extended binary trees, there is an extended binary tree, denoted by T1 · T2, consisting of a root r together with edges connecting the root to each of the roots of the left subtree T1 and the right subtree T2 when these trees are nonempty.

The set of full binary trees can be defined recursively by these steps:

> BASIS STEP: There is a full binary tree consisting only of a single vertex r.
>
> RECURSIVE STEP: If T1 and T2 are disjoint full binary trees, there is a full binary tree, denoted by T1 · T2, consisting of a root r together with edges connecting the root to each of the roots of the left subtree T1 and the right subtree T2.

Difference between this recursive definition and that of extended binary trees lies entirely in the basis step.

### 4. Recursive Algorithms

## 6. Counting

6.1-5

### 1. The Basics of Counting

### 2. The Pigeonhole Principle

### 3. Permutations and Combinations

### 4. Binomial Coefficients and Identities

### 5. Generalized Permutations and Combinations

**여기까지 중간2**

7.1-4

### 1. An Introduction to Discrete Probability

### 2. Probability Theory

### 3. Bayes' Theorem

### 4. Expected Value and Variance

## 8. Advanced Counting Techniques

8.1,2,3,5,6

## 9. Relations

9.1,3,5,6

## 10. Graphs

10.1,2,3,4

### 수업 메모

https://en.wikipedia.org/wiki/Randomized_algorithm

스도쿠에 오타 하나 있음.

https://en.wikipedia.org/wiki/Graph_cuts_in_computer_vision

https://en.wikipedia.org/wiki/PageRank
