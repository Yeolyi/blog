
## Living Clojure

Living Clojure by Carin Meier. Copyright © 2015 Carin Meier. All rights reserved. Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.

[GitHub](https://github.com/gigasquid/wonderland-clojure-katas)

## Preface

> We will be concentrating on the major aspects of the language, not the minutaie, with the goal being to learn how to _think_ closure.

Clojure runs on the Java virtual machine(JVM).

```clj
42
;; -> 42
```

## 1. A Guided Tour of Clojure

It is designed to get you up and running with a rounded undertstanding of the language, project setup, and useful libraries.

### 1. The Structure of Clojure

클로저 코드는 표현식으로 구성되어있으며 평가 후 결과를 반환한다. 가장 간단한 표현식은 그 자신으로 평가되며 simple values/literal로 불린다.

```clj
(println 1/3) ; 1/3
(println 4/2) ; 2
; (println 4.0/2) Invalid number: 4.0/2

(println (/ 1 3)) ; 1/3
(println (/ 1.0 3)) ; 0.3333...

(println "JAM") ; JAM

; Clojure에서 키워드는 symbolic identifier이다. 
; 아주 유용하게 사용됨. 단순 값. 
(println :jam) ; :jam

; character
(println \j) ; j

; boolean
(println true false) ; true false
; 그나저나 쉼표 유무는 상관 없는 듯?
(println true, false) ; true false

; nil 
(println nil)

(println (+ 1 1)) ; 2
(println (+ 1 ( + 8 3))) ; 12
```

클로저에서는 함수나 연산자가 패러미터보다 먼저 등장한다.

Clojure collection에는 list, vector, map, set이 있다.

```clj
; List
(println '(1 2 "A" :B))
; 쉼표는 무시되고 공백과 같이 처리된다.
; 클로저에서는 코드 스타일의 맥락에서 idiomatic이란 단어가 자주 사용된다. 
; 'You can use commas, but it is idiomatic not to.'

(println (first '(:a :b :c :d))) ; :a
(println (rest '(:a :b :c :d))) ; (:b :c :d)
(println (first (rest '(:a :b :c :d)))) ; :b

(println (first '())) ; nil

; 첫번째 인자는 추가하고자 하는 요소, 두번째는 리스트
(println (cons 5 '())) ; (5)
; 리스트의 끝은 nil로 specified되므로 아래도 된다.
(println (cons 5 nil)) ; (5)
(println (cons 1 '(2))) ; (1 2)
; (println (cons '(2) 1)) IllegalArgumentException


; Vector
; Collecting Data by Index
(println [1 2 3 4 5]) ; [1 2 3 4 5]
; 리스트와 달리 fast index access 가능
(println (nth [1 2 3 4 5] 3)) ; 4
(println (nth '(1 2 3 4 5) 3)) ; 4
; 되지만 vector에서 더 성능이 좋다. 리스트에서는 첫번째 인덱스부터 탐색한다

(println (count [1 2 3])) ; 3

; conj 함수는 가장 자연스러운 위치에 원소를 삽입한다.
(println (conj '(1 2) 3)) ; (3 1 2)
; 정황상 list는 연결리스트인 것 같기도?
(println (conj [1 2] 3)) ; [1 2 3]


; Map
(println {:jam1 "strawberry" :jam2 "blackberry"})
; Maps are the on place that it can be idiomatic to leave the commas in for readability.
(println {:jam1 "strawberry", :jam2 "blackberry"})

(println (get {:jam1 "strawberry", :jam2 "blackberry"} :jam3)) ; nil
(println (get {:jam1 "strawberry", :jam2 "blackberry"} :jam3 "not found")) ; not found

; 키를 함수로써 사용할 수 있다.
; 키워드는 맵의 키로써 가장 많이 사용된다. 
(println (:jam1 {:jam1 "strawberry", :jam2 "blackberry"})) ; strawberry

(println (keys {:jam1 "strawberry", :jam2 "blackberry"})); ; (:jam1 :jam2)
(println (vals {:jam1 "strawberry", :jam2 "blackberry"})); ; (:jam1 :jam2)

(println (assoc {:jam1 "red" :jam2 "black"} :jam1 "orange")); 
(println (dissoc {:jam1 "red" :jam2 "black"} :jam1 "orange")); 
(println (merge {:jam1 "red" :jam2 "black"} {:jam1 "orange"})); 

; Set
(println #{:red :blue :white :pink})
; (println #{:red :blue :white :pink :pink}) Duplicate key: pink

(require 'clojure.set) ; 책에는 왜 이거 없냐
(println (clojure.set/union #{:r :b :w} #{:w :p :y}))
(println (clojure.set/difference #{:r :b :w} #{:w :p :y}))
(println (clojure.set/intersection #{:r :b :w} #{:w :p :y}))

(println (set [:a :b :c]))
(println (get (set {:a 1 :b 2 :c 3}) [:a 1]))
(println (contains? #{:a :b :c} :a)) ; true

; conj와 disj가 동일하게 작동
```

모든 collection은 immutable하고 persistent하다. 전자는 불변성이고, 후자는 각 collection이 structural sharing을 사용해 새로운 버전의 스스로를 smart creation한다는 것이다.

Lists are actually at the heart of Clojure.

Clojure의 기본 구조는 LISP(LISt Processing)에서 왔고, LISP에서 표현식의 첫 요소는 연산자 혹은 함수로 간주된다. 따라서 Clojure에서 리스트는 `(어쩌구)로 표현된다. 없으면 문자열을 함수로 실행시키려고 함.

> ‘All Clojure code is made of lists of data.’

```clj
; def allows us to give something a name
(def developer "Alice")
(println developer) ; Alice

; 콘솔에서 실행시키면 아래처럼 user 네임스페이스가 있음
; Created a var object in the default namespace of our REPL called user
; (def developer "Alice")
; -> #'user/developer’
; user/devloper
; -> "Alice"


; let은 자신이 속한 context에서만 유효한 심벌에 값을 바인딩한다. 
(
  let [a "a" b "b"]
  (println a b)
)
; (print a b) 없음

; defn
(defn follow-the-rabbit [] "Off we go!")
(println  (follow-the-rabbit))

(defn shop-for-jams [jam1 jam2]
  {:name "jam-basket"
   :jam1 jam1
   :jam2 jam2
  }
)
(println (shop-for-jams "strawberry" "marmalade"))

; 괄호 두 개여야 invoke
(println ((fn [] (str "Off we go" "!"))))

; 사실 defn은 fn로 만든 익명 함수에 def한 것과 같다.

; 익명 함수 shorthand
(println (#(str "Off we go" "!")))
(println (#(str "Off we go" "!" "-" %) "again"))
(println (#(str "Off we go" "!" "-" %1 %2) "again" " again!!"))
```

OOP에서는 객체로 정리하지만 클로저에서는 네임스페이스를 활용한다.

```clj
(println (ns alice.favfoods)) ; nil
; (println ns alice.favfoods) ; 이러면 터짐
;이후의 def는 해당 이름 공간에 할당된다.

; REPL에서 *ns*로 현재 네임스페이스 알 수 있음
; 별표는 earmuff로 used as a convention for things that are intended for rebinding

(def fav-food "strawberry jam")
(println fav-food)

(ns rabbit.favfoods)

(def fav-food "lettuce soup")
(println fav-food)
(println alice.favfoods/fav-food)

; 클로저 libs도 이를 적극 활용 중
; REPL이 실행될 때 auto-required되지만 아니면 아래 구문으로 require
; (require 'clojure.set)

(ns wonderland)
(require '[alice.favfoods :as af])
(println af/fav-food) ; strawberry jam

(ns wonderland (:require [alice.favfoods :as af])) ; ?????

; Most Clojure code will use libs with a require and specify an alias using :as

; :refer :all은 추천하지 않는다니 공부 생략
```
