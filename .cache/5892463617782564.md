
## Foundations

### About Next.js

Next.js is a flexible React framework that gives you building blocks to create fast web applications.

React is a JavaScript library for building interactive user interfaces. By library, we mean React provides helpful functions to build UI, but leaves it up to the developer where to use those functions in their application. 리액트의 성공은 다른 부분의 구성에 대해 상대적으로 unopinionated했기 때문이다.

Next.js is a React framework that gives you building blocks to create web applications. By framework, we mean Next.js handles the tooling and configuration needed for React, and provides additional structure, features, and optimizations for your application.

UI를 리액트로 만들고 routing, data fetching과 같은 다른 문제들을 해결해준다.

### From JavaScript to React

HTML로부터 DOM을 구성한다. The DOM is an object representation of the HTML elements. It acts as a bridge between your code and the user interface, and has a tree-like structure with parent and child relationships.

```html
<html>
  <body>
    <div id="app"></div>

    <script type="text/javascript">
      // Select the div element with 'app' id
      const app = document.getElementById('app');

      // Create a new H1 element
      const header = document.createElement('h1');

      // Create a new text node for the H1 element
      const headerContent = document.createTextNode('Develop. Preview. Ship. 🚀');

      // Append the text to the H1 element
      header.appendChild(headerContent);

      // Place the H1 element inside the div
      app.appendChild(header);
    </script>
  </body>
</html>
```

HTML represents the initial page content, whereas the DOM represents the updated page content which was changed by the JavaScript code you wrote.

하지만 이대로는 번거롭다. 컴퓨터에게 how를 imperative하게 알려줘야함. What만 알려주면 컴퓨터가 알아서 해주면 안되나?? A popular declarative library that helps developers build user interfaces is React.

```html
<!-- index.html -->
<html>
  <body>
    <div id="app"></div>

    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <!-- 브라우저는 JSX를 이해하지 못해서 바벨과 같은 자스 컴파일러가 필요하다 -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- You will need to inform Babel what code to transform by changing the script type to type=text/jsx. -->
    <script type="text/jsx">
      const app = document.getElementById('app');
      ReactDOM.render(<h1>Develop. Preview. Ship. 🚀</h1>, app);
    </script>
  </body>
</html>
```

- react is the core React library.
- react-dom provides DOM-specific methods that enable you to use React with the DOM.

[Javascript Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)

### From React to Next.js

unpkg.com이 아닌 node를 사용한다.

```
npm install react react-dom next
```

없앴 수 있다 - The Babel script because Next.js has a compiler that transforms JSX into valid JavaScript browsers can understand.

html 파일도 jsx 파일로 바꿔도 됨. index.jsx 파일은 pages 폴더로 이동.

```jsx
import { useState } from 'react';

function Header({ title }) {
  return <h1>{title ? title : 'Default title'}</h1>;
}

export default function HomePage() {
  const names = ['Ada Lovelace', 'Grace Hopper', 'Margaret Hamilton'];

  const [likes, setLikes] = useState(0);

  function handleClick() {
    setLikes(likes + 1);
  }

  return (
    <div>
      <Header title="Develop. Preview. Ship. 🚀" />
      <ul>
        {names.map((name) => (
          <li key={name}>{name}</li>
        ))}
      </ul>

      <button onClick={handleClick}>Like ({likes})</button>
    </div>
  );
}
```

```json
{
  "scripts": {
    // npx는 자동으로 붙여주나보지?
    "dev": "next dev",
    "test": "echo \"Error: no test specified\" && exit 1"
  }
}
```

### How Next.js Works

In the next sections, we’ll look at what happens to your application code during these different stages:

- The environment where your code runs: Development vs. Production
- When your code runs: Build Time vs. Runtime
- Where rendering happens: Client vs. Server

개발 환경에서는 타입스크립트, ESLint와 같은 기능이 중점이고 배포 환경에서는 성능과 접근성이 중점. 배포판을 만드려면 compiled, bundled, minified, code split이 필요하다.

Next.js에는 러스트로 쓴 컴파일러와 SWC 플랫폼이 있다.

In Next.js, **compilation** happens during the development stage as you edit your code, and as part of the build step to prepare your application for production.

**Minification** is the process of removing unnecessary code formatting and comments without changing the code’s functionality. The goal is to improve the application’s performance by decreasing file sizes.

**Bundling** is the process of resolving the web of dependencies and merging (or ‘packaging’) the files (or modules) into optimized bundles for the browser, with the goal of reducing the number of requests for files when a user visits a web page.

**Code-splitting** is the process of splitting the application’s bundle into smaller chunks required by each entry point.

When you build your application, Next.js will transform your code into production-optimized files ready to be deployed to servers and consumed by users. These files include:

- HTML files for statically generated pages
- JavaScript code for rendering pages on the **server**
- JavaScript code for making pages interactive on the **client**
- CSS files

리액트 코드를 HTML로 바꾸는 과정을 렌더링이라 하고, 이는 서버와 클라이언트 어느쪽에서든 일어나게 할 수 있다. 빌드시점, 런타임 둘 다 가능하다. Next.js에서는 Server-side Rendering, Static Site Generation, Client-Side Rendering 모두 가능하다.

Server-Side Rendering and Static Site Generation are also referred to as **Pre-Rendering** because the fetching of external data and transformation of React components into HTML happens before the result is sent to the client.

useEffect 써서 데이터 불러오면 CSR로 opt to할 수 있다.

넥스트는 기본적으로 모든 페이지를 pre-render한다.

SSR에서는 각 요청마다 HTML이 서버에서 생성된다. 클라이언트에서는 HTML을 써서 빠르게 non-interactive page를 보이고 이후 리액트가 JSON과 JS를 사용해 컴포넌트가 interactive하게 만든다. 이를 **hyration**이라 한다. 넥스트에서는 getServerSideProps를 통해 SSR로 opt to할 수 있다.

Server components allow developers to keep some logic on the server and only send the result of that logic to the client.

SSG는 HTML이 서버에서 만들어지지만 런타임에 서버가 없다. HTML이 CDN에 저장됨. getStaticProps로 opt to할 수 있다.

We use the term **origin** to distinguish this server from the other places application code can be distributed to, such as **CDN servers** and **Edge servers**.

In Next.js, since pre-rendering can be done ahead of time, CDNs are well suited to store the static result of the work - making content delivery faster.

...But unlike CDNs, which store static content, some Edge servers can run small snippets of code. 캐싱과 code execution이 가능하다. By moving some work that was traditionally done client-side or server-side to the Edge, you can make your application more performant because it reduces the amount of code sent to the client, and part of the user's request does not have to go all the way back to the origin server - thus reducing latency.

[Falling Into The Pit of Success](https://blog.codinghorror.com/falling-into-the-pit-of-success/)

## Create Your First App

### Create a Next.js App

- page-based routing system (with support for dynamic routes)
- Pre-rendering(both SSG, SSR)
- Automatic code splitting
- Client-side routing with optimized prefetching
- CSS/Sass/CSS-in-JS support
- Fast Refresh
- API routes to build API endpoints with Serverless Functions??

create-next-app

### Navigate Between Pages

In Next.js, a page is a React Component exported from a file in the pages directory. Path to the file becomes the URL path.

a 태그 대신에 Link 컴포넌트를 사용한다. <Link> allows you to do client-side navigation and accepts props that give you better control over the navigation behavior.

Client-side navigation means that the page transition happens using JavaScript, which is faster than the default navigation done by the browser. Browser does not load the full page.

a로 하면 브라우저 상단에 로딩바 움직이는데 Link는 그런거 없음!

Only loading the code for the page you request also means that pages become isolated. If a certain page throws an error, the rest of the application would still work.

Furthermore, in a production build of Next.js, whenever Link components appear in the browser’s viewport, Next.js automatically prefetches the code for the linked page in the background.

If you need to link to an external page outside the Next.js app, just use an <a> tag without Link.

### Assets, Metadata, and CSS

Next.js can serve static assets, like images, under the top-level public directory. 얘네는 root of the application에서만 접근 가능??

```html
<img
  src="/images/profile.jpg"
  alt="Your Name"
/>
// 이 경우 스크린 크기별 대응, 이미지 최적화?, viewport에 진입시에만 로딩하기 등등을 알아서
해야된다.
```

Image 컴포넌트를 제공한다. Next.js also has support for Image Optimization by default. This allows for resizing, optimizing, and serving images in modern formats like WebP when the browser supports it. 암튼 좋다. CMS등에서 호스팅되어도 최적화 가능하다. on-demain로 최적화해서 빌드 시간이 늘지 않는다.

<Head> is a React Component that is built into Next.js. It allows you to modify the <head> of a page.

Third-party JavaScript refers to any scripts that are added from a third-party source. next/script is an extension of the HTML <\script> element and optimizes when additional scripts are fetched and executed.

```jsx
<Script
  src="https://connect.facebook.net/en_US/sdk.js"
  strategy="lazyOnload"
  onLoad={() => console.log(`script loaded correctly, window.FB has been populated`)}
/>
```

A global stylesheet (globals.css), and a CSS module (Home.module.css). CSS modules allow you to locally scope CSS at the component-level by automatically creating unique class names. 같은 클래스 이름을 충돌 없이 사용할 수 있다.

To use CSS Modules, the CSS file name must end with .module.css.

```jsx
import styles from './layout.module.css';

export default function Layout({ children }) {
  return <div className={styles.container}>{children}</div>;
}
```

Furthermore, Next.js’s code splitting feature works on CSS Modules as well. It ensures the minimal amount of CSS is loaded for each page.

The default export of \_app.js is a top-level React component that wraps all the pages in your application.

In Next.js, you can add global CSS files by importing them from pages/\_app.js. You cannot import global CSS anywhere else.

[Utility-first CSS](https://tailwindcss.com/docs/utility-first)

Out of the box, with no configuration, Next.js compiles CSS using PostCSS.

To customize PostCSS config, you can create a top-level file called postcss.config.js. This is useful if you're using libraries like Tailwind CSS.

> PostCSS: A tool for transforming CSS with JavaScript

### Pre-rendering and Data Fetching

one of the most important concepts in Next.js: **Pre-rendering**.

When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive. (This process is called **hydration**.)

<!-- ![Alt text](https://nextjs.org/static/images/learn/data-fetching/pre-rendering.png) -->

<!-- ![Alt text](https://nextjs.org/static/images/learn/data-fetching/no-pre-rendering.png) -->

Static Generation and Server-side Rendering. The difference is in when it generates the HTML for a page.

Importantly, Next.js lets you choose which pre-rendering form to use for each page.

데이터가 자주 바뀌거나 페이지 내용이 요청마다 바뀌면 SSR. 아님 걍 client-side JS를 써서 데이터를 업데이트할 수도 있다.

일단은 Static Generation을 배워보자.

Static Generation can be done with and without data.

Maybe you need to access the file system, fetch external API, or query your database at build time.

```jsx
export default function Home(props) { ... }

export async function getStaticProps() {
  // Get external data from the file system, API, DB, etc.
  const data = ...

  // The value of the `props` key will be
  //  passed to the `Home` component
  return {
    props: ...
  }
}
```

```jsx
export async function getStaticProps() {
  const allPostsData = getSortedPostsData();
  return {
    props: {
      allPostsData,
    },
  };
}
```

getStaticProps only runs on the **server-side**.

In production, getStaticProps runs at build time. However, this behavior can be enhanced using the fallback key returned by getStaticPaths??

getStaticProps can only be exported from a page.

To use Server-side Rendering, you need to export getServerSideProps instead of getStaticProps from your page.

```jsx
// Because getServerSideProps is called at request time, its parameter (context) contains request specific parameters.
export async function getServerSideProps(context) {
  return {
    props: {
      // props for your component
    },
  };
}
```

<!-- ![Alt text](https://nextjs.org/static/images/learn/data-fetching/client-side-rendering.png) -->

This approach(CSR) works well for user dashboard pages, for example. Because a dashboard is a private, user-specific page, SEO is not relevant, and the page doesn’t need to be pre-rendered. The data is frequently updated, which requires request-time data fetching. [useSWR](https://swr.vercel.app/ko)

### Dynamic Routes

In this lesson, we’ll talk about the case where each page path depends on external data. Next.js allows you to statically generate pages with paths that depend on external data. This enables **dynamic URLs** in Next.js.

Pages that begin with [ and end with ] are dynamic routes in Next.js.

```jsx
// pages/posts/[id].js
import Layout from '../../components/layout';

export default function Post() {
  return <Layout>...</Layout>;
}

export async function getStaticPaths() {
  // Return a list of possible value for id
  // Returns an array that looks like this:
  // [
  //   {
  //     params: {
  //       id: 'ssg-ssr'
  //     }
  //   },
  //   {
  //     params: {
  //       id: 'pre-rendering'
  //     }
  //   }
  // ]
}

export async function getStaticProps({ params }) {
  const postData = getPostData(params.id);
  return {
    props: {
      postData,
    },
  };
}
```

To render markdown content, we’ll use the remark library.

```
npm install remark remark-html
```

```jsx
const processedContent = await remark().use(html).process(matterResult.content);
const contentHtml = processedContent.toString();
```

```jsx
// title tag 추가는 요렇게
<Head>
  <title>{postData.title}</title>
</Head>
```

To format the date, we’ll use the date-fns library.

```jsx
import { parseISO, format } from 'date-fns';

export default function Date({ dateString }) {
  const date = parseISO(dateString);
  // time이라는 태그도 있구나,,
  return <time dateTime={dateString}>{format(date, 'LLLL d, yyyy')}</time>;
}
```

If fallback is false, then any paths not returned by getStaticPaths will result in a 404 page.

If fallback is true, then the behavior of getStaticProps changes:

- The paths returned from getStaticPaths will be rendered to HTML at build time.
- The paths that have not been generated at build time will not result in a 404 page. Instead, Next.js will serve a “fallback” version of the page on the first request to such a path.
- In the background, Next.js will statically generate the requested path. Subsequent requests to the same path will serve the generated page, just like other pages pre-rendered at build time??

If fallback is blocking, then new paths will be server-side rendered with getStaticProps, and cached for future requests so it only happens once per path???

Dynamic routes can be extended to catch all paths by adding three dots (...) inside the brackets. pages/posts/\[...id].js matches /posts/a, but also /posts/a/b, /posts/a/b/c and so on.

```jsx
return [
  {
    params: {
      // Statically Generates /posts/a/b/c
      id: ['a', 'b', 'c'],
    },
  },
  //...
];
```

To create a custom 404 page, create pages/404.js.

### API Routes

Next.js has support for API Routes, which let you easily create an API endpoint as a Node.js serverless function.

creating a function inside the pages/api directory that has the following format:

```jsx
// req = HTTP incoming message, res = HTTP server response
export default function handler(req, res) {
  // ...
}
```

They can be deployed as Serverless Functions (also known as Lambdas).

- req is an instance of http.IncomingMessage, plus some pre-built middlewares.
- res is an instance of http.ServerResponse, plus some helper functions.

**Do Not Fetch an API Route from getStaticProps or getStaticPaths**. A good use case for API Routes is handling form input. For example, you can create a form on your page and have it send a POST request to your API Route. You can then write code to directly save it to your database. The API Route code will not be part of your client bundle, so you can safely write server-side code.

Preview Mode??

### Deploying Your Next.js App

- Develop: We’ve written code in Next.js and used the Next.js development server running to take advantage of its hot reloading feature.
- Preview: We’ve pushed changes to a branch on GitHub, and Vercel created a preview deployment that’s available via a URL. We can share this preview URL with others for feedback. In addition to doing code reviews, you can do deployment previews.
- Ship: We’ve merged the pull request to main to ship to production.

다른 호스팅 업체에다 올리려면 npm run build를 하고 npm run start하면 Node.js server가 실행된다.

## Search Engine Optimization

검색 엔진은 Crawling, Indexing, Rendering, Ranking의 작업을 한다.

<!-- [Title](https://nextjs.org/_next/image?url=/static/images/learn/seo/googlebot.png&w=3840&q=75&dpl=dpl_39cnxyHb7GauKiJcrRXoucnG8nyk) -->

Web crawlers identify themselves using custom user-agents.

The HTTP 301 Moved Permanently redirect status response code indicates that the resource requested has been definitively moved to the destination URL. 넥스트는 308이 새 버전이고 나아서 그걸 쓴다.

```jsx
//  pages/about.js
export async function getStaticProps(context) {
  return {
    redirect: {
      destination: '/',
      permanent: true, // triggers 308
    },
  };
}

//next.config.js
module.exports = {
  async redirects() {
    return [
      {
        source: '/about',
        destination: '/',
        permanent: true, // triggers 308
      },
    ];
  },
};
```

```txt
//robots.txt

# Block all crawlers for /accounts
User-agent: *
Disallow: /accounts

# Allow all crawlers
User-agent: *
Allow: /
```

Do not name the public directory anything else. The name cannot be changed and is the only directory used to serve static assets.

A sitemap is a file where you provide information about the pages, videos, and other files on your site, and the relationships between them. Search engines like Google read this file to more intelligently crawl your site.

It's more likely your site will be dynamic. In this case, we can leverage getServerSideProps to generate an XML sitemap on-demand.

```jsx
//pages/sitemap.xml.js
const EXTERNAL_DATA_URL = 'https://jsonplaceholder.typicode.com/posts';

function generateSiteMap(posts) {
  return `<?xml version="1.0" encoding="UTF-8"?>
   <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
     <!--We manually set the two URLs we know already-->
     <url>
       <loc>https://jsonplaceholder.typicode.com</loc>
     </url>
     <url>
       <loc>https://jsonplaceholder.typicode.com/guide</loc>
     </url>
     ${posts
       .map(({ id }) => {
         return `
       <url>
           <loc>${`${EXTERNAL_DATA_URL}/${id}`}</loc>
       </url>
     `;
       })
       .join('')}
   </urlset>
 `;
}

function SiteMap() {
  // getServerSideProps will do the heavy lifting
}

// res???
export async function getServerSideProps({ res }) {
  // We make an API call to gather the URLs for our site
  const request = await fetch(EXTERNAL_DATA_URL);
  const posts = await request.json();

  // We generate the XML sitemap with the posts data
  const sitemap = generateSiteMap(posts);

  res.setHeader('Content-Type', 'text/xml');
  // we send the XML to the browser
  res.write(sitemap);
  res.end();

  return {
    props: {},
  };
}

export default SiteMap;
```

Meta robots tags orrobots.txt files are directives and will always be obeyed. Canonical tags are recommendations that Google can decide to obey or not.

```jsx
// When users search for your site, Google Search results sometimes display a search box specific to your site,
// along with other direct links to your site.
// This tag tells Google not to show the sitelinks search box.
<meta
  name="google"
  content="nositelinkssearchbox"
/>
```

To avoid duplicate tags in your head you can use the key property, which will make sure the tag is only rendered once?? 그냥 넣어도 중복 안돼야되는거 아닌가 아 child에서 명시하는 경우?

A canonical URL is the URL of the page that search engines think is most representative from a set of duplicate pages on your site.

They let Google know which URLs are the original source of truth and which are duplicated.

```html
<link
  rel="canonical"
  href="https://example.com/products/phone"
/>
```

**Incremental Static Regeneration** enables developers and content editors to use static generation on a per-page basis, without needing to rebuild the entire site. With ISR, you can retain the benefits of static while scaling to millions of pages.

CSR is perfect for data heavy dashboards, account pages or any page that you do not require to be in any search engine index.

**The most important thing for SEO is that page data and metadata is available on page load without JavaScript.**

[A Complate Guide To Incremental Static Regeneration(ISR) with Nex.js](https://www.smashingmagazine.com/2021/04/incremental-static-regeneration-nextjs/)

While Next.js offers AMP support, consider weighing the costs and benefits of having an AMP implementation in your website if it already has great Core Web Vitals scores. AMP는 후순위인듯~!

URL Structure - Semantic / Patterns that are logical and consistent / Keyword focuesd / Not parameter-based

```jsx
// pages/blog/[slug].js

// Set fallback to blocking. Now any new post added post build will SSR
// to ensure SEO. It will then be static for all subsequent requests
return { paths, fallback: 'blocking' };
```

The title tag is one of the most important SEO elements for two main reasons:

- 유저가 검색 결과에서 보고 누르는 것
- 구글이 페이지 이해할 때 주요하게 사용하는 것. 키워드 쓰면 좋다.

The description meta tag is another important SEO element, but less so than the title. According to Google, this element is not taken into account for ranking purposes, but it can affect your click-through-rate on search results.

The Open Graph protocol, originally developed by Facebook, standardizes how metadata is used on any given web page. Other social media companies (like Pinterest, Twitter, LinkedIn, etc), may also use open graph for displaying rich cards when sharing a URL.

Structured data facilitates the understanding of your pages to search engines. Over the years, there have been several vocabularies in place, but currently the main one is schema.org.

According to the website, schema.org is a "collaborative, community activity with a mission to create, maintain, and promote schemas for structured data on the Internet, on web pages, in email messages, and beyond."

```jsx
import Head from 'next/head';

function ProductPage() {
  function addProductJsonLd() {
    return {
      __html: `{
      "@context": "https://schema.org/",
      "@type": "Product",
      "name": "Executive Anvil",
      "image": [
        "https://example.com/photos/1x1/photo.jpg",
        "https://example.com/photos/4x3/photo.jpg",
        "https://example.com/photos/16x9/photo.jpg"
       ],
      "description": "Sleeker than ACME's Classic Anvil, the Executive Anvil is perfect for the business traveler looking for something to drop from a height.",
      "sku": "0446310786",
      "mpn": "925872",
      "brand": {
        "@type": "Brand",
        "name": "ACME"
      },
      "review": {
        "@type": "Review",
        "reviewRating": {
          "@type": "Rating",
          "ratingValue": "4",
          "bestRating": "5"
        },
        "author": {
          "@type": "Person",
          "name": "Fred Benson"
        }
      },
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.4",
        "reviewCount": "89"
      },
      "offers": {
        "@type": "Offer",
        "url": "https://example.com/anvil",
        "priceCurrency": "USD",
        "price": "119.99",
        "priceValidUntil": "2020-11-20",
        "itemCondition": "https://schema.org/UsedCondition",
        "availability": "https://schema.org/InStock"
      }
    }
  `,
    };
  }
  return (
    <div>
      <Head>
        <title>My Product</title>
        <meta
          name="description"
          content="Super product with free shipping."
          key="desc"
        />
        <script
          type="application/ld+json"
          dangerouslySetInnerHTML={addProductJsonLd()}
          key="product-jsonld"
        />
      </Head>
      <h1>My Product</h1>
      <p>Super product for sale.</p>
    </div>
  );
}

export default ProductPage;
```

At a high level, **on page SEO** refers to the headings and links that make up the overall structure of the page. Headings indicate importance in the document and links connect the web together.

각 페이지마다 H1태그가 있어야하고 title 태그와 유사한 내용을 담아야한다.

However, if the child of Link is a custom component that wraps an a tag, you must add passHref to Link. styled-component와 같은 라이브러리를 사용할 때 필수적이다. ESLint가 이런 실수는 막아준다!!

```jsx
import Link from 'next/link';
import styled from 'styled-components';

// This creates a custom component that wraps an <a> tag
const RedLink = styled.a`
  color: red;
`;

function NavLink({ href, name }) {
  // Must add passHref to Link
  return (
    <Link
      href={href}
      passHref
    >
      <RedLink>{name}</RedLink>
    </Link>
  );
}

export default NavLink;
```

**Web Vitals** is an initiative created by Google to provide unified guidance and metrics to measure end-user page experience on the web.

**Core Web Vitals** is a subset of Web Vitals, and currently consists of three metrics that measure loading, interactivity, and visual stability. These metrics are **Largest Contentful Paint (LCP)**, **First Input Delay (FID)**, and **Cumulative Layout Shift (CLS)**. 각각의 메트릭은 Good, Needs Improvements, Poor로 나뉜다.

**LCP** measures the time it takes to get the largest element on the page visible within the viewport.

The **FID**(First Input Delay) metric is the perception of an end user’s experience while interacting with a web page. 얘는 Google Lighthouse같은 lab에서 측정 불가능. [TBT](https://web.dev/tbt/)는 된다는데 다음에 읽어보자.

The **Cumulative Layout Shift (CLS)** metric is a measure of your site’s overall layout stabilit

Google provided [a set of specific metics and ranges](https://developers.google.com/search/blog/2021/04/more-details-page-experience) to analyze and optimize your performance.

Lighthouse - It is important to run reports in an incognito window, as third-party plugins will affect your report. Ad blocker 등등도 영향을 미칠 수 있다.

예제 돌리니까 certificate 어쩌구 에러 뜨는데?? 다시 해보니까 이미 점수가 높아서 음,,

next/image를 사용하자~ On-demand optimization, Lazy Loaded Images, Avoids CLS 등등.

ext.js supports ES2020 dynamic `import()` for JavaScript. With it, you can import JavaScript modules dynamically and work with them. They also work with server-side rendering (SSR).

```js
const Fuse = (await import('fuse.js')).default;
const _ = (await import('lodash')).default;
```

React components can also be imported using dynamic imports, but in this case we use it in conjunction with next/dynamic to make sure it works just like any other React Component.

```js
import dynamic from 'next/dynamic';
const CodeSampleModal = dynamic(() => import('../components/CodeSampleModal'), {
  ssr: false,
});
```

Next.js has built-in Automatic Webfont Optimization. By default, Next.js will automatically inline font CSS at build time, eliminating an extra round trip to fetch font declarations. This results in improvements to First Contentful Paint (FCP) and Largest Contentful Paint (LCP).

Next.js provides a built-in Script component that optimizes loading for any third-party script, while giving developers the option to decide when to fetch and execute it.

```jsx
// next/head 안에 있을 필요 없다.
<Script
  strategy="afterInteractive"
  src="https://www.googletagmanager.com/gtag/js?id=123"
/>
```

To not negatively affect Largest Contentful Paint (LCP), most third-party scripts should be deferred to load after all the contents of a page has finished loading, either immediately after the page becomes interactive (strategy="afterInteractive") or lazily during browser idle time (strategy="lazyOnload").

> Once you have optimized your site, it's important to monitor while in production so you can continue to iterate.

[Next.js Speed Insights](https://nextjs.org/analytics)

[Chrome User Experience Report](https://developers.google.com/web/tools/chrome-user-experience-report)

등등...

## Excel

- tsconfig.json file. You may customize this file.
- next-env.d.ts file, which ensures Next.js types are picked up by the TypeScript compiler. You should not touch this file.

GetStaticProps, GetStaticPaths, GetServerSideProps 타입이 있다.
