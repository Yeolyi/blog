
[Writing a Javascript Module Bundler](https://ak2316.user.srcf.net/2021/07/writing-a-module-bundler/)

A module bundler is a tool that takes pieces of JavaScript and their dependencies and bundles them into a single file, usually for use in the browser. You may have used tools such as Browserify, Webpack, Rollup or one of many others.

It usually starts with an entry file, and from there it bundles up all of the code needed for that entry file.

There are two main stages.

1. Dependency resolution
1. Packing

Let’s start out our code with some imports.

```js
const detective = require('detective');
const resolve = require('resolve').sync;
const fs = require('fs');
const path = require('path');
```

## Dependency Resolution

- The name and an identifier of the file
- Where the file came from (in the file system)
- The code in the file
- What dependencies that file needs

```js
let ID = 0;
function createModuleObject(filepath) {
  const source = fs.readFileSync(filepath, 'utf-8');
  const requires = detective(source);
  const id = ID++;

  return { id, filepath, source, requires };
}
```

Detective is a library that can “find all calls to require() no matter how deeply nested”.

```js
// 코드 실행이 필요하므로 이런건 안된다,,
const libName = 'lodash';
const lib = require(libName);
```

When you import modules in Node, you can do relative imports, like require('./utils'). How does the bundler know what is the right ./utils file when everything is packaged?

That is the problem the **module map** solves. Our module object has a unique id key which will be our ‘source of truth’.

The main purpose of this dependency resolution is to start at the root/entry module, and to **look for and resolve dependencies recursively**.

To make clear what is meant by ‘resolve dependencies’, in Node there is a function require.resolve, and that is used to figure out where the file your module is requireing is. The need for this to be an explicit process is because we can import **both relatively or from a node_modules folder**.

Luckily there’s an npm module named resolve which implements this algorithm for us. We just have to pass in the dependency and base URL arguments, and it will do all the hard work for us.

[node.js.org - modules](https://nodejs.org/api/modules.html#requireresolverequest-options). require.resolve(request[, options]) - Use the internal require() machinery to look up the location of a module, but rather than loading the module, just return the resolved filename.

```js
function getModules(entry) {
  // { id, filepath, source, requires }
  const rootModule = createModuleObject(entry);
  const modules = [rootModule];

  // Iterate over the modules, even when new
  // ones are being added
  for (const module of modules) {
    module.map = {}; // Where we will keep the module maps

    module.requires.forEach((dependency) => {
      const basedir = path.dirname(module.filepath);
      const dependencyPath = resolve(dependency, { basedir });

      const dependencyObject = createModuleObject(dependencyPath);

      module.map[dependency] = dependencyObject.id;
      modules.push(dependencyObject);
    });
  }

  return modules;
}
```

At the end of this function, we are left with an array named modules which will contain module objects for every module/dependency in our project.

## Packing

In the browser, there’s not really such thing as modules, and there’s also no require or module.exports. So even though we have all of our dependencies, we currently have no way to use them as modules.

A factory function is a function (that’s not a constructor) which returns an object. One of its uses is to do encapsulation and dependency injection, which is exactly what we want to do.

```js
// A factory function - we can replace require and module with
// our own dependency injection
(require, module) => {
  /* Module Source */
};

// For each module object obtained in the previous stage,
// we are going to going to transform it so that a factory function can be used.

// from
{
    id: 0,
    filepath: '/Users/john/app.js',
    requires: ['./log', './utils'],
    map: { './log': 1, './utils': 2 },
    source: `
        const log = require('./logging);
        const util = require('./utils);

        log('hello world!');
    `
}

// to
0: {
    factory: (module, require) => {
        const log = require('./logging');
        const util = require('./utils');

        log('hello world!');
    },
    map: { './log': 1, './utils': 2 },
}
```

The main process performed here is putting each module into a module factor function, and then doing dependency injection using the module map.

```js
function pack(modules) {
  const modulesSource = modules
    .map(
      (module) =>
        `${module.id}: {
      factory: (module, require) => {
        ${module.source}
      },
      map: ${JSON.stringify(module.map)}
    }`
    )
    .join();

  return `(modules => {
    const require = id => {
      const { factory, map } = modules[id]
      const localRequire = name => require(map[name])
      const module = { exports: {} }
      factory(module, localRequire)
      return module.exports
    }
    require(0)
  })({ ${modulesSource} })`;
}
```

The final output is an IIFE(Immediately Invoked Function Expression), which means that if you run that code in the browser (or anywhere else), the function will be run immediately. The IFFE is also a good way to encapsulate scope, so that we don’t pollute everything with all of our modules.

This probably shouldn’t be used in production, because it’s missing loads of features (like managing circular dependencies, making sure each file gets only parsed once, es-modules, and so on) but this has hopefully given you a good idea of how module bundlers actually work.

로컬 파일 require는 ./를 붙여야됐었나,,? 맞다면 그 이유를 알 듯.

```js
const bundle = require('./index');
const entry = __dirname + '/entry.js';

console.log(bundle(entry));

// 결과
((modules) => {
  const require = (id) => {
    const { factory, map } = modules[id];
    const localRequire = (name) => require(map[name]);
    const module = { exports: {} };

    factory(module, localRequire);

    return module.exports;
  };

  require(0);
})({
  0: {
    factory: (module, require) => {
      const { f } = require('./samples/folder/3.js');
      require('./samples/1.js');
      f();
    },
    map: { './samples/folder/3.js': 1, './samples/1.js': 2 },
  },
  1: {
    factory: (module, require) => {
      console.log('3');

      module.exports = {
        f: () => console.log('function from 3.js'),
      };
    },
    map: {},
  },
  2: {
    factory: (module, require) => {
      require('./2.js');
      console.log('1');
    },
    map: { './2.js': 3 },
  },
  3: {
    factory: (module, require) => {
      const { f } = require('./folder/3.js');
      console.log('2');
      f();
    },
    map: { './folder/3.js': 4 },
  },
  4: {
    factory: (module, require) => {
      console.log('3');

      module.exports = {
        f: () => console.log('function from 3.js'),
      };
    },
    map: {},
  },
});
```
