
[Modern JavaScript for Dinosaurs](https://peterxjang.com/blog/modern-javascript-explained-for-dinosaurs.html).

## tldr

We went from plain HTML and JS to using a **package manager** to automatically download 3rd party packages, a **module bundler** to create a single script file, a **transpiler** to use future JavaScript features, and a **task runner** to automate different parts of the build process.

## Content

The goal of this article is to provide a historical context of how JavaScript tools have evolved to what they are today in 2017.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>JavaScript Example</title>
    <script src="moment.min.js"></script>
    <script src="index.js"></script>
  </head>
  <body>
    <h1>Hello from HTML!</h1>
  </body>
</html>
```

```js
console.log('Hello from JavaScript!');
moment().startOf('day').fromNow();
```

We can add moment.js to our website by downloading the moment.min.js file in the same directory and including it in our index.html file.

The bad thing was that it was annoying to find and download new versions of libraries every time they would update.

Several competing JavaScript package managers emerged to help automate the process of downloading and upgrading libraries from a central repository.

Note that npm was originally a package manager made specifically for node.js, a JavaScript runtime designed to run on the server, not the frontend. _So that makes it a pretty weird choice for a frontend JavaScript package manager for libraries meant to run in a browser._

To install the moment.js JavaScript package, we can now follow the npm instructions...

```
npm install moment --save
```

This command downloads all the code from the moment.js pacakge into a folder called node_moudle, and it automatically modifies the package.json file to keep track of moment.js as a project dependency. This is useful later when sharing a project with others.

This means we can link to the npm downloaded version of moment.min.js in the index.html file as follows:

```html
<script src="node_modules/moment/min/moment.min.js"></script>
```

The bad thing is right now we’re digging through the node_modules folder to find the location of each package and manually including it in our HTML.

> These days people use npm as a frontend package manager.
>
> Q. How can JS in the browser properly use JS modules designed for node? 그러게,,,?

Most programming languages provide a way to import code from one file into another. JavaScript **wasn’t originally designed with this feature**, because JavaScript was designed to only run in the browser, with no access to the file system of the client’s computer (for security reasons).

In 2009, a project named CommonJS was started with the goal of specifying an ecosystem for JavaScript outside the browser. A big part of CommonJS was its specification for modules, which would finally allow JavaScript to import and export code across files like most programming languages, without resorting to global variables. The most well-known of implementation of CommonJS modules is node.js.

Instead of loading all of moment.min.js with an HTML script tag, you can load it directly in the JavaScript file as follows:

```js
// index.js
var moment = require('moment');
console.log('Hello from JavaScript!');
console.log(moment().startOf('day').fromNow());
```

Node.js also knows the location of each npm module path.

But if you tried to use the above code in the browser, you’d get an error saying require is not defined. The browser doesn’t have access to the file system.

This is where a **module bundler** comes in. A JavaScript module bundler is a tool that gets around the problem with a build step (which has access to the file system) to create a final output that is browser compatible (which doesn’t need access to the file system). In this case, we need a module bundler to find all require statements (which is invalid browser JavaScript syntax) and replace them with the actual contents of each required file. The final result is a single bundled JavaScript file (with no require statements)!

2011 Browserify, 2015 webpack.

**Transpiling code** means converting the code in one language to code in another similar language. Important part of frontend since browsers are slow to add compatible langauges.

The most popular transpiler for a while was CoffeeScript(2010), whereas nowadays most people use babel or TypeScript.

Babel is a transpiler that transpiles next generation JavaScript with features not yet available to all browsers to older more compatible JavaScript.

After setting up Babel, we can use the ES2015 import statement instead of require for loading modules, which is what you’ll see in a lot of codebases today.

Task runner is a tool that automates different parts of the build process. For frontend development, tasks include minifying code, optimizing images, running tests, etc.

Nowadays the most popular choice seems to be using the scripting capabilities built into the npm package manager itself.

```html
<!DOCTYPE html>
<html>
  <head>
    <title>ES Modules in Browser</title>
  </head>
  <body>
    <script
      type="module"
      src="main.js"
    ></script>
  </body>
</html>
```

```js
// Exporting a variable from the module
export const message = 'Hello, ES modules in the browser!';

// Exporting a function from the module
export function showMessage() {
  console.log(message);
}
```

```js
// Importing the "message" variable and the "showMessage" function from the "app.js" module
import { message, showMessage } from './app.js';

console.log(message); // Output: "Hello, ES modules in the browser!"
showMessage(); // Output: "Hello, ES modules in the browser!"
```

To get this behavior, you specify that your script is a module by using type="module".

https://stackoverflow.com/questions/36523013/how-will-browsers-handle-es6-import-export-syntax

Apart from providing a consistent tooling environment that saves you from the pain of dependencies, many popular module bundlers also come with performance optimization features. Code splitting and hot module replacement are examples of these functionalities.

```html
<!DOCTYPE html>
<html>
  <body></body>
  <script>
    let a = 10;
  </script>
  <script>
    console.log(a); // 10
  </script>
</html>
```

Since the variable a is declared in the global scope (within the HTML document), it is accessible to both script blocks, and thus, the second script block can access and log the value of a, which is 10?? - GPT

- A module is a piece of code that is executed once it is loaded. It means that if a module is not included in the main bundle, it will not be evaluated
- Modules are singletons. If a module is imported multiple times, only a single instance of it exists and it is evaluated only once at load

https://stackoverflow.com/questions/36564901/in-the-import-syntax-of-es6-how-is-a-module-evaluated-exactly

Maintained는 아닌데 브라우저가 ESM 지원해서 [Snowpack](https://www.snowpack.dev/posts/2020-05-26-snowpack-2-0-release/)같은 것도 생기는 듯.
