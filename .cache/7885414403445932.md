
In this chapter, you’ll learn the escape hatches that let you “step outside” React and connect to external systems. Most of your application logic and data flow should not rely on these features.

## Referencing Values with Refs

> When you want a component to “remember” some information, but you don’t want that information to trigger new renders, you can use a ref.

ref.current property is intentionally mutable.

When a piece of information is only needed by event handlers and changing it doesn’t require a re-render, using a ref may be more efficient.

```jsx
// You shouldn’t read (or write) the current value during rendering.
// 컴포넌트가 pure function이어야하는 것과 비슷한 맥락인듯.
<button onClick={handleClick}>You clicked {countRef.current} times</button>
```

```jsx
function useRef(initialValue) {
  const [ref, unused] = useState({ current: initialValue });
  return ref;
}
```

Treat refs as an escape hatch. Don’t read or write ref.current during rendering. useEffect 내에서만하라는 뜻인가?? <- event handler 내에서도 괜찮은듯

사용례로는 storing timeout IDs, DOM elements(다음 페이지), JSX에 필수적이지 않은 기타 객체들.

렌더링중에 사용하지 말기. The only exception to this is code like if (!ref.current) ref.current = new Thing() which only sets the ref once during the first render.

The most common use case for a ref is to access a DOM element.

## Manipulating the DOM with Refs

Sometimes you might need access to the DOM elements managed by React—for example, to focus a node, scroll to it, or measure its size and position. There is no built-in way to do those things in React, so you will need a ref to the DOM node.

```jsx
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

You can then access this DOM node from your event handlers and use the built-in browser APIs defined on it.

[Element.scrollIntoView](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView)

How to manage a list of refs using a ref callback - ...pass a function to the ref attribute. This is called a “ref callback”. React will call your ref callback with the DOM node when it’s time to set the ref, and with null when it’s time to clear it.

```jsx
<li
    key={cat.id}
    ref={(node) => {
    const map = getMap();
    if (node) {
        map.set(cat.id, node);
    } else {
        map.delete(cat.id);
    }
    }}
>
```

By default React does not let a component access the DOM nodes of other components.

```jsx
const MyInput = forwardRef((props, ref) => {
  return (
    <input
      {...props}
      ref={ref}
    />
  );
});
```

In design systems, it is a common pattern for low-level components like buttons, inputs, and so on, to forward their refs to their DOM nodes.

```jsx
// Exposing a subset of the API with an imperative handle
// In this case, the ref “handle” is not the DOM node, but the custom object you create inside useImperativeHandle call.
import { forwardRef, useRef, useImperativeHandle } from 'react';

const MyInput = forwardRef((props, ref) => {
  const realInputRef = useRef(null);
  useImperativeHandle(ref, () => ({
    // Only expose focus and nothing else
    focus() {
      realInputRef.current.focus();
    },
  }));
  return (
    <input
      {...props}
      ref={realInputRef}
    />
  );
});
```

In React, every update is split in two phases:

During render, React calls your components to figure out what should be on the screen. During commit, React applies changes to the DOM. 렌더링중에는 일반적으로 ref에 접근하지 말자. 그때는 아직 최신값이 아닐 수도 있음.

React sets ref.current during the commit. Usually, you will access refs from event handlers.

You can force React to update (“flush”) the DOM synchronously. To do this, import flushSync from react-dom and wrap the state update into a flushSync call:

```jsx
flushSync(() => {
  setTodos([...todos, newTodo]);
});
listRef.current.lastChild.scrollIntoView();
// 문서 보니까 권장하지는 않는듯?
```

...include managing focus, scroll position, or calling browser APIs that React does not expose.

포커싱이나 스크롤링같은 비파괴적인 작업은 ㄱㅊ. 하지만 Avoid changing DOM nodes managed by React. Modifying, adding children to, or removing children from elements that are managed by React can lead to inconsistent visual results or crashes like above.

## Synchronizing with Effects

> Effects let you run some code after rendering so that you can synchronize your component with some system outside of React.

리액트 컴포넌트에는 두 종류의 로직이 있다.

- Rendering code(must be pure)
- Event handlers(contain side effects)

> Effects let you specify side effects that are caused by rendering itself, rather than by a particular event.

browser APIs, third-party widgets, network...

Effects run at the end of a commit after the screen updates.

```jsx
// You need to synchronize the value of isPlaying prop, which tells whether the video should currently be playing, with calls like play() and pause().
function VideoPlayer({ src, isPlaying }) {
  // TODO: do something with isPlaying
  return <video src={src} />;
}
```

Notice that you can’t “choose” your dependencies. React compares the dependency values using the Object.is comparison.

ref object has a stable identity. The set functions returned by useState also have stable identity.

In development React remounts every component once immediately after its initial mount.

```jsx
// Controlling non-React widgets
useEffect(() => {
  const map = mapRef.current;
  map.setZoomLevel(zoomLevel);
}, [zoomLevel]);

// Subscribing to events
useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

> Inbetweening, also known as tweening, is a process in animation that involves creating intermediate frames, called inbetweens, between two keyframes.

> In animation and filmmaking, a key frame (or keyframe) is a drawing or shot that defines the starting and ending points of a smooth transition.

```jsx
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);

//  If the second request in development is bothering you, the best approach is to use a solution that deduplicates requests and caches their responses between components:
const todos = useSomeDataLibrary(`/api/user/${userId}/todos`);
```

Writing fetch calls inside Effects is a very manual approach and it has significant downsides.

- Effects don't run on the server. 클라이언트가 js파일 다 받고 앱을 렌더링해야 데이터 로딩이 필요하다는 것을 알 수 있다.
- Fetching directly in Effects makes it easy to create "network waterfalls"
- Fetching directly in Effects means you don't preload or cache data.
- It's not very ergonomic. [Race conditions fetching data react with useEffect](https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect).

따라서 If you use a framework, use its built-in data fetching mechanism.

Some logic should only run once when the application starts. You can put it outside your components:

```jsx
if (typeof window !== 'undefined') {
  // Check if we're running in the browser.
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

디버깅 모드에서의 remounting이 로직을 고장낸다면 아마 버그가 있다는 것이다.

React always cleans up the previous render’s Effect before the next render’s Effect.

Each Effect “captures” the text value from its corresponding render.

... Additionally, React will remount the Effects whenever you save a file in development. Both of these behaviors are development-only.

## You Might Not Need an Effect

Effect는 외부 시스템과의 synchronize를 위해서 사용되어야 한다.

- You don’t need Effects to transform data for rendering. 컴포넌트 top level에서 하자.
- You don’t need Effects to handle user events. event handler에서 어떤 상황인지 정확히 알 수 있으니 거기서 처리하자.

### Updating state based on props or state

**When something can be calculated from the existing props or state, don’t put it in state. Instead, calculate it during rendering.**

### Caching expensive calculations

useMemo 훅으로 비용이 큰 계산을 캐싱할 수 있다. If the overall logged time adds up to a significant amount (say, 1ms or more), it might make sense to memoize that calculation.

```jsx
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  const visibleTodos = useMemo(() => {
    // ✅ Does not re-run unless todos or filter change
    return getFilteredTodos(todos, filter);
  }, [todos, filter]);
  // ...
}
```

### Resetting all state when a prop changes

그냥 키 값을 바꾸자.

### Adjusting some state when a prop changes

```jsx
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // Better: Adjust the state while rendering
  const [prevItems, setPrevItems] = useState(items);
  if (items !== prevItems) {
    setPrevItems(items);
    setSelection(null);
  }
  // ...
  // React will re-render the List immediately after it exits with a return statement.
  //  This lets the List children skip rendering the stale selection value.
}
```

When you update a component during rendering, React throws away the returned JSX and immediately retries rendering. To avoid very slow cascading retries, React only lets you update the same component’s state during a render. You may adjust state like this, but any other side effects (like changing the DOM or setting timeouts) should stay in event handlers or Effects to keep components pure.

**Although this pattern is more efficient than an Effect, most components shouldn’t need it either.** Always check whether you can reset all state with a key or calculate everything during rendering instead.

```jsx
// Now there is no need to “adjust” the state at all.
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selectedId, setSelectedId] = useState(null);
  // ✅ Best: Calculate everything during rendering
  const selection = items.find((item) => item.id === selectedId) ?? null;
  // ...
}
```

### Sharing logic between event handlers

When you’re not sure whether some code should be in an Effect or in an event handler, ask yourself why this code needs to run. **Use Effects only for code that should run because the component was displayed to the user.**

### Sending a POST request.

If this logic is caused by a particular interaction, keep it in the event handler. If it’s caused by the user seeing the component on the screen, keep it in the Effect.

### Chains of computation

Avoid chains of Effects that adjust the state solely to trigger each other. In this case, it’s better to calculate what you can during rendering, and adjust the state in the event handler.

### Initializing the application

If some logic must run once per app load rather than once per component mount, add a top-level variable to track whether it has already executed:

```jsx
let didInit = false;

function App() {
  useEffect(() => {
    if (!didInit) {
      didInit = true;
      // ✅ Only runs once per app load
      loadDataFromLocalStorage();
      checkAuthToken();
    }
  }, []);
  // ...
}
```

Code at the top level runs once when your component is imported—even if it doesn’t end up being rendered. To avoid slowdown or surprising behavior when importing arbitrary components, don’t overuse this pattern.

### Notifying parent components about state changes.

Whenever you try to keep two different state variables synchronized, try lifting state up instead!

### Passing data to the parent

Since both the child and the parent need the same data, let the parent component fetch that data, and pass it down to the child instead:

### Subscribing to an external store

React has a purpose-built Hook for subscribing to an external store that is preferred instead. Delete the Effect and replace it with a call to **useSyncExternalStore**.

```jsx
function subscribe(callback) {
  window.addEventListener('online', callback);
  window.addEventListener('offline', callback);
  return () => {
    window.removeEventListener('online', callback);
    window.removeEventListener('offline', callback);
  };
}

function useOnlineStatus() {
  // ✅ Good: Subscribing to an external store with a built-in Hook
  return useSyncExternalStore(
    subscribe, // React won't resubscribe for as long as you pass the same function
    () => navigator.onLine, // How to get the value on the client
    () => true // How to get the value on the server
  );
}

function ChatIndicator() {
  const isOnline = useOnlineStatus();
  // ...
}
```

### Fetching data

...These issues apply to any UI library, not just React. Solving them is not trivial, which is why modern frameworks provide more efficient built-in data fetching mechanisms than fetching data in Effects.

> In general, whenever you have to resort to writing Effects, keep an eye out for when you can extract a piece of functionality into a custom Hook with a more declarative and purpose-built API like useData above.

## Lifecycle of Reactive Effects

Effects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it.

It’s a good way to think about components, but not about Effects. 컴포넌트와 efect는 분리해서 생각하기.

컴포넌트가 마운트되고 언마운트될 때만 effect가 연관된 것이 아니다. Sometimes, it may also be necessary to start and stop synchronizing multiple times while the component remains mounted.

When you looked from the component’s perspective, it was tempting to think of Effects as “callbacks” or “lifecycle events” that fire at a specific time like “after a render” or “before unmount”.

**Instead, always focus on a single start/stop cycle at a time. It shouldn’t matter whether a component is mounting, updating, or unmounting. All you need to do is to describe how to start synchronization and how to stop it. If you do it well, your Effect will be resilient to being started and stopped as many times as it’s needed.**

Re-synchronize덕분에 코드 수정 후 적용도 매끄럽게 되는 듯?

Each Effect in your code should represent a separate and independent synchronization process.

**Props, state, and other values declared inside the component are reactive because they’re calculated during rendering and participate in the React data flow.** All variables declared in the component body are reactive.

The ref object returned by useRef itself can be a dependency.

Effects “react” to all values from the component body.

Mutable values (including global variables) aren’t reactive. useState로 만든 객체는??

ref.current는 changing it doesn’t trigger a re-render, it’s not a reactive value, and React won’t know to re-run your Effect when it changes. Reactive하다는거는 뷰의 상태에 따라가는 값이라는건가?

**Effects are reactive blocks of code.**

Effects are not a tool for code reuse.

### Separating Events from Effects

...an Effect that re-runs in response to some values but not others. This page will teach you how to do that.

**Props, state, and variables declared inside your component’s body are called reactive values.** Reactive values like these can change due to a re-render.

Logic inside event handlers is not reactive, logic inside Effects is reactive.

useEffectEvent를 쓰면 되는데,,, experiment API라고 해서 생략.

### Removing Effect Dependencies

**If you want to change the dependencies, change the surrounding code first.**

**We recommend treating the dependency lint error as a compilation error.**

여기도 useEffectEvent 얘기 나옴.

**Object and function dependencies can make your Effect re-synchronize more often than you need.**

```jsx
/// useMemo말고 이런 방법도 있네
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId,
    };
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ✅ All dependencies declared
  // ...
}
```

아래는 부모 컴포넌트에서 건네주는 경우.

```jsx
function ChatRoom({ options }) {
  const [message, setMessage] = useState('');

  const { roomId, serverUrl } = options;
  useEffect(() => {
    const connection = createConnection({
      roomId: roomId,
      serverUrl: serverUrl,
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]); // ✅ All dependencies declared
  // ...
}
```

## Reusing Logic with Custom Hooks

...**More importantly, the code inside them describes what they want to do (use the online status!) rather than how to do it (by subscribing to the browser events).**

- React component names must start with a capital letter.
- Hook names must start with use followed by a capital letter.

use로 시작하기에 state인지 아닌지 알 수 있다.

In principle, you could make a Hook that doesn’t call other Hooks. This is often confusing and limiting so it’s best to avoid that pattern.

**Custom Hooks let you share stateful logic but not state itself. Each call to a Hook is completely independent from every other call to the same Hook.**

Custom Hooks need to be pure.

여기도 useEffectEvent 나옴.

**Keep custom Hooks focused on concrete high-level use cases.** Avoid creating and using custom “lifecycle” Hooks that act as alternatives and convenience wrappers for the useEffect API itself.

**Custom “lifecycle” Hooks like useMount don’t fit well into the React paradigm.** 이 경우는 린터도 문제를 감지할 수 없다.

**A good custom Hook makes the calling code more declarative by constraining what it does.**

With time, the React team’s goal is to reduce the number of the Effects in your app to the minimum by providing more specific solutions to more specific problems.

The more coordination between Effects is needed (for example, to chain multiple animations), the more it makes sense to extract that logic out of Effects and Hooks completely like in the sandbox above. Then, the code you extracted becomes the “external system”. This lets your Effects stay simple because they only need to send messages to the system you’ve moved outside React.

The code of your custom Hooks should be pure, like your component’s code.
