
[GitHub](https://github.com/facebook/react-devtools)

## 1. Welcome to React

[React blog](https://reactjs.org/blog)

[React Developer Tools](https://github.com/facebook/react-devtools)

React itself is an example of a useful npm library.

_package.json_ describies the project and all its dependencies.

Yarn was released in 2016 by Facebook in collaboration with Exponent, Google, and Tilde.

## 2. JavaScript for React

> DHTML(Dynamic HTML; 동적 HTML)은 정적 마크업 언어인 HTML과 클라이언트 기반 스크립트 언어(자바스크립트 같은) 그리고 스타일 정의 언어인 CSS를 조합하여 대화형웹 사이트를 제작하는 기법을 의미한다. 경쟁 기술로는 애니메이션을 위한 어도비플래시나 자바, AJAX, 애플릿, SVG 등이 있다(SVG는 아직까지 주요웹 브라우저에서잘지원되지 않는다).

[AJAX what is it? (it’s not DHTML)](https://derivadow.com/2007/01/05/ajax-what-is-it-its-not-dhtml/)

[kangax compatibility table](http://kangax.github.io/compat-table/esnext/)

Function declarations are hoisted and function expression are not.

화살표가 리턴 값을 바로 가리키면 return을 생략할 수 있다.

화살표 함수에서 객체를 반환하려면 중괄호를 소괄호로 묶어야한다!

[Babel REPL](https://babeljs.io/repl)

```js
const sandwich = {
  bread: 'dutch crunch',
  meat: 'tuna',
};
const { bread, meat } = sandwich;

const foo = {
  bar: {
    x: 10,
  },
};
const {
  bar: { x },
} = foo;

const morning = {
  breakfast: 'oatmeal',
  lunch: 'peanut butter and jelly',
};
const dinner = 'mac and cheese';
console.log({ ...morning, dinner });
```

Today, React is beginning to move away from classes, instead using functions to construct components.

ES6 Module -> import, export? CommonJS -> module.exports, require

## 3. Functional Programming with JavaScript

Many of the features that are included in the latest JS syntax are present because they support functional programming techniques. In functional JS, we can think of out code as being a collection of functions that can be composed into applications.

함수형 프로그래밍은 선언형 프로그래밍이라는 더 넓은 범주의 프로그래밍 기법에 속한다.

Declarative programming is a style of programming where applications are structured in a way that prioritizes describing what should happen over defining how it should happen.

In a declarative program, the syntax itself describes what souel happen, and the details of how things happen are abstracted away.

[Declarative Programming wiki](http://wiki.c2.com/?DeclarativeProgramming)

```js
// Building a DOM

// Imperative approach
const target = document.getElementById('target');
const wrapper = document.createElement('div');
const headline = document.createElement('h1x');

wrapper.id = 'welcome';
headline.innerText = 'Hello World';

wrapper.appendChild(headline);
target.appendChild(wrapper);

// Declarative approach
const { render } = ReactDOM;

const Welcom = () => (
  <div id="welcome">
    <h1>Hello World</h1>
  </div>
);

render(<Welcome />, document.getElementById('target'));
```

> React is declarative.

Core concepts of functional programming

- Immutability
- Purity
- Data transformation
- High-order functions
- Recursion

```js
const rateColor = function (color, rating) {
  // return Object.assign({}, color, {rating: rating});
  return { ...color, rating };
};
```

> A pure function is a function that returns a value that's computed based on its arguments. Pure functions are naturally testable.

> In React, the UI is expressed with pure functions.

When writing functions, try to follow these three rules:

1. The function should take in at least one argument.
2. The function should return a value or another function.
3. The function should not change or mutate any of its arguments.

```js
const arr = ['1', '2', '3'];
console.log(arr.reduceRight((a, b) => a + b)); // 321, 배열의 끝에서부터 시작
```

> In mathematics and computer science, currying is the technique of converting a function that takes multiple arguments into a sequence of functions that each takes a single argument.

```js
async function getFakeMembers(count) {
  let res = await fetch(`https://api.randomuser.me/?nat=US&results=${count}`);
  let { results } = await res.json();
  return results;
}

const userLogs = (userName) => (message) => console.log(`${userName} -> ${message}`);
const log = userLogs('grandpa23');
log('attempted to load 20 fake members');

getFakeMembers(10).then((members) => log(`successfully loaded ${members.length} members`));
```

Recursion is a pattern that works particularly well with asynchronous processes. Functions can recall themselves when they're ready, like when the data is available or when a timer has finished.

```js
const countdown = (value, fn, delay = 1000) => {
  fn(value);
  return value > 0 ? setTimeout(() => countdown(value - 1, fn, delay), delay) : value;
};

countdown(10, console.log);
```

Composition

A more elegant approach is to create a higher-order function we can use to compose functions into larger functions

```js
const both = (date) => appendAMPM(civilianHours(date));

const compost =
  (...fns) =>
  (arg) =>
    fns.reduce((composed, f) => f(composed), arg);
const betterBoth = compose(civilianHours, appendAMPM);
```

In functional programs, we should use functions over values wherever possible.

[λ-Calculus: Then & Now](https://turing100.acm.org/lambda_calculus_timeline.pdf)

## 4. How React Works

> JSX is a tag-based JS syntax that looks a lot like HTML

> React is the library for creating views.

> ReactDOM is the library used to actually render the UI in the browser.

HTML is simply a set of instructions that a browser follows when constructing the DOM.

AJAX의 발명으로 웹 앱 전체가 UI 업데이트를 JS에 맏겨 단일 페이지에서 동작할 수있게 되었다. SPA에서브라우저는 하나의 HTML 문서를 로드한다.

리액트는 DOM을 우리 대신 업데이트하도록 디자인된 라이브러리이다.

React DOM은 React element로 구성되어있다.

```html
<body>
  <div id="root"></div>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script>
    const dish = React.createElement('h1', { id: 'recipe-0' }, 'Baked Salmon');
    console.log(dish);
    /*
        $$typeof: Symbol(react.element)
        key: null
        props: {id: 'recipe-0', children: 'Baked Salmon'}
        ref: null
        type: "h1"
        _owner: null
        _store: {validated: false}
        _self: null
        _source: null
        [[Prototype]]: Object
        */
    // _ 와 $$ 붙은건 리액트 내부용 같고 key, ref, type, props가 중요.
    // type은 생성할 HTML/SVG의 종류를 의미
    // props는 DOM 요소를 구성하기 위해 필요한 데이터들과 자식 요소.

    // ReactDOM.render is no longer supported in React 18.
    // ReactDOM.render(dish, document.getElementById('root'));
    // https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html#updates-to-client-rendering-apis
    const dessert = React.createElement('h2', null, 'Coconut Cream Pie');
    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render([dish, dessert]);
    // Warning: Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.

    // JSX 형식이 아닌 createElement로 뒤덮인 코드가 브라우저에서 결과적으로 돌아가는 코드다.
  </script>
</body>
```

The major advantage of using React is its ability to separate data from UI elements.

```html
<body>
  <div id="root"></div>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script>
    const items = [
      '2 lb salmon',
      '5 sprigs fresh rosemary',
      '2 tablespoons olive oil',
      '2 small lemons',
    ];
    const ingredients = React.createElement(
      'ul',
      { className: 'ingredients' },
      // key 프로퍼티는 DOM을 효과적으로 업데이트하기 위해 사용된다.
      items.map((ingredient, i) => React.createElement('li', { key: i }, ingredient))
    );

    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(ingredients);
  </script>
</body>
```

Components allow us to reuse the same structure, and then we can populate those structures with different sets of data.

```html
<body>
  <div id="root"></div>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script>
    const items = [
      '2 lb salmon',
      '5 sprigs fresh rosemary',
      '2 tablespoons olive oil',
      '2 small lemons',
    ];
    function IngredientsList({ items }) {
      return React.createElement(
        'ul',
        { className: 'ingredients' },
        items.map((ingredient, i) => React.createElement('li', { key: i }, ingredient))
      );
    }

    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    // 그냥 IngredientsList({ items }) 하면 안되나??
    root.render(React.createElement(IngredientsList, { items }));
  </script>
</body>
```

## 5. React with JSX

> JSX combines the JS from JavaScript and the X from XML. It is a JS extension that allows us to define React elements using a tag-based syntax directly within our JS code.

```jsx
React.createElement(IngredientsList, {list: [...]});
<Ingredients list={[...]}>
// 여기서도 그냥 IngredientesList({[...]}) 해주면 안되나?
// 기계적 변환이라서 어쩔 수 없는건가,,
// 모든 JSX는 Babel을 통해 createElement 호출로 변환된다.
```

Component 프로퍼티들은 string이나 중괄호로 쌓인 JS expression 두 타입만 받는다. 중괄호로 쌓인 것들은평가(evaluate)된다.

[CDN](https://www.cloudflare.com/ko-kr/learning/cdn/what-is-a-cdn/)

```html
<body>
  <div id="root"></div>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel">
    const data = [
      {
        name: 'Baked Salmon',
        ingredients: [{ name: 'Salmon', amount: 1, measurement: 'l lb' }],
        steps: ['Preheat the oven to 350 degrees.'],
      },
      {
        name: 'Fish Tacos',
        ingredients: [
          { name: 'Whitefish', amount: 1, measurement: 'l lb' },
          { name: 'Cheese', amount: 1, measurement: 'cup' },
        ],
        steps: [
          'Cook the fish on the grill until cooked through.',
          'Place the fish on the 3 tortillas.',
        ],
      },
    ];

    function Recipe({ name, ingredients, steps }) {
      return (
        <section id={name.toLowerCase().replace(/ /g, '-')}>
          {/* Safari에서 h1이 더 작음,, 왜??? */}
          <h1>{name}</h1>
          <ul className="ingredients">
            {ingredients.map((ingredient, i) => (
              <li key={i}>{ingredient.name}</li>
            ))}
          </ul>
          <section className="instructions">
            <h2>Cooking Instructions</h2>
            {steps.map((step, i) => (
              <p key={i}>{step}</p>
            ))}
          </section>
        </section>
      );
    }

    function Menu({ title, recipes }) {
      return (
        <article>
          <header>
            <h1>{title}</h1>
          </header>
          <div className="recipes">
            {recipes.map((recipe, i) => (
              <Recipe key={i} {...recipe} />
            ))}
          </div>
        </article>
      );
    }

    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<Menu recipes={data} title="Delicious Recipes" />);
  </script>
</body>
```

> If we use a React fragment, we can mimic the behavior of a wrapper without actually creating a new tag.

Webpack 관련은 스킵.

## 6. React State Management

지난 챕터에서 데이터가 프로퍼티를 따라 flow할 수 있는 component tree를 만들었다. Properties are half of the picture. State is the other half.

> The state of a React application is driven by data that has the ability to change.

```js
// 이런 식의 export는 어떻게 하는걸까?
// React state를 사용해 변화하는 값을 저장하고 수정한다.
// Hooks contain reusable code logic that is separate from the component tree.
// Hook the component with state.
import React, { useState } from 'react';
import { FaStar } from 'react-icons/fa';

const Star = ({ selected, onSelect }) => (
  // 책에서는 에러를 막기 위해 onSelect에 f => f를 할당했지만 딱히 없어도 터지지는 않는다,,,?
  // onClick에 console.log('asd')를 하면 맨 처음 한번 실행되고 끝난다.
  <FaStar color={selected ? 'red' : 'grey'} onClick={onSelect} />
);
const createArray = (length) => [...Array(length)];

export function StarRating({ totalStars = 5 }) {
  // The most important thing to remember about Hooks is that they can cause the component they're hooked into to rerender.
  // 어떤 원리로????
  // 개발자 모드로 봤을 때 바뀌어야하는 별의 색만 바뀌는 듯.
  // StarRating을 선택하면 hooks를 볼 수 있다.
  const [selectedStars, setSelectedStars] = useState(3);
  return (
    <>
      {createArray(totalStars).map((n, i) => (
        <Star key={i} selected={selectedStars > i} onSelect={() => setSelectedStars(i + 1)} />
      ))}
      <p>
        {selectedStars}개 중 {totalStars}개 선택
      </p>
    </>
  );
}

// ColorList 예제에서 사용하기 위한 pure component
// A pure component is a function component that does not contain state and will render the same UI given the same props.
export function PureStarRating({ totalStars, selectedStars, onRate = (f) => f }) {
  return (
    <>
      {createArray(totalStars).map((n, i) => (
        <Star key={i} selected={selectedStars > i} onSelect={() => onRate(i + 1)} />
      ))}
      <p>
        {selectedStars}개 중 {totalStars}개 선택
      </p>
    </>
  );
}
```

무분별한 state의 사용은 디버깅을 어렵게하고 프로그램을 바꾸기 어렵게 만든다. 해결법 중 하나는 state 를 component tree의 루트에서 자식 컴포넌트로 props를 통해 전달하는 것이다.

```js
import React, { useState } from 'react';
import colorData from './color-data.json';
import ColorList from './ColorList';
import BetterAddColorForm from './AddColorForm';
import { v4 } from 'uuid';

// The App component will be the only component within out application that holds state.
export default function App() {
  const [colors, setColors] = useState(colorData);
  return (
    <>
      <BetterAddColorForm
        onNewColor={(title, color) => {
          const newColors = [
            ...colors,
            {
              id: v4(),
              rating: 0,
              title,
              color,
            },
          ];
          setColors(newColors);
        }}
      />
      <ColorList
        colors={colors}
        onRateColor={(id, rating) => {
          const newColors = colors.map((color) => (color.id === id ? { ...color, rating } : color));
          setColors(newColors);
        }}
        onRemoveColor={(id) => {
          const newColors = colors.filter((color) => color.id !== id);
          setColors(newColors);
        }}
      />
    </>
  );
}
```

```js
import React from 'react';
import { FaTrash } from 'react-icons/fa';
import { PureStarRating } from './starRating';

export default function ColorList({
  colors = [],
  onRemoveColor = (f) => f,
  onRateColor = (f) => f,
}) {
  if (!colors.length) return <div>No Colors Listed.</div>;
  return (
    <div>
      {colors.map((color) => (
        <Color key={color.id} {...color} onRemove={onRemoveColor} onRate={onRateColor} />
      ))}
    </div>
  );
}

function Color({ id, title, color, rating, onRemove = (f) => f, onRate = (f) => f }) {
  return (
    <section>
      <h1>{title}</h1>
      <button onClick={() => onRemove(id)}>
        <FaTrash />
      </button>
      <div style={{ height: 50, backgroundColor: color }} />
      <PureStarRating
        selectedStars={rating}
        totalStars={5}
        onRate={(rating) => onRate(id, rating)}
      />
    </section>
  );
}
```

Just as we passed data down a component tree via props, interactinos can be passed back up the tree along with data via functino properties.

> In React, a ref if an object that stores values for the lifetime of a component.

```js
import React, { useRef } from 'react';
import { useInput } from './useInput';

// DOM 노드의 value 어트리뷰트를 ""로 직접 설정한다. 이는 선언적이지 않고 명령적이다. AddColorForm은 form값을 저장하기 위해 DOM을 사용하는 uncontrolled component라 한다.
function AddColorForm({ onNewColor = (f) => f }) {
  const txtTitle = useRef();
  const hexColor = useRef();
  const submit = (e) => {
    // HTML form을 submit할 때 기본 동작으로 POST request를 한다. 이를 방지.
    e.preventDefault();
    const title = txtTitle.current.value;
    const color = hexColor.current.value;
    onNewColor(title, color);
    txtTitle.current.value = '';
    hexColor.current.value = '';
  };
  return (
    <form onSubmit={submit}>
      // ref를 통해 설정한 object의 current 필드를 통해 DOM 요소에 직접 접근할 수 있다.
      <input ref={txtTitle} type="text" placeholder="color title..." required />
      <input ref={hexColor} type="color" required />
      <buttom>ADD</buttom>
    </form>
  );
}

// controlled component에서는 값/state가 DOM이 아니라 React에 의해 관리된다.
// refs들을 사용할 필요가 없다.
export default function BetterAddColorForm({ onNewColor = (f) => f }) {
  const [titleProps, resetTitle] = useInput('');
  const [colorProps, resetColor] = useInput('#000000');

  const submit = (e) => {
    // HTML form을 submit할 때 기본 동작으로 POST request를 한다. 이를 방지.
    e.preventDefault();
    onNewColor(titleProps.value, colorProps.value);
    resetTitle();
    resetColor();
  };
  return (
    <form onSubmit={submit}>
      <input
        /*
                    // value를 설정하면 form을 통한 변화가 불가능해진다. 
                    value={title}
                    // Component의 렌더가 빈번하지만 React는 이를 고려해 디자인되었다. 
                    onChange={event => setTitle(event.target.value)}
                */
        {...titleProps}
        type="text"
        placeholder="color title..."
        required
      />
      <input {...colorProps} type="color" required />
      <button>ADD</button>
    </form>
  );
}
```

```js
import { useState } from 'react';

// Custom hook
export const useInput = (initialValue) => {
  const [value, setValue] = useState(initialValue);
  return [{ value, onChange: (e) => setValue(e.target.value) }, () => setValue(initialValue)];
};
```

하지만 여러 요소를 지나 데이터를 건네는 것은 데이터를 사용하는 곳과 넣는 곳이 너무 먼 문제점을 낳는다.

> A context provider is a React component you can wrap around your entire component tree or specific sections of your component tree.

> The context consumer is the React component that retrieves the data from context.

```js
import React, { createContext, useContext, useState } from 'react';
import colorData from './color-data';
import ReactDOM from 'react-dom/client';
import App from './App.js';
import v4 from 'uuid';

// ColorContext.consumer을 사용해야하기에 export
// ...했지만 아래 useColor를 사용한는 방식이 더 깔끔.
const ColorContext = createContext();
// Wrap all of the functionality necessary to render and work with stateful colors in a single JS module.
// 함수로 표현한 것이 신기. 왜 상수가 아니지?
export const useColors = () => useContext(ColorContext);

// Context provider 자체로는 내부의 값을 수정할 수 없고, Context provider를 렌더하는 stateful component를 만들면 된다.
function ColorProvider({ children }) {
  const [colors, setColors] = useState(colorData);
  // setColor는 context 내부의 모든 유저에게 수정의 권한을 주니 좋지 않다.
  /*
    return (
        <ColorContext.Provider value={{ colors, setColors }}
        >
            {children}
        </ColorContext.Provider>
    )
    */

  // 필요한 동작과 관련된 함수들만을 전달한다.
  const addColor = (title, color) =>
    setColors([
      ...colors,
      {
        id: v4(),
        rating: 0,
        title,
        color,
      },
    ]);
  const rateColor = (id, rating) =>
    setColors(colors.map((color) => (color.id === id ? { ...color, rating } : color)));
  const removeColor = (id) => setColors(colors.filter((color) => color.id !== id));

  return (
    <ColorContext.Provider value={{ colors, addColor, removeColor, rateColor }}>
      {children}
    </ColorContext.Provider>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <ColorProvider>
      <App />
    </ColorProvider>
  </React.StrictMode>
);
```

```js
import React from 'react';
import { useColors } from './';
import { FaTrash } from 'react-icons/fa';
import { PureStarRating } from './starRating';

export default function ColorList() {
  // The Consumer is accessed within the useContext hook, which mean that we no longer have to work directly with the consumer component.
  const { colors } = useColors();
  if (!colors.length) return <div>No Colors Listed.</div>;
  return (
    <div>
      {colors.map((color) => (
        <Color key={color.id} {...color} />
      ))}
    </div>
  );
}

function Color({ id, title, color, rating }) {
  const { rateColor, removeColor } = useColors();
  return (
    <section>
      <h1>{title}</h1>
      <button onClick={() => removeColor(id)}>
        <FaTrash />
      </button>
      <div style={{ height: 50, backgroundColor: color }} />
      <PureStarRating
        selectedStars={rating}
        totalStars={5}
        onRate={(rating) => rateColor(id, rating)}
      />
    </section>
  );
}
```

Hook을 통해 렌더링 부분과 로직 부분을 분리할 수 있다.

## 7. Enhancing Components with Hooks

- useState, useRef, useContext
- useEffect, useLayoutEffect, useReducer
- useCallback, useMemo

> We use useEffect when a render needs to cause side effects.

> Those things we want the component to do other than return UI are called effects.

렌더가 이루어질 때마나, useEffect는 렌더 이후의 최신 값들에 접근할 수 있다.

```jsx
useEffect(() => {
  localStorage.setItem('checkbos-value', checked);
});
```

```js
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom/client';

function App() {
  const [val, set] = useState('');
  const [phrase, setPhrase] = useState('example phrase');

  const createPhrase = () => {
    setPhrase(val);
    set('');
  };

  // The dependency array can be used to control when an effect is invoked.
  useEffect(() => {
    console.log(`typing ${val}`);
  }, [val]);

  useEffect(() => {
    console.log(`saved phrase: ${phrase}`);
  }, [phrase]);

  // 빈 배열은 초기 렌더에서만 useEffect가 실행되도록 한다. 의존성이 없는 것은 변화가 없음을 의미하기 때문이다. 초기 설정에 매우 유용하게 사용된다.
  useEffect(() => {
    console.log('initial');
    return () => console.log('end');
  }, []);

  return (
    <>
      <label>Favorite phrase: </label>
      <input value={val} placeholder={phrase} onChange={(e) => set(e.target.value)} />
      <button onClick={createPhrase}>send</button>
    </>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

이런 식의 custom hook을 만들 수도 있다.

```jsx
const useJazzyNews = () => {
  const [posts, setPosts] = useState([]);
  const addPost = (post) => setPosts((allPosts) => [post, ...allPosts]);

  useEffect(() => {
    newsFeed.subscribe(addPost);
    return () => newsFeed.unsubscribe(addPost);
  }, []);

  useEffect(() => {
    welcomeChime.play();
    return () => goodbyeChime.play();
  }, []);

  return posts;
};
```

Dependency array에 객체를 넣으면, rerender마다 새로운 인스턴스가 생기기에 useEffect가 매번 불리게 된다.

> useMemo invokes a function to calculate a memoized value.

Memoization할 때 그 memo. Dependency가 바뀔 때만 값을 재계산하여 반환한다.

```jsx
// 반환값 타입이 뭘까,,,?
const words = useMemo(() => {
  const words = children.split(' ');
  return words;
}, [children]);

useEffect(() => {
  console.log('fresh render');
}, [words]);
```

> useCallback can be used like useMemo, but it memoizes functions instead of values.

useMemo와 useCallback을 사용하여 useJazzyNews를 개선할 수 있다.

```jsx
const useJazzyNews = () = {
    const [_posts, setPosts] = useState([]);
    const addPost = post => setPosts(allPosts => [post, ...allPosts]);

    const posts = useMemo(() => _posts, [_posts]);

    useEffect(() => {
        newPostChime.play();
    }, [posts]);

    // 이하 동일
}
```

> **useLayoutEffect** is invoked after the render but before the browser paints the change.

> Browser paint: the time when the components' elements are actually added to the DOM

**Render** > useLayoutEffect > Browser paint > useEffect. 렌더가 가장 먼저네??

Browser paint에 반드시 필요한 effect이면 useLayoutEffect를 사용한다.

```jsx
function useWindowSize() {
  const [width, setWidth] = useState(0);
  const [height, setHeight] = useState(0);

  const resize = () => {
    setWidth(window.innerWidth);
    setHeight(window.innerHeight);
  };

  useLayoutEffect(() => {
    window.addEventListener('resize', resize);
    resize();
    return () => window.removeEventListener('resize', resize);
  }, []);

  return [width, height];
}
```

### Rules to Follow with Hooks

- Hooks only run in the scope of a component.
- It's a good idea to break funtionality out into multiple Hooks.
- Hooks should only be called at the top level. if문을 써야되면 hook안에서.

> Lazy initial state. The initialState argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render.

hook 안에 async function이 필요하면 argument로 전달은 안되고 nested function에서처리해야한다.

### Improving Code with useReducer

> Instead of hardcoding behavior, we can abstract logic into a **reducer function** that will always produce the same result.

```jsx
const [checked, setChecked] = useState(false);
// 불필요하게 복잡하다.
<input
    onchange{() => setChecked(checked => !checked)}
/>

// If the same input is provided to a function, the sam eoutput should be expected.
const [checked, toggle] = useReducer(checked => !checked, false);
const [number, setNumber] = useReducer((number, newNumber) => number+newNumber, 0);
```

> In React, a pure component is a component that always renders the same output, given the saem properties.

> The memo function can be used to create a component that will only render when its properties change.

```jsx
const Cat = ({name, meow = f => f}) = {
    return <p onClick={() => meow(name)}>{name}</p>;
}
// PureCat will only cause the Cat to render when the properties change.
// Second argument sent to the memo function is a predicate.
// The function decides wheter to reerender a cat or not.
const PureCat = memo(
    Cat,
    (prevProps, nextProps) => prevProps.name === nextProps.name
);
// 위에 처럼 memo를 사용하거나, useCallback으로 변환한 meow를 건네주거나 둘 중 하나.
```

> The **React Profiler** can be used to measure the performance of each of your components.

## 8. Incorporating Data

In this chapter, we're going to take a look at various techniques for loading and working with data form the source.

### Requesting Data

파일을 POST하기 위해서는 body에 파일이 위치함을 서버에 알리는 multipart-formdata request가 필요하다. body에 FormData를 담아 보낸다.

```js
const formData = new FormData();
formData.append('avatar', imgFile);
fetch('/create/user', { method: 'POST', body: formData });
```

유저를 식별하기 위한 토큰은 보통 Authorization header에 담긴다. 토큰은 특정 서비스에 로그인하거나, open standard protocol인 OAuth를 사용하는 서드파티 웹에서 제공된다.

```js
import React, { useState, useEffect } from 'react';
import { loadJSON, saveJSON } from './storage';

export default function GitHubUser({ login }) {
  // Save the data to the browser
  const [data, setData] = useState(loadJSON(`user:${login}`));
  useEffect(() => {
    if (!data) return;
    if (data.login === login) return;
    const { name, avatar_url, location } = data;
    saveJSON(`user:${login}`, {
      name,
      login,
      avatar_url,
      location,
    });
  }, [data, login]);
  // React Hook useEffect has a missing dependency 때문에 책과 다르게 login을 추가

  // Request more data from GitHub.
  useEffect(() => {
    if (!login) return;
    if (data && data.login === login) return;
    fetch(`https://api.github.com/users/${login}`)
      .then((response) => response.json())
      .then(setData)
      .catch(console.error);
  }, [data, login]);

  if (data) return <pre>{JSON.stringify(data, null, 2)}</pre>;
  return null;

  // localStorage.clear() 전까지 4개의 요소만 있는 작은 객체가 뜬다.
}
```

> We can save data locally to the browser using the Web Storage API

- window.sessionStorage: 유저의 세션에 저장. 탭을 닫거나 브라우저를 재시작하면사라진다.
- window.localStorage: 제거 전까지 계속 남는다.

```js
// sync하니 사용에 주의
export const loadJSON = (key) => key && JSON.parse(localStorage.getItem(key));
export const saveJSON = (key, data) => localStorage.setItem(key, JSON.stringify(data));
```

Cache-Control: max-age=<EXP_DATE>를 통해 HTTP가 캐시를 처리할 수 있게 할 수도 있다.

```js
import React, { useState, useEffect } from 'react';

export default function GitHubUser({ login }) {
  const [data, setData] = useState();
  const [error, setError] = useState();
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    (async () => {
      if (!login) return;
      setLoading(true);
      try {
        const response = await fetch(`https://api.github.com/users/${login}`);
        const json = await response.json();
        setData(json);
        setLoading(false);
      } catch (e) {
        setError(e);
      }
    })();
  }, [login]);

  if (loading) return <h1>loading...</h1>;
  if (error) return <pre>{JSON.stringify(error, null, 2)}</pre>;
  if (!data) return null;

  return (
    <div>
      <img src={data.avatar_url} alt={data.login} style={{ width: 200 }} />
      <div>
        <h1>{data.login}</h1>
        {data.name && <p>{data.name}</p>}
        {data.location && <p>{data.location}</p>}
      </div>
    </div>
  );
}
```

### Render Props

> Properties that are rendered.

비동기 컴포넌트의 재사용성을 극대화시키는데 유용하다.

```js
import React from 'react';

export default function List({ data, renderItem, renderEmpty }) {
  return !data.length ? (
    renderEmpty
  ) : (
    <ul>
      {data.map((item, i) => (
        <li key={i}>{renderItem(item)}</li>
      ))}
    </ul>
  );
}
```

위 작업을 위한 더 나은 컴포넌트가 존재한다.

### Virtualized Lists

실제 앱에서는 데이터가 많고 이를 한번에 렌더할 수는 없다.

windowing/virtualization. 가장 유명한건 react-window/react-virtualized.

```js
import { faker } from '@faker-js/faker';
import List from './List';
import { FixedSizeList } from 'react-window';

const bigList = [...Array(5000)].map(() => ({
  name: faker.name.findName(),
  email: faker.internet.email(),
  avatar: faker.internet.avatar(),
}));

// 429 TOO MANY REQUESTS
export function NormalList() {
  const renderItem = (item) => (
    <div style={{ display: 'flex' }}>
      <img src={item.avatar} alt={item.name} width={50} />
      <p>
        {item.name} - {item.email}
      </p>
    </div>
  );
  return <List data={bigList} renderItem={renderItem} />;
}

export function BetterList() {
  const renderRow = ({ index, style }) => (
    <div style={{ ...style, ...{ display: 'flex' } }}>
      <img src={bigList[index].avatar} alt={bigList[index].name} width={50} />
      <p>
        {bigList[index].name} - {bigList[index].email}
      </p>
    </div>
  );

  // renderRow -> render props pattern
  return (
    <FixedSizeList
      height={window.innerHeight}
      width={window.innerWidth - 20}
      itemCount={bigList.length}
      itemSize={50}
    >
      {renderRow}
    </FixedSizeList>
  );
}
```

### --

```js
import { useEffect, useState } from 'react';

export default function useFetch(uri) {
  const [data, setData] = useState();
  const [error, setError] = useState();
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    (async () => {
      try {
        const response = await fetch(uri);
        const json = await response.json();
        setData(json);
        setLoading(false);
      } catch (e) {
        setError(e);
      }
    })();
  }, [uri]);

  return { loading, data, error };
}
```

```js
import useFetch from './useFetch';

export default function Fetch({
  uri,
  renderSuccess,
  loadingFallback = <p>loading...</p>,
  renderError = (error) => <pre>{JSON.stringify(error, null, 2)}</pre>,
}) {
  const { loading, data, error } = useFetch(uri);
  if (loading) return loadingFallback;
  if (error) return renderError(error);
  if (data) return renderSuccess({ data });
}
```

```js
import Fetch from './fetch';

export default function GitHubUser3({ login }) {
  return <Fetch uri={`https://api.github.com/users/${login}`} renderSuccess={UserDetails} />;
}

function UserDetails({ data }) {
  return (
    <div className="githubUser">
      <img src={data.avatar_url} alt={data.login} style={{ width: 200 }} />{' '}
      <div>
        <h1>{data.login}</h1>
        {data.name && <p>{data.name}</p>}
        {data.location && <p>{data.location}</p>}
      </div>
    </div>
  );
}
```

```js
import { useCallback, useState, useMemo } from 'react';

export const useIterator = (items = [], initialIndex = 0) => {
  const [i, setIndex] = useState(initialIndex);

  /*
    Memoizing these values does not give us huge performance gains, or at least not enough to justify the code complexity. However, when a consumer uses the useIterator component, the memoized values will always point to the exact same object and function. This makes it easier on our consumers when they need to compare these values or use them in their own dependency arrays.
    */
  const prev = useCallback(() => {
    if (i === 0) return setIndex(items.length - 1);
    setIndex(i - 1);
  }, [i]);

  const next = useCallback(() => {
    if (i === items.length - 1) return setIndex(0);
    setIndex(i + 1);
  }, [i]);

  const item = useMemo(() => items[i], [i]);

  return [item || items[i], prev, next];
};
```

```js
import React, { useEffect } from 'react';
import { useIterator } from './useIterator';
import Fetch from './Fetch';
import RepositoryReadme from './RepositoryReadme';

export default function UserDetails({ data }) {
  return (
    <div className="githubUser">
      <img src={data.avatar_url} alt={data.login} style={{ width: 200 }} />
      <div>
        <h1>{data.login}</h1>
        {data.name && <p>{data.name}</p>}
        {data.location && <p>{data.location}</p>}
      </div>
      <UserRepos login={data.login} onSelect={(repoName) => console.log(`${repoName} selected`)} />
    </div>
  );
}

export function UserRepos({ login, onSelect = (f) => f }) {
  return (
    <Fetch
      uri={`https://api.github.com/users/${login}/repos`}
      renderSuccess={({ data }) => (
        <RepoMenu repositories={data} login={login} onSelect={onSelect} />
      )}
    ></Fetch>
  );
}

export function RepoMenu({ repositories, login, onSelect = (f) => f }) {
  const [{ name }, previous, next] = useIterator(repositories);

  useEffect(() => {
    if (!name) return;
    onSelect(name);
  }, [name]);

  return (
    <>
      <div style={{ display: 'flex' }}>
        <button onClick={previous}>&lt;</button>
        <p>{name}</p>
        <button onClick={next}>&gt;</button>
      </div>
      <RepositoryReadme login={login} repo={name} />
    </>
  );
}
```

> 유저 정보를 불러오고 이후 유저의 레포 목록을 불러온다. We call these requests waterfall requests because they happen one right after the other—they’re dependent on each other.

```js
import { useCallback, useEffect, useState } from 'react';
import ReactMarkdown from 'react-markdown';

// export default는 이 경우에 안되네?
const loadReadme = async (login, repo) => {
  const uri = `https://api.github.com/${login}/${repo}/readme`;
  const { download_url } = await fetch(uri).then((res) => res.json());
  const markdown = await fetch(download_url).then((res) => res.text());
  return markdown;
};

export default function RepositoryReadme({ repo, login }) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState();
  const [markdown, setMarkdown] = useState('');

  const loadReadme = useCallback(async (login, repo) => {
    setLoading(true);
    const uri = `https://api.github.com/repos/${login}/${repo}/readme`;
    const { download_url } = await fetch(uri).then((res) => res.json());
    const markdown = await fetch(download_url).then((res) => res.text());
    setMarkdown(markdown);
    setLoading(false);
  }, []);

  useEffect(() => {
    if (!repo || !login) return;
    loadReadme(login, repo).catch(setError);
  }, [repo]);

  if (error) return <pre>{JSON.stringify(error, null, 2)}</pre>;
  if (loading) return <p>Loading...</p>;
  return <ReactMarkdown>{markdown}</ReactMarkdown>;
}
```

크롬의 Network 탭에서 네트워크 속도를 조절할 수 있다. XHR로 필터링하여 fetch 만골라서 볼 수 있다. Waterfall에서 그래프도 볼 수 있음.

이후 책에서 위 구조를 평면화? 병렬화?하는 작업을 하지만 생략.

리액트 요소가 사라졌는데 업데이트를 시도하면(네트워크가 느린 등의 이유로 인해) 'Can't perform a React state update on an unmounted component.'라는 경고가 뜬다.

```js
// useState를 안쓰는 이유??
/*
Keep in mind that useRef doesn’t notify you when its content changes. Mutating the .current property doesn’t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a callback ref instead.
*/
// 리렌더링과 관련된 듯?
export function useMountedRef() {
  const mounted = useRef(false);
  useEffect(() => {
    mounted.current = true;
    return () => (mounted.current = false);
  });
  return mounted;
}
```

It’s always a good idea to test your app under slow network conditions. These bugs will be revealed and eliminated.

### Introducing GraphQL

> GraphQL is a declarative solution for communicating with APIs. A GraphQL query is a declarative description of the data we’re requesting.

GraphQL 관련은 일단 스킵.

## 9. Suspense

스킵.

## 10. React Testing

스킵

## 11. React Router

> **Routing** is the process of defining endpoints for your client’s requests.

> Each **route** is an endpoint that can be entered into the browser's location bar.

> The **Router component** passes information about the current location to any children that are nested inside of it. The Router component should be used once and placed near the root of our component tree.

> The wrapper component for any routes we want to render is called **Routes**. Inside of Routes, we’ll use a **Route component** for each page we want to render.

Routes가 Router에게 window의 위치가 바뀌었을 때 어떤 컴포넌트를 렌더할지 알려준다.

모든 Route 컴포넌트는 window의 현 위치에 따라 이들을 선택하는 Routes에 감싸져야한다.

```js
import App from './App';
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter as Router } from 'react-router-dom';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Router>
      <App />
    </Router>
  </React.StrictMode>
);
```

```js
import React from 'react';
import { Routes, Route, useLocation } from 'react-router-dom';

import { About, Events, Products, Contact } from './pages';
import { Home } from './Home';

export default function App() {
  return (
    <div>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/events" element={<Events />} />{' '}
        <Route path="/products" element={<Products />} />
        <Route path="/contact" element={<Contact />} />
        <Route path="*" element={<Whoops404 />} />
      </Routes>
    </div>
  );
}

function Whoops404() {
  const location = useLocation();
  console.log(location);
  return (
    <div>
      <h1>{location.pathname}</h1>
    </div>
  );
}
```

```js
import { Link } from 'react-router-dom';

export function Home() {
  return (
    <div>
      <h1>[Company Website]</h1>
      <nav>
        <Link to="about">About</Link>
        <Link to="events">Events</Link>
        <Link to="products">Products</Link>
        <Link to="contact">Contact Us</Link>
      </nav>
    </div>
  );
}
```

페이지에 위계를 주고 싶으면 아래와 같이 Route를 nest하면 된다.

```jsx
function App() {
  return (
    <div>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="about" element={<About />}>
          <Route path="services" element={<Services />} />
          <Route path="history" element={<History />} />
          <Route path="location" element={<Location />} />
        </Route>
        <Route path="events" element={<Events />} />
        <Route path="products" element={<Products />} /> <Route
          path="contact"
          element={<Contact />}
        />
        <Route path="*" element={<Whoops404 />} />
      </Routes>
    </div>
  );
}
```

이때 /about/history에서 About은 보이지만 History는 보이지 않는데, 이 때 Outlet을사용한다. Child Content를 렌더링하고 싶은 곳에 Outlet을 배치한다.

Redirect로 리다이렉트한다.

```jsx
<Redirect from="services" to="about/services" />
```

Routing parameter 생략.

## 12. React and the Server
